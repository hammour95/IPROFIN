require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var css = "/* BASIC */\n\n.biojs_msa_stage {\n    cursor: default;\n    line-height: normal; \n}\n\n.biojs_msa_seqblock {\n    cursor: move;\n}\n\n.biojs_msa_layer{\n    display: block;\n    white-space: nowrap;\n}\n\n.biojs_msa_labels {\n    color:black;\n    display: inline-block;\n    white-space: nowrap;\n    cursor: pointer;\n    vertical-align:middle;\n    overflow: hidden;\n    text-overflow: clip;\n    /*margin:auto; */\n    text-align: left;\n}\n\n.biojs_msa_header {\n    white-space: nowrap;\n    text-align: left;\n}\n\n.biojs_msa_labelrow:before {\n    content: '';\n    display: inline-block;\n    width: 0;\n    height: 100%;\n    vertical-align: middle;\n}\n\n.biojs_msa_labelrow{\n    height: 100%;\n}\n\n.biojs_msa_labelblock::-webkit-scrollbar, .biojs_msa_rheader::-webkit-scrollbar{\n    // FIX scrollbars on Mac\n    -webkit-appearance: none;\n    width: 7px;\n    height: 7px;\n}\n.biojs_msa_labelblock::-webkit-scrollbar-thumb, .biojs_msa_rheader::-webkit-scrollbar-thumb{\n    border-radius: 4px;\n    background-color: rgba(0,0,0,.5);\n    box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n\n/* END BASIC */\n/* Marker */\n\n.biojs_msa_marker{\n    color:grey;\n    white-space: nowrap;\n    cursor: pointer;\n}\n\n.biojs_msa_marker span{\n    text-align: center;\n}\n\n/* END Marker */\n/* Menubar */\n\n.smenubar .smenubar_alink {\n    background: #3498db;\n    background-image: -webkit-linear-gradient(top, #3498db, #2980b9);\n    background-image: -moz-linear-gradient(top, #3498db, #2980b9);\n    background-image: -ms-linear-gradient(top, #3498db, #2980b9);\n    background-image: -o-linear-gradient(top, #3498db, #2980b9);\n    background-image: linear-gradient(to bottom, #3498db, #2980b9);\n    -webkit-border-radius: 28;\n    -moz-border-radius: 28;\n    border-radius: 28px;\n    font-family: Arial;\n    color: #ffffff;\n    padding: 3px 10px 3px 10px;\n    margin-left: 10px;\n    text-decoration: none;\n}\n.smenubar {\n    display: inline-block;\n}\n\n.smenubar .smenubar_alink:hover {\n    cursor: pointer;\n}\n\n\n/* jquery dropdown CSS */\n\n.smenu-dropdown {\n    position: absolute;\n    z-index: 9999999;\n    display: none;\n}\n\n.smenu-dropdown .smenu-dropdown-menu,\n.smenu-dropdown .smenu-dropdown-panel {\n    min-width: 160px;\n    max-width: 360px;\n    list-style: none;\n    background: #FFF;\n    border: solid 1px #DDD;\n    border: solid 1px rgba(0, 0, 0, .2);\n    border-radius: 6px;\n    box-shadow: 0 5px 10px rgba(0, 0, 0, .2);\n    overflow: visible;\n    padding: 4px 0;\n    margin: 0;\n}\n\n.smenu-dropdown .smenu-dropdown-panel {\n    padding: 10px;\n}\n\n\n.smenu-dropdown.smenu-dropdown-scroll .smenu-dropdown-menu,\n.smenu-dropdown.smenu-dropdown-scroll .smenu-dropdown-panel {\n    max-height: 358px;\n    overflow: auto;\n}\n\n.smenu-dropdown .smenu-dropdown-menu LI {\n    list-style: none;\n    padding: 0 0;\n    margin: 0;\n    line-height: 18px;\n}\n\n.smenu-dropdown .smenu-dropdown-menu LI,\n.smenu-dropdown .smenu-dropdown-menu LABEL {\n    display: block;\n    color: #555;\n    text-decoration: none;\n    line-height: 18px;\n    padding: 3px 15px;\n    white-space: nowrap;\n}\n\n.smenu-dropdown .smenu-dropdown-menu LI:hover,\n.smenu-dropdown .smenu-dropdown-menu LABEL:hover {\n    background-color: #08C;\n    color: #FFF;\n    cursor: pointer;\n}\n\n.smenu-dropdown .smenu-dropdown-menu .smenu-dropdown-divider {\n    font-size: 1px;\n    border-top: solid 1px #E5E5E5;\n    padding: 0;\n    margin: 5px 0;\n}\n\n/* END Menubar */\n"; (require("/home/travis/build/greenify/msa/node_modules/cssify"))(css); module.exports = css;
},{"/home/travis/build/greenify/msa/node_modules/cssify":65}],2:[function(require,module,exports){
var _ = require('underscore');
var viewType = require("backbone-viewj");
var pluginator;

/**
 * Remove an element and provide a function that inserts it into its original position
 * @param element {Element} The element to be temporarily removed
 * @return {Function} A function that inserts the element into its original position
 **/
function removeToInsertLater(element) {
  var parentNode = element.parentNode;
  var nextSibling = element.nextSibling;
  parentNode.removeChild(element);
  return function() {
    if (nextSibling) {
      parentNode.insertBefore(element, nextSibling);
    } else {
      parentNode.appendChild(element);
    }
  };
}

var removeChilds = function (node) {
    var last;
    while (last = node.lastChild) node.removeChild(last);
};

module.exports = pluginator = viewType.extend({
  renderSubviews: function() {
    // it is faster to remove the entire element and replace it
    // -> however this will lead to lost id,class and style props
    var oldEl = this.el;

    // it might be that the element is not on the DOM yet
    var elOnDom = oldEl.parentNode != undefined;
    if(elOnDom){
      var insert = removeToInsertLater(oldEl)
    }
    removeChilds(oldEl);

    var frag = document.createDocumentFragment();
    var views = this._views();
    var viewsSorted = _.sortBy(views, function(el) {
      return el.ordering;
    });
    var view, node;
    for (var i = 0; i <  viewsSorted.length; i++) {
      view = viewsSorted[i];
      view.render();
      node = view.el;
      if (node != null) {
        frag.appendChild(node);
      }
    }

    oldEl.appendChild(frag);
    if(elOnDom){
      insert();
    }
    return oldEl;
  },
  addView: function(key, view) {
    var views = this._views();
    if (view == null) {
      throw "Invalid plugin. ";
    }
    if (view.ordering == null) {
      view.ordering = key;
    }
    return views[key] = view;
  },
  removeViews: function() {
    var el, key;
    var views = this._views();
    for (key in views) {
      el = views[key];
      el.undelegateEvents();
      el.unbind();
      if (el.removeViews != null) {
        el.removeViews();
      }
      el.remove();
    }
    return this.views = {};
  },
  removeView: function(key) {
    var views = this._views();
    views[key].remove();
    return delete views[key];
  },
  getView: function(key) {
    var views = this._views();
    return views[key];
  },
  remove: function() {
    this.removeViews();
    return viewType.prototype.remove.apply(this);
  },
  _views: function() {
    if (this.views == null) {
      this.views = {};
    }
    return this.views;
  }
});

},{"backbone-viewj":9,"underscore":91}],3:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

var Events = require("backbone-events-standalone");
var extend = require("backbone-extend-standalone");
var _ = require("underscore");
var Model = require("./model");

// Create local references to array methods we'll want to use later.
var array = [];
var slice = array.slice;

// Backbone.Collection
// -------------------

// If models tend to represent a single row of data, a Backbone Collection is
// more analogous to a table full of data ... or a small slice or page of that
// table, or a collection of rows that belong together for a particular reason
// -- all of the messages in this particular folder, all of the documents
// belonging to this particular author, and so on. Collections maintain
// indexes of their models, both in order, and for lookup by `id`.

// Create a new **Collection**, perhaps to contain a specific type of `model`.
// If a `comparator` is specified, the Collection will maintain
// its models in sort order, as they're added and removed.
var Collection = function(models, options) {
  options || (options = {});
  if (options.model) this.model = options.model;
  if (options.comparator !== void 0) this.comparator = options.comparator;
  this._reset();
  this.initialize.apply(this, arguments);
  if (models) this.reset(models, _.extend({silent: true}, options));
};

// Default options for `Collection#set`.
var setOptions = {add: true, remove: true, merge: true};
var addOptions = {add: true, remove: false};

// Define the Collection's inheritable methods.
_.extend(Collection.prototype, Events, {

  // The default model for a collection is just a **Backbone.Model**.
  // This should be overridden in most cases.
  model: Model,

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
  toJSON: function(options) {
    return this.map(function(model){ return model.toJSON(options); });
  },

    // Proxy `Backbone.sync` by default.
  sync: function() {
    return Backbone.sync.apply(this, arguments);
  },

    // Add a model, or list of models to the set.
  add: function(models, options) {
    return this.set(models, _.extend({merge: false}, options, addOptions));
  },

    // Remove a model, or a list of models from the set.
  remove: function(models, options) {
    var singular = !_.isArray(models);
    models = singular ? [models] : _.clone(models);
    options || (options = {});
    for (var i = 0, length = models.length; i < length; i++) {
      var model = models[i] = this.get(models[i]);
      if (!model) continue;
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      delete this._byId[model.cid];
      var index = this.indexOf(model);
      this.models.splice(index, 1);
      this.length--;
      if (!options.silent) {
        options.index = index;
        model.trigger('remove', model, this, options);
      }
      this._removeReference(model, options);
    }
    return singular ? models[0] : models;
  },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
  set: function(models, options) {
    options = _.defaults({}, options, setOptions);
    if (options.parse) models = this.parse(models, options);
    var singular = !_.isArray(models);
    models = singular ? (models ? [models] : []) : models.slice();
    var id, model, attrs, existing, sort;
    var at = options.at;
    var sortable = this.comparator && (at == null) && options.sort !== false;
    var sortAttr = _.isString(this.comparator) ? this.comparator : null;
    var toAdd = [], toRemove = [], modelMap = {};
    var add = options.add, merge = options.merge, remove = options.remove;
    var order = !sortable && add && remove ? [] : false;

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (var i = 0, length = models.length; i < length; i++) {
      attrs = models[i];

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(attrs)) {
        if (remove) modelMap[existing.cid] = true;
        if (merge && attrs !== existing) {
          attrs = this._isModel(attrs) ? attrs.attributes : attrs;
          if (options.parse) attrs = existing.parse(attrs, options);
          existing.set(attrs, options);
          if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
        }
        models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
      } else if (add) {
        model = models[i] = this._prepareModel(attrs, options);
        if (!model) continue;
        toAdd.push(model);
        this._addReference(model, options);
      }

      // Do not add multiple models with the same `id`.
      model = existing || model;
      if (!model) continue;
      id = this.modelId(model.attributes);
      if (order && (model.isNew() || !modelMap[id])) order.push(model);
      modelMap[id] = true;
    }

    // Remove nonexistent models if appropriate.
    if (remove) {
      for (var i = 0, length = this.length; i < length; i++) {
        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
      }
      if (toRemove.length) this.remove(toRemove, options);
    }

    // See if sorting is needed, update `length` and splice in new models.
    if (toAdd.length || (order && order.length)) {
      if (sortable) sort = true;
      this.length += toAdd.length;
      if (at != null) {
        for (var i = 0, length = toAdd.length; i < length; i++) {
          this.models.splice(at + i, 0, toAdd[i]);
        }
      } else {
        if (order) this.models.length = 0;
        var orderedModels = order || toAdd;
        for (var i = 0, length = orderedModels.length; i < length; i++) {
          this.models.push(orderedModels[i]);
        }
      }
    }

    // Silently sort the collection if appropriate.
    if (sort) this.sort({silent: true});

    // Unless silenced, it's time to fire all appropriate add/sort events.
    if (!options.silent) {
      var addOpts = at != null ? _.clone(options) : options;
      for (var i = 0, length = toAdd.length; i < length; i++) {
        if (at != null) addOpts.index = at + i;
        (model = toAdd[i]).trigger('add', model, this, addOpts);
      }
      if (sort || (order && order.length)) this.trigger('sort', this, options);
    }

    // Return the added (or merged) model (or models).
    return singular ? models[0] : models;
  },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
  reset: function(models, options) {
    options || (options = {});
    for (var i = 0, length = this.models.length; i < length; i++) {
      this._removeReference(this.models[i], options);
    }
    options.previousModels = this.models;
    this._reset();
    models = this.add(models, _.extend({silent: true}, options));
    if (!options.silent) this.trigger('reset', this, options);
    return models;
  },

    // Add a model to the end of the collection.
  push: function(model, options) {
    return this.add(model, _.extend({at: this.length}, options));
  },

    // Remove a model from the end of the collection.
  pop: function(options) {
    var model = this.at(this.length - 1);
    this.remove(model, options);
    return model;
  },

    // Add a model to the beginning of the collection.
  unshift: function(model, options) {
    return this.add(model, _.extend({at: 0}, options));
  },

    // Remove a model from the beginning of the collection.
  shift: function(options) {
    var model = this.at(0);
    this.remove(model, options);
    return model;
  },

    // Slice out a sub-array of models from the collection.
  slice: function() {
    return slice.apply(this.models, arguments);
  },

    // Get a model from the set by id.
  get: function(obj) {
    if (obj == null) return void 0;
    var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
    return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
  },

    // Get the model at the given index.
  at: function(index) {
    if (index < 0) index += this.length;
    return this.models[index];
  },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
  where: function(attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return this[first ? 'find' : 'filter'](function(model) {
      for (var key in attrs) {
        if (attrs[key] !== model.get(key)) return false;
      }
      return true;
    });
  },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
  findWhere: function(attrs) {
    return this.where(attrs, true);
  },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
  sort: function(options) {
    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
    options || (options = {});

    // Run sort based on type of `comparator`.
    if (_.isString(this.comparator) || this.comparator.length === 1) {
      this.models = this.sortBy(this.comparator, this);
    } else {
      this.models.sort(_.bind(this.comparator, this));
    }

    if (!options.silent) this.trigger('sort', this, options);
    return this;
  },

    // Pluck an attribute from each model in the collection.
  pluck: function(attr) {
    return _.invoke(this.models, 'get', attr);
  },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
  fetch: function(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var success = options.success;
    var collection = this;
    options.success = function(resp) {
      var method = options.reset ? 'reset' : 'set';
      collection[method](resp, options);
      if (success) success(collection, resp, options);
      collection.trigger('sync', collection, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
  create: function(model, options) {
    options = options ? _.clone(options) : {};
    if (!(model = this._prepareModel(model, options))) return false;
    if (!options.wait) this.add(model, options);
    var collection = this;
    var success = options.success;
    options.success = function(model, resp) {
      if (options.wait) collection.add(model, options);
      if (success) success(model, resp, options);
    };
    model.save(null, options);
    return model;
  },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
  parse: function(resp, options) {
    return resp;
  },

    // Create a new collection with an identical list of models as this one.
  clone: function() {
    return new this.constructor(this.models, {
      model: this.model,
      comparator: this.comparator
    });
  },

    // Define how to uniquely identify models in the collection.
  modelId: function (attrs) {
    return attrs[this.model.prototype.idAttribute || 'id'];
  },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
  _reset: function() {
    this.length = 0;
    this.models = [];
    this._byId  = {};
  },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
  _prepareModel: function(attrs, options) {
    if (this._isModel(attrs)) {
      if (!attrs.collection) attrs.collection = this;
      return attrs;
    }
    options = options ? _.clone(options) : {};
    options.collection = this;
    var model = new this.model(attrs, options);
    if (!model.validationError) return model;
    this.trigger('invalid', this, model.validationError, options);
    return false;
  },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
  _isModel: function (model) {
    return model instanceof Model;
  },

    // Internal method to create a model's ties to a collection.
  _addReference: function(model, options) {
    this._byId[model.cid] = model;
    var id = this.modelId(model.attributes);
    if (id != null) this._byId[id] = model;
    model.on('all', this._onModelEvent, this);
  },

    // Internal method to sever a model's ties to a collection.
  _removeReference: function(model, options) {
    if (this === model.collection) delete model.collection;
    model.off('all', this._onModelEvent, this);
  },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
  _onModelEvent: function(event, model, collection, options) {
    if ((event === 'add' || event === 'remove') && collection !== this) return;
    if (event === 'destroy') this.remove(model, options);
    if (event === 'change') {
      var prevId = this.modelId(model.previousAttributes());
      var id = this.modelId(model.attributes);
      if (prevId !== id) {
        if (prevId != null) delete this._byId[prevId];
        if (id != null) this._byId[id] = model;
      }
    }
    this.trigger.apply(this, arguments);
  }

});

// Underscore methods that we want to implement on the Collection.
// 90% of the core usefulness of Backbone Collections is actually implemented
// right here:
var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample', 'partition'];

// Mix in each Underscore method as a proxy to `Collection#models`.
_.each(methods, function(method) {
  if (!_[method]) return;
  Collection.prototype[method] = function() {
    var args = slice.call(arguments);
    args.unshift(this.models);
    return _[method].apply(_, args);
  };
});

// Underscore methods that take a property name as an argument.
var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

// Use attributes instead of properties.
_.each(attributeMethods, function(method) {
  if (!_[method]) return;
  Collection.prototype[method] = function(value, context) {
    var iterator = _.isFunction(value) ? value : function(model) {
      return model.get(value);
    };
    return _[method](this.models, iterator, context);
  };
});

// setup inheritance
Collection.extend = extend;
module.exports = Collection;

},{"./model":5,"backbone-events-standalone":7,"backbone-extend-standalone":8,"underscore":91}],4:[function(require,module,exports){
module.exports.Model = require("./model");
module.exports.Collection = require("./collection");
module.exports.Events = require("backbone-events-standalone");
module.exports.extend = require("backbone-extend-standalone");

},{"./collection":3,"./model":5,"backbone-events-standalone":7,"backbone-extend-standalone":8}],5:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

var Events = require("backbone-events-standalone");
var extend = require("backbone-extend-standalone");
var _ = require("underscore");

// Backbone.Model
// --------------

// Backbone **Models** are the basic data object in the framework --
// frequently representing a row in a table in a database on your server.
// A discrete chunk of data and a bunch of useful, related methods for
// performing computations and transformations on that data.

// Create a new model with the specified attributes. A client id (`cid`)
// is automatically generated and assigned for you.
var Model = function(attributes, options) {
  var attrs = attributes || {};
  options || (options = {});
  this.cid = _.uniqueId('c');
  this.attributes = {};
  if (options.collection) this.collection = options.collection;
  if (options.parse) attrs = this.parse(attrs, options) || {};
  attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
  this.set(attrs, options);
  this.changed = {};
  this.initialize.apply(this, arguments);
};

// Attach all inheritable methods to the Model prototype.
_.extend(Model.prototype, Events, {

  // A hash of attributes whose current and previous value differ.
  changed: null,

  // The value returned during the last failed validation.
  validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
  idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
  initialize: function(){},

    // Return a copy of the model's `attributes` object.
  toJSON: function(options) {
    return _.clone(this.attributes);
  },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
  sync: function() {
    return Backbone.sync.apply(this, arguments);
  },

    // Get the value of an attribute.
  get: function(attr) {
    return this.attributes[attr];
  },

    // Get the HTML-escaped value of an attribute.
  escape: function(attr) {
    return _.escape(this.get(attr));
  },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
  has: function(attr) {
    return this.get(attr) != null;
  },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
  set: function(key, val, options) {
    var attr, attrs, unset, changes, silent, changing, prev, current;
    if (key == null) return this;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options || (options = {});

    // Run validation.
    if (!this._validate(attrs, options)) return false;

    // Extract attributes and options.
    unset           = options.unset;
    silent          = options.silent;
    changes         = [];
    changing        = this._changing;
    this._changing  = true;

    if (!changing) {
      this._previousAttributes = _.clone(this.attributes);
      this.changed = {};
    }
    current = this.attributes, prev = this._previousAttributes;

    // Check for changes of `id`.
    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

    // For each `set` attribute, update or delete the current value.
    for (attr in attrs) {
      val = attrs[attr];
      if (!_.isEqual(current[attr], val)) changes.push(attr);
      if (!_.isEqual(prev[attr], val)) {
        this.changed[attr] = val;
      } else {
        delete this.changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }

    // Trigger all relevant attribute changes.
    if (!silent) {
      if (changes.length) this._pending = options;
      for (var i = 0, length = changes.length; i < length; i++) {
        this.trigger('change:' + changes[i], this, current[changes[i]], options);
      }
    }

    // You might be wondering why there's a `while` loop here. Changes can
    // be recursively nested within `"change"` events.
    if (changing) return this;
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger('change', this, options);
      }
    }
    this._pending = false;
    this._changing = false;
    return this;
  },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
  unset: function(attr, options) {
    return this.set(attr, void 0, _.extend({}, options, {unset: true}));
  },

    // Clear all attributes on the model, firing `"change"`.
  clear: function(options) {
    var attrs = {};
    for (var key in this.attributes) attrs[key] = void 0;
    return this.set(attrs, _.extend({}, options, {unset: true}));
  },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
  hasChanged: function(attr) {
    if (attr == null) return !_.isEmpty(this.changed);
    return _.has(this.changed, attr);
  },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
  changedAttributes: function(diff) {
    if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
    var val, changed = false;
    var old = this._changing ? this._previousAttributes : this.attributes;
    for (var attr in diff) {
      if (_.isEqual(old[attr], (val = diff[attr]))) continue;
      (changed || (changed = {}))[attr] = val;
    }
    return changed;
  },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
  previous: function(attr) {
    if (attr == null || !this._previousAttributes) return null;
    return this._previousAttributes[attr];
  },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
  previousAttributes: function() {
    return _.clone(this._previousAttributes);
  },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
  fetch: function(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function(resp) {
      if (!model.set(model.parse(resp, options), options)) return false;
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
  save: function(key, val, options) {
    var attrs, method, xhr, attributes = this.attributes;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (key == null || typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options = _.extend({validate: true}, options);

    // If we're not waiting and attributes exist, save acts as
    // `set(attr).save(null, opts)` with validation. Otherwise, check if
    // the model will be valid when the attributes, if any, are set.
    if (attrs && !options.wait) {
      if (!this.set(attrs, options)) return false;
    } else {
      if (!this._validate(attrs, options)) return false;
    }

    // Set temporary attributes if `{wait: true}`.
    if (attrs && options.wait) {
      this.attributes = _.extend({}, attributes, attrs);
    }

    // After a successful server-side save, the client is (optionally)
    // updated with the server-side state.
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function(resp) {
      // Ensure attributes are restored during synchronous saves.
      model.attributes = attributes;
      var serverAttrs = model.parse(resp, options);
      if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
      if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
        return false;
      }
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);

    method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
    if (method === 'patch' && !options.attrs) options.attrs = attrs;
    xhr = this.sync(method, this, options);

    // Restore attributes.
    if (attrs && options.wait) this.attributes = attributes;

    return xhr;
  },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
  destroy: function(options) {
    options = options ? _.clone(options) : {};
    var model = this;
    var success = options.success;

    var destroy = function() {
      model.stopListening();
      model.trigger('destroy', model, model.collection, options);
    };

    options.success = function(resp) {
      if (options.wait || model.isNew()) destroy();
      if (success) success(model, resp, options);
      if (!model.isNew()) model.trigger('sync', model, resp, options);
    };

    if (this.isNew()) {
      options.success();
      return false;
    }
    wrapError(this, options);

    var xhr = this.sync('delete', this, options);
    if (!options.wait) destroy();
    return xhr;
  },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
  url: function() {
    var base =
      _.result(this, 'urlRoot') ||
      _.result(this.collection, 'url') ||
      urlError();
    if (this.isNew()) return base;
    return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
  },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
  parse: function(resp, options) {
    return resp;
  },

    // Create a new model with identical attributes to this one.
  clone: function() {
    return new this.constructor(this.attributes);
  },

    // A model is new if it has never been saved to the server, and lacks an id.
  isNew: function() {
    return !this.has(this.idAttribute);
  },

    // Check if the model is currently in a valid state.
  isValid: function(options) {
    return this._validate({}, _.extend(options || {}, { validate: true }));
  },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
  _validate: function(attrs, options) {
    if (!options.validate || !this.validate) return true;
    attrs = _.extend({}, this.attributes, attrs);
    var error = this.validationError = this.validate(attrs, options) || null;
    if (!error) return true;
    this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
    return false;
  }

});

// Underscore methods that we want to implement on the Model.
var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit', 'chain', 'isEmpty'];

// Mix in each Underscore method as a proxy to `Model#attributes`.
_.each(modelMethods, function(method) {
  if (!_[method]) return;
  Model.prototype[method] = function() {
    var args = slice.call(arguments);
    args.unshift(this.attributes);
    return _[method].apply(_, args);
  };
});

// setup inheritance
Model.extend = extend;
module.exports = Model;

},{"backbone-events-standalone":7,"backbone-extend-standalone":8,"underscore":91}],6:[function(require,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  }else if (typeof define === "function") {
    define(function() {
      return Events;
    });
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],7:[function(require,module,exports){
module.exports = require('./backbone-events-standalone');

},{"./backbone-events-standalone":6}],8:[function(require,module,exports){
(function (definition) {
  if (typeof exports === "object") {
    module.exports = definition();
  }
  else if (typeof define === 'function' && define.amd) {
    define(definition);
  }
  else {
    window.BackboneExtend = definition();
  }
})(function () {
  "use strict";
  
  // mini-underscore
  var _ = {
    has: function (obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    },
  
    extend: function(obj) {
      for (var i=1; i<arguments.length; ++i) {
        var source = arguments[i];
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      }
      return obj;
    }
  };

  /// Following code is pasted from Backbone.js ///

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Expose the extend function
  return extend;
});

},{}],9:[function(require,module,exports){
// this is the extracted view model from backbone
// note that we inject jbone as jquery replacment
// (and underscore directly)
//
// Views are almost more convention than they are actual code.
//  MVC pattern
// Backbone.View
// -------------

var _ = require("underscore");
var Events = require("backbone-events-standalone");
var extend = require("backbone-extend-standalone");
var $ = require('jbone');

// Backbone Views are almost more convention than they are actual code. A View
// is simply a JavaScript object that represents a logical chunk of UI in the
// DOM. This might be a single item, an entire list, a sidebar or panel, or
// even the surrounding frame which wraps your whole app. Defining a chunk of
// UI as a **View** allows you to define your DOM events declaratively, without
// having to worry about render order ... and makes it easy for the view to
// react to specific changes in the state of your models.

// Creating a Backbone.View creates its initial element outside of the DOM,
// if an existing element is not provided...
var View =  function(options) {
  this.cid = _.uniqueId('view');
  options || (options = {});
  _.extend(this, _.pick(options, viewOptions));
  this._ensureElement();
  this.initialize.apply(this, arguments);
};

// Cached regex to split keys for `delegate`.
var delegateEventSplitter = /^(\S+)\s*(.*)$/;

// List of view options to be merged as properties.
var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

// Set up all inheritable **Backbone.View** properties and methods.
_.extend(View.prototype, Events, {

  // The default `tagName` of a View's element is `"div"`.
  tagName: 'div',

  // jQuery delegate for element lookup, scoped to DOM elements within the
  // current view. This should be preferred to global lookups where possible.
  $: function(selector) {
    return this.$el.find(selector);
  },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
  initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
  render: function() {
    return this;
  },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
  remove: function() {
    this._removeElement();
    this.stopListening();
    return this;
  },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
  _removeElement: function() {
    this.$el.remove();
  },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
  setElement: function(element) {
    this.undelegateEvents();
    this._setElement(element);
    this.delegateEvents();
    return this;
  },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
  _setElement: function(el) {
    this.$el = el instanceof $ ? el : $(el);
    this.el = this.$el[0];
  },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
  delegateEvents: function(events) {
    if (!(events || (events = _.result(this, 'events')))) return this;
    this.undelegateEvents();
    for (var key in events) {
      var method = events[key];
      if (!_.isFunction(method)) method = this[events[key]];
      if (!method) continue;
      var match = key.match(delegateEventSplitter);
      this.delegate(match[1], match[2], _.bind(method, this));
    }
    return this;
  },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
  delegate: function(eventName, selector, listener) {
    this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
  },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
  undelegateEvents: function() {
    if (this.$el) this.$el.off('.delegateEvents' + this.cid);
    return this;
  },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
  undelegate: function(eventName, selector, listener) {
    this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
  },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
  _createElement: function(tagName) {
    return document.createElement(tagName);
  },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
  _ensureElement: function() {
    if (!this.el) {
      var attrs = _.extend({}, _.result(this, 'attributes'));
      if (this.id) attrs.id = _.result(this, 'id');
      if (this.className) attrs['class'] = _.result(this, 'className');
      this.setElement(this._createElement(_.result(this, 'tagName')));
      this._setAttributes(attrs);
    } else {
      this.setElement(_.result(this, 'el'));
    }
  },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
  _setAttributes: function(attributes) {
    this.$el.attr(attributes);
  }

});

// setup inheritance
View.extend = extend;
module.exports = View;

},{"backbone-events-standalone":11,"backbone-extend-standalone":12,"jbone":67,"underscore":91}],10:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],11:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"./backbone-events-standalone":10,"dup":7}],12:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],13:[function(require,module,exports){
var events = require("backbone-events-standalone");

events.onAll = function(callback,context){
  this.on("all", callback,context);
  return this;
};

// Mixin utility
events.oldMixin = events.mixin;
events.mixin = function(proto) {
  events.oldMixin(proto);
  // add custom onAll
  var exports = ['onAll'];
  for(var i=0; i < exports.length;i++){
    var name = exports[i];
    proto[name] = this[name];
  }
  return proto;
};

module.exports = events;

},{"backbone-events-standalone":15}],14:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],15:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"./backbone-events-standalone":14,"dup":7}],16:[function(require,module,exports){
var GenericReader;

var xhr = require('request');
var vow = require('vow');

module.exports = GenericReader = (function() {
  function GenericReader() {}

  // returns a promise if callback is undefined
  GenericReader.read = function(url, callback) {
    var onret;
    onret = (function(_this) {
      return function(err, response, text) {
        return GenericReader._onRetrieval(err, text, callback, _this);
      };
    })(this);

    if(typeof callback === "undefined"){
      var prom = vow.defer();
      callback = function(err, res){
        if(err){
          prom.reject(err);
        }else{
          prom.resolve(res);
        }
      };
      xhr(url, onret);
      return prom.promise();
    }else{
      return xhr(url, onret);
    }
  };

  GenericReader._onRetrieval = function(err, text, callback, _this) {
    var rText;
    if(typeof err !== "undefined"){
      rText = _this.parse(text);
    }
    return callback.call(_this, err, rText);
  };

  // provide a convenient shortcut to inherit
  GenericReader.extend = function(obj, statics){
    return extend(GenericReader, obj, statics); 
  };
  // Mixin utility
  GenericReader.mixin = function(proto) {
    var exports = ['read'];
    if(typeof proto !== "object"){
      proto = proto.prototype;
    }
    exports.forEach(function(name) {
      proto[name] = GenericReader[name];
    }, this);
    return proto;
  };

  return GenericReader;

})();

},{"request":18,"vow":17}],17:[function(require,module,exports){
(function (process){
/**
 * @module vow
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @version 0.4.9
 * @license
 * Dual licensed under the MIT and GPL licenses:
 *   * http://www.opensource.org/licenses/mit-license.php
 *   * http://www.gnu.org/licenses/gpl.html
 */

(function(global) {

var undef,
    nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
                return fns.push(fn) === 1;
            },
            callFns = function() {
                var fnsToCall = fns, i = 0, len = fns.length;
                fns = [];
                while(i < len) {
                    fnsToCall[i++]();
                }
            };

        if(typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
            return function(fn) {
                enqueueFn(fn) && setImmediate(callFns);
            };
        }

        if(typeof process === 'object' && process.nextTick) { // nodejs < 0.10
            return function(fn) {
                enqueueFn(fn) && process.nextTick(callFns);
            };
        }

        if(global.postMessage) { // modern browsers
            var isPostMessageAsync = true;
            if(global.attachEvent) {
                var checkAsync = function() {
                        isPostMessageAsync = false;
                    };
                global.attachEvent('onmessage', checkAsync);
                global.postMessage('__checkAsync', '*');
                global.detachEvent('onmessage', checkAsync);
            }

            if(isPostMessageAsync) {
                var msg = '__promise' + +new Date,
                    onMessage = function(e) {
                        if(e.data === msg) {
                            e.stopPropagation && e.stopPropagation();
                            callFns();
                        }
                    };

                global.addEventListener?
                    global.addEventListener('message', onMessage, true) :
                    global.attachEvent('onmessage', onMessage);

                return function(fn) {
                    enqueueFn(fn) && global.postMessage(msg, '*');
                };
            }
        }

        var doc = global.document;
        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
            var createScript = function() {
                    var script = doc.createElement('script');
                    script.onreadystatechange = function() {
                        script.parentNode.removeChild(script);
                        script = script.onreadystatechange = null;
                        callFns();
                };
                (doc.documentElement || doc.body).appendChild(script);
            };

            return function(fn) {
                enqueueFn(fn) && createScript();
            };
        }

        return function(fn) { // old browsers
            enqueueFn(fn) && setTimeout(callFns, 0);
        };
    })(),
    throwException = function(e) {
        nextTick(function() {
            throw e;
        });
    },
    isFunction = function(obj) {
        return typeof obj === 'function';
    },
    isObject = function(obj) {
        return obj !== null && typeof obj === 'object';
    },
    toStr = Object.prototype.toString,
    isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
    },
    getArrayKeys = function(arr) {
        var res = [],
            i = 0, len = arr.length;
        while(i < len) {
            res.push(i++);
        }
        return res;
    },
    getObjectKeys = Object.keys || function(obj) {
        var res = [];
        for(var i in obj) {
            obj.hasOwnProperty(i) && res.push(i);
        }
        return res;
    },
    defineCustomErrorType = function(name) {
        var res = function(message) {
            this.name = name;
            this.message = message;
        };

        res.prototype = new Error();

        return res;
    },
    wrapOnFulfilled = function(onFulfilled, idx) {
        return function(val) {
            onFulfilled.call(this, val, idx);
        };
    };

/**
 * @class Deferred
 * @exports vow:Deferred
 * @description
 * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
 */

/**
 * @constructor
 * @description
 * You can use `vow.defer()` instead of using this constructor.
 *
 * `new vow.Deferred()` gives the same result as `vow.defer()`.
 */
var Deferred = function() {
    this._promise = new Promise();
};

Deferred.prototype = /** @lends Deferred.prototype */{
    /**
     * Returns corresponding promise.
     *
     * @returns {vow:Promise}
     */
    promise : function() {
        return this._promise;
    },

    /**
     * Resolves corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.then(function(value) {
     *     // value is "'success'" here
     * });
     *
     * defer.resolve('success');
     * ```
     */
    resolve : function(value) {
        this._promise.isResolved() || this._promise._resolve(value);
    },

    /**
     * Rejects corresponding promise with given `reason`.
     *
     * @param {*} reason
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.fail(function(reason) {
     *     // reason is "'something is wrong'" here
     * });
     *
     * defer.reject('something is wrong');
     * ```
     */
    reject : function(reason) {
        if(this._promise.isResolved()) {
            return;
        }

        if(vow.isPromise(reason)) {
            reason = reason.then(function(val) {
                var defer = vow.defer();
                defer.reject(val);
                return defer.promise();
            });
            this._promise._resolve(reason);
        }
        else {
            this._promise._reject(reason);
        }
    },

    /**
     * Notifies corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.progress(function(value) {
     *     // value is "'20%'", "'40%'" here
     * });
     *
     * defer.notify('20%');
     * defer.notify('40%');
     * ```
     */
    notify : function(value) {
        this._promise.isResolved() || this._promise._notify(value);
    }
};

var PROMISE_STATUS = {
    PENDING   : 0,
    RESOLVED  : 1,
    FULFILLED : 2,
    REJECTED  : 3
};

/**
 * @class Promise
 * @exports vow:Promise
 * @description
 * The `Promise` class is used when you want to give to the caller something to subscribe to,
 * but not the ability to resolve or reject the deferred.
 */

/**
 * @constructor
 * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
 * @description
 * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
 * In other case you should use `vow.defer()` and `defer.promise()` methods.
 * @example
 * ```js
 * function fetchJSON(url) {
 *     return new vow.Promise(function(resolve, reject, notify) {
 *         var xhr = new XMLHttpRequest();
 *         xhr.open('GET', url);
 *         xhr.responseType = 'json';
 *         xhr.send();
 *         xhr.onload = function() {
 *             if(xhr.response) {
 *                 resolve(xhr.response);
 *             }
 *             else {
 *                 reject(new TypeError());
 *             }
 *         };
 *     });
 * }
 * ```
 */
var Promise = function(resolver) {
    this._value = undef;
    this._status = PROMISE_STATUS.PENDING;

    this._fulfilledCallbacks = [];
    this._rejectedCallbacks = [];
    this._progressCallbacks = [];

    if(resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
        var _this = this,
            resolverFnLen = resolver.length;

        resolver(
            function(val) {
                _this.isResolved() || _this._resolve(val);
            },
            resolverFnLen > 1?
                function(reason) {
                    _this.isResolved() || _this._reject(reason);
                } :
                undef,
            resolverFnLen > 2?
                function(val) {
                    _this.isResolved() || _this._notify(val);
                } :
                undef);
    }
};

Promise.prototype = /** @lends Promise.prototype */ {
    /**
     * Returns value of fulfilled promise or reason in case of rejection.
     *
     * @returns {*}
     */
    valueOf : function() {
        return this._value;
    },

    /**
     * Returns `true` if promise is resolved.
     *
     * @returns {Boolean}
     */
    isResolved : function() {
        return this._status !== PROMISE_STATUS.PENDING;
    },

    /**
     * Returns `true` if promise is fulfilled.
     *
     * @returns {Boolean}
     */
    isFulfilled : function() {
        return this._status === PROMISE_STATUS.FULFILLED;
    },

    /**
     * Returns `true` if promise is rejected.
     *
     * @returns {Boolean}
     */
    isRejected : function() {
        return this._status === PROMISE_STATUS.REJECTED;
    },

    /**
     * Adds reactions to promise.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
     */
    then : function(onFulfilled, onRejected, onProgress, ctx) {
        var defer = new Deferred();
        this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
        return defer.promise();
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(undefined, onRejected)`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    'catch' : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(null, onRejected)`. It's alias for `catch`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds resolving reaction (to fulfillment and rejection both).
     *
     * @param {Function} onResolved Callback that to be called with the value after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(onResolved, ctx) {
        var _this = this,
            cb = function() {
                return onResolved.call(this, _this);
            };

        return this.then(cb, cb, ctx);
    },

    /**
     * Adds progress reaction.
     *
     * @param {Function} onProgress Callback to be called with the value when promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(onProgress, ctx) {
        return this.then(undef, undef, onProgress, ctx);
    },

    /**
     * Like `promise.then`, but "spreads" the array into a variadic value handler.
     * It is useful with `vow.all` and `vow.allResolved` methods.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
     *     // arg1 is "1", arg2 is "'two'" here
     * });
     *
     * defer1.resolve(1);
     * defer2.resolve('two');
     * ```
     */
    spread : function(onFulfilled, onRejected, ctx) {
        return this.then(
            function(val) {
                return onFulfilled.apply(this, val);
            },
            onRejected,
            ctx);
    },

    /**
     * Like `then`, but terminates a chain of promises.
     * If the promise has been rejected, throws it as an exception in a future turn of the event loop.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     *
     * @example
     * ```js
     * var defer = vow.defer();
     * defer.reject(Error('Internal error'));
     * defer.promise().done(); // exception to be thrown
     * ```
     */
    done : function(onFulfilled, onRejected, onProgress, ctx) {
        this
            .then(onFulfilled, onRejected, onProgress, ctx)
            .fail(throwException);
    },

    /**
     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
     * or immediately rejected if promise is rejected.
     *
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(delay) {
        var timer,
            promise = this.then(function(val) {
                var defer = new Deferred();
                timer = setTimeout(
                    function() {
                        defer.resolve(val);
                    },
                    delay);

                return defer.promise();
            });

        promise.always(function() {
            clearTimeout(timer);
        });

        return promise;
    },

    /**
     * Returns a new promise that will be rejected in `timeout` milliseconds
     * if the promise is not resolved beforehand.
     *
     * @param {Number} timeout
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promiseWithTimeout1 = defer.promise().timeout(50),
     *     promiseWithTimeout2 = defer.promise().timeout(200);
     *
     * setTimeout(
     *     function() {
     *         defer.resolve('ok');
     *     },
     *     100);
     *
     * promiseWithTimeout1.fail(function(reason) {
     *     // promiseWithTimeout to be rejected in 50ms
     * });
     *
     * promiseWithTimeout2.then(function(value) {
     *     // promiseWithTimeout to be fulfilled with "'ok'" value
     * });
     * ```
     */
    timeout : function(timeout) {
        var defer = new Deferred(),
            timer = setTimeout(
                function() {
                    defer.reject(new vow.TimedOutError('timed out'));
                },
                timeout);

        this.then(
            function(val) {
                defer.resolve(val);
            },
            function(reason) {
                defer.reject(reason);
            });

        defer.promise().always(function() {
            clearTimeout(timer);
        });

        return defer.promise();
    },

    _vow : true,

    _resolve : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        if(val === this) {
            this._reject(TypeError('Can\'t resolve promise with itself'));
            return;
        }

        this._status = PROMISE_STATUS.RESOLVED;

        if(val && !!val._vow) { // shortpath for vow.Promise
            val.isFulfilled()?
                this._fulfill(val.valueOf()) :
                val.isRejected()?
                    this._reject(val.valueOf()) :
                    val.then(
                        this._fulfill,
                        this._reject,
                        this._notify,
                        this);
            return;
        }

        if(isObject(val) || isFunction(val)) {
            var then;
            try {
                then = val.then;
            }
            catch(e) {
                this._reject(e);
                return;
            }

            if(isFunction(then)) {
                var _this = this,
                    isResolved = false;

                try {
                    then.call(
                        val,
                        function(val) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._resolve(val);
                        },
                        function(err) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._reject(err);
                        },
                        function(val) {
                            _this._notify(val);
                        });
                }
                catch(e) {
                    isResolved || this._reject(e);
                }

                return;
            }
        }

        this._fulfill(val);
    },

    _fulfill : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.FULFILLED;
        this._value = val;

        this._callCallbacks(this._fulfilledCallbacks, val);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _reject : function(reason) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.REJECTED;
        this._value = reason;

        this._callCallbacks(this._rejectedCallbacks, reason);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _notify : function(val) {
        this._callCallbacks(this._progressCallbacks, val);
    },

    _addCallbacks : function(defer, onFulfilled, onRejected, onProgress, ctx) {
        if(onRejected && !isFunction(onRejected)) {
            ctx = onRejected;
            onRejected = undef;
        }
        else if(onProgress && !isFunction(onProgress)) {
            ctx = onProgress;
            onProgress = undef;
        }

        var cb;

        if(!this.isRejected()) {
            cb = { defer : defer, fn : isFunction(onFulfilled)? onFulfilled : undef, ctx : ctx };
            this.isFulfilled()?
                this._callCallbacks([cb], this._value) :
                this._fulfilledCallbacks.push(cb);
        }

        if(!this.isFulfilled()) {
            cb = { defer : defer, fn : onRejected, ctx : ctx };
            this.isRejected()?
                this._callCallbacks([cb], this._value) :
                this._rejectedCallbacks.push(cb);
        }

        if(this._status <= PROMISE_STATUS.RESOLVED) {
            this._progressCallbacks.push({ defer : defer, fn : onProgress, ctx : ctx });
        }
    },

    _callCallbacks : function(callbacks, arg) {
        var len = callbacks.length;
        if(!len) {
            return;
        }

        var isResolved = this.isResolved(),
            isFulfilled = this.isFulfilled();

        nextTick(function() {
            var i = 0, cb, defer, fn;
            while(i < len) {
                cb = callbacks[i++];
                defer = cb.defer;
                fn = cb.fn;

                if(fn) {
                    var ctx = cb.ctx,
                        res;
                    try {
                        res = ctx? fn.call(ctx, arg) : fn(arg);
                    }
                    catch(e) {
                        defer.reject(e);
                        continue;
                    }

                    isResolved?
                        defer.resolve(res) :
                        defer.notify(res);
                }
                else {
                    isResolved?
                        isFulfilled?
                            defer.resolve(arg) :
                            defer.reject(arg) :
                        defer.notify(arg);
                }
            }
        });
    }
};

/** @lends Promise */
var staticMethods = {
    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return vow.cast(value);
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     */
    all : function(iterable) {
        return vow.all(iterable);
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` are fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    race : function(iterable) {
        return vow.anyResolved(iterable);
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        return vow.resolve(value);
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        return vow.reject(reason);
    }
};

for(var prop in staticMethods) {
    staticMethods.hasOwnProperty(prop) &&
        (Promise[prop] = staticMethods[prop]);
}

var vow = /** @exports vow */ {
    Deferred : Deferred,

    Promise : Promise,

    /**
     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
     * It's equivalent to `new vow.Deferred()`.
     *
     * @returns {vow:Deferred}
     */
    defer : function() {
        return new Deferred();
    },

    /**
     * Static equivalent to `promise.then`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    when : function(value, onFulfilled, onRejected, onProgress, ctx) {
        return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.fail`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onRejected Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(value, onRejected, ctx) {
        return vow.when(value, undef, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.always`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onResolved Callback that will to be invoked with the reason after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(value, onResolved, ctx) {
        return vow.when(value).always(onResolved, ctx);
    },

    /**
     * Static equivalent to `promise.progress`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onProgress Callback that will to be invoked with the reason after promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(value, onProgress, ctx) {
        return vow.when(value).progress(onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.spread`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    spread : function(value, onFulfilled, onRejected, ctx) {
        return vow.when(value).spread(onFulfilled, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.done`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     */
    done : function(value, onFulfilled, onRejected, onProgress, ctx) {
        vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Checks whether the given `value` is a promise-like object
     *
     * @param {*} value
     * @returns {Boolean}
     *
     * @example
     * ```js
     * vow.isPromise('something'); // returns false
     * vow.isPromise(vow.defer().promise()); // returns true
     * vow.isPromise({ then : function() { }); // returns true
     * ```
     */
    isPromise : function(value) {
        return isObject(value) && isFunction(value.then);
    },

    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return value && !!value._vow?
            value :
            vow.resolve(value);
    },

    /**
     * Static equivalent to `promise.valueOf`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {*}
     */
    valueOf : function(value) {
        return value && isFunction(value.valueOf)? value.valueOf() : value;
    },

    /**
     * Static equivalent to `promise.isFulfilled`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isFulfilled : function(value) {
        return value && isFunction(value.isFulfilled)? value.isFulfilled() : true;
    },

    /**
     * Static equivalent to `promise.isRejected`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isRejected : function(value) {
        return value && isFunction(value.isRejected)? value.isRejected() : false;
    },

    /**
     * Static equivalent to `promise.isResolved`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isResolved : function(value) {
        return value && isFunction(value.isResolved)? value.isResolved() : true;
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        var res = vow.defer();
        res.resolve(value);
        return res.promise();
    },

    /**
     * Returns a promise that has already been fulfilled with the given `value`.
     * If `value` is a promise, returned promise will be fulfilled with fulfill/rejection value of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    fulfill : function(value) {
        var defer = vow.defer(),
            promise = defer.promise();

        defer.resolve(value);

        return promise.isFulfilled()?
            promise :
            promise.then(null, function(reason) {
                return reason;
            });
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     * If `reason` is a promise, returned promise will be rejected with fulfill/rejection value of given promise.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        var defer = vow.defer();
        defer.reject(reason);
        return defer.promise();
    },

    /**
     * Invokes a given function `fn` with arguments `args`
     *
     * @param {Function} fn
     * @param {...*} [args]
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var promise1 = vow.invoke(function(value) {
     *         return value;
     *     }, 'ok'),
     *     promise2 = vow.invoke(function() {
     *         throw Error();
     *     });
     *
     * promise1.isFulfilled(); // true
     * promise1.valueOf(); // 'ok'
     * promise2.isRejected(); // true
     * promise2.valueOf(); // instance of Error
     * ```
     */
    invoke : function(fn, args) {
        var len = Math.max(arguments.length - 1, 0),
            callArgs;
        if(len) { // optimization for V8
            callArgs = Array(len);
            var i = 0;
            while(i < len) {
                callArgs[i++] = arguments[i];
            }
        }

        try {
            return vow.resolve(callArgs?
                fn.apply(global, callArgs) :
                fn.call(global));
        }
        catch(e) {
            return vow.reject(e);
        }
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * with array:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise(), 3])
     *     .then(function(value) {
     *          // value is "[1, 2, 3]" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     *
     * @example
     * with object:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
     *     .then(function(value) {
     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     */
    all : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            len = keys.length,
            res = isPromisesArray? [] : {};

        if(!len) {
            defer.resolve(res);
            return defer.promise();
        }

        var i = len;
        vow._forEach(
            iterable,
            function(value, idx) {
                res[keys[idx]] = value;
                if(!--i) {
                    defer.resolve(res);
                }
            },
            defer.reject,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are resolved.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
     *     promise1.isRejected(); // returns true
     *     promise1.valueOf(); // returns "'error'"
     *     promise2.isFulfilled(); // returns true
     *     promise2.valueOf(); // returns "'ok'"
     * });
     *
     * defer1.reject('error');
     * defer2.resolve('ok');
     * ```
     */
    allResolved : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            i = keys.length,
            res = isPromisesArray? [] : {};

        if(!i) {
            defer.resolve(res);
            return defer.promise();
        }

        var onResolved = function() {
                --i || defer.resolve(iterable);
            };

        vow._forEach(
            iterable,
            onResolved,
            onResolved,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    allPatiently : function(iterable) {
        return vow.allResolved(iterable).then(function() {
            var isPromisesArray = isArray(iterable),
                keys = isPromisesArray?
                    getArrayKeys(iterable) :
                    getObjectKeys(iterable),
                rejectedPromises, fulfilledPromises,
                len = keys.length, i = 0, key, promise;

            if(!len) {
                return isPromisesArray? [] : {};
            }

            while(i < len) {
                key = keys[i++];
                promise = iterable[key];
                if(vow.isRejected(promise)) {
                    rejectedPromises || (rejectedPromises = isPromisesArray? [] : {});
                    isPromisesArray?
                        rejectedPromises.push(promise.valueOf()) :
                        rejectedPromises[key] = promise.valueOf();
                }
                else if(!rejectedPromises) {
                    (fulfilledPromises || (fulfilledPromises = isPromisesArray? [] : {}))[key] = vow.valueOf(promise);
                }
            }

            if(rejectedPromises) {
                throw rejectedPromises;
            }

            return fulfilledPromises;
        });
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when all the items are rejected (with the reason of the first rejected item).
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    any : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        var i = 0, reason;
        vow._forEach(
            iterable,
            defer.resolve,
            function(e) {
                i || (reason = e);
                ++i === len && defer.reject(reason);
            },
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    anyResolved : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        vow._forEach(
            iterable,
            defer.resolve,
            defer.reject,
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Static equivalent to `promise.delay`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(value, delay) {
        return vow.resolve(value).delay(delay);
    },

    /**
     * Static equivalent to `promise.timeout`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} timeout
     * @returns {vow:Promise}
     */
    timeout : function(value, timeout) {
        return vow.resolve(value).timeout(timeout);
    },

    _forEach : function(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
        var len = keys? keys.length : promises.length,
            i = 0;

        while(i < len) {
            vow.when(
                promises[keys? keys[i] : i],
                wrapOnFulfilled(onFulfilled, i),
                onRejected,
                onProgress,
                ctx);
            ++i;
        }
    },

    TimedOutError : defineCustomErrorType('TimedOut')
};

var defineAsGlobal = true;
if(typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = vow;
    defineAsGlobal = false;
}

if(typeof modules === 'object' && isFunction(modules.define)) {
    modules.define('vow', function(provide) {
        provide(vow);
    });
    defineAsGlobal = false;
}

if(typeof define === 'function') {
    define(function(require, exports, module) {
        module.exports = vow;
    });
    defineAsGlobal = false;
}

defineAsGlobal && (global.vow = vow);

})(this);

}).call(this,require('_process'))

},{"_process":64}],18:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":19,"once":20,"parse-headers":24}],19:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],21:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":22}],22:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],23:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],24:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":21,"trim":23}],25:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"request":27,"vow":26}],26:[function(require,module,exports){
(function (process){
/**
 * @module vow
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @version 0.4.9
 * @license
 * Dual licensed under the MIT and GPL licenses:
 *   * http://www.opensource.org/licenses/mit-license.php
 *   * http://www.gnu.org/licenses/gpl.html
 */

(function(global) {

var undef,
    nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
                return fns.push(fn) === 1;
            },
            callFns = function() {
                var fnsToCall = fns, i = 0, len = fns.length;
                fns = [];
                while(i < len) {
                    fnsToCall[i++]();
                }
            };

        if(typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
            return function(fn) {
                enqueueFn(fn) && setImmediate(callFns);
            };
        }

        if(typeof process === 'object' && process.nextTick) { // nodejs < 0.10
            return function(fn) {
                enqueueFn(fn) && process.nextTick(callFns);
            };
        }

        if(global.postMessage) { // modern browsers
            var isPostMessageAsync = true;
            if(global.attachEvent) {
                var checkAsync = function() {
                        isPostMessageAsync = false;
                    };
                global.attachEvent('onmessage', checkAsync);
                global.postMessage('__checkAsync', '*');
                global.detachEvent('onmessage', checkAsync);
            }

            if(isPostMessageAsync) {
                var msg = '__promise' + +new Date,
                    onMessage = function(e) {
                        if(e.data === msg) {
                            e.stopPropagation && e.stopPropagation();
                            callFns();
                        }
                    };

                global.addEventListener?
                    global.addEventListener('message', onMessage, true) :
                    global.attachEvent('onmessage', onMessage);

                return function(fn) {
                    enqueueFn(fn) && global.postMessage(msg, '*');
                };
            }
        }

        var doc = global.document;
        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
            var createScript = function() {
                    var script = doc.createElement('script');
                    script.onreadystatechange = function() {
                        script.parentNode.removeChild(script);
                        script = script.onreadystatechange = null;
                        callFns();
                };
                (doc.documentElement || doc.body).appendChild(script);
            };

            return function(fn) {
                enqueueFn(fn) && createScript();
            };
        }

        return function(fn) { // old browsers
            enqueueFn(fn) && setTimeout(callFns, 0);
        };
    })(),
    throwException = function(e) {
        nextTick(function() {
            throw e;
        });
    },
    isFunction = function(obj) {
        return typeof obj === 'function';
    },
    isObject = function(obj) {
        return obj !== null && typeof obj === 'object';
    },
    toStr = Object.prototype.toString,
    isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
    },
    getArrayKeys = function(arr) {
        var res = [],
            i = 0, len = arr.length;
        while(i < len) {
            res.push(i++);
        }
        return res;
    },
    getObjectKeys = Object.keys || function(obj) {
        var res = [];
        for(var i in obj) {
            obj.hasOwnProperty(i) && res.push(i);
        }
        return res;
    },
    defineCustomErrorType = function(name) {
        var res = function(message) {
            this.name = name;
            this.message = message;
        };

        res.prototype = new Error();

        return res;
    },
    wrapOnFulfilled = function(onFulfilled, idx) {
        return function(val) {
            onFulfilled.call(this, val, idx);
        };
    };

/**
 * @class Deferred
 * @exports vow:Deferred
 * @description
 * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
 */

/**
 * @constructor
 * @description
 * You can use `vow.defer()` instead of using this constructor.
 *
 * `new vow.Deferred()` gives the same result as `vow.defer()`.
 */
var Deferred = function() {
    this._promise = new Promise();
};

Deferred.prototype = /** @lends Deferred.prototype */{
    /**
     * Returns corresponding promise.
     *
     * @returns {vow:Promise}
     */
    promise : function() {
        return this._promise;
    },

    /**
     * Resolves corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.then(function(value) {
     *     // value is "'success'" here
     * });
     *
     * defer.resolve('success');
     * ```
     */
    resolve : function(value) {
        this._promise.isResolved() || this._promise._resolve(value);
    },

    /**
     * Rejects corresponding promise with given `reason`.
     *
     * @param {*} reason
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.fail(function(reason) {
     *     // reason is "'something is wrong'" here
     * });
     *
     * defer.reject('something is wrong');
     * ```
     */
    reject : function(reason) {
        if(this._promise.isResolved()) {
            return;
        }

        if(vow.isPromise(reason)) {
            reason = reason.then(function(val) {
                var defer = vow.defer();
                defer.reject(val);
                return defer.promise();
            });
            this._promise._resolve(reason);
        }
        else {
            this._promise._reject(reason);
        }
    },

    /**
     * Notifies corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.progress(function(value) {
     *     // value is "'20%'", "'40%'" here
     * });
     *
     * defer.notify('20%');
     * defer.notify('40%');
     * ```
     */
    notify : function(value) {
        this._promise.isResolved() || this._promise._notify(value);
    }
};

var PROMISE_STATUS = {
    PENDING   : 0,
    RESOLVED  : 1,
    FULFILLED : 2,
    REJECTED  : 3
};

/**
 * @class Promise
 * @exports vow:Promise
 * @description
 * The `Promise` class is used when you want to give to the caller something to subscribe to,
 * but not the ability to resolve or reject the deferred.
 */

/**
 * @constructor
 * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
 * @description
 * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
 * In other case you should use `vow.defer()` and `defer.promise()` methods.
 * @example
 * ```js
 * function fetchJSON(url) {
 *     return new vow.Promise(function(resolve, reject, notify) {
 *         var xhr = new XMLHttpRequest();
 *         xhr.open('GET', url);
 *         xhr.responseType = 'json';
 *         xhr.send();
 *         xhr.onload = function() {
 *             if(xhr.response) {
 *                 resolve(xhr.response);
 *             }
 *             else {
 *                 reject(new TypeError());
 *             }
 *         };
 *     });
 * }
 * ```
 */
var Promise = function(resolver) {
    this._value = undef;
    this._status = PROMISE_STATUS.PENDING;

    this._fulfilledCallbacks = [];
    this._rejectedCallbacks = [];
    this._progressCallbacks = [];

    if(resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
        var _this = this,
            resolverFnLen = resolver.length;

        resolver(
            function(val) {
                _this.isResolved() || _this._resolve(val);
            },
            resolverFnLen > 1?
                function(reason) {
                    _this.isResolved() || _this._reject(reason);
                } :
                undef,
            resolverFnLen > 2?
                function(val) {
                    _this.isResolved() || _this._notify(val);
                } :
                undef);
    }
};

Promise.prototype = /** @lends Promise.prototype */ {
    /**
     * Returns value of fulfilled promise or reason in case of rejection.
     *
     * @returns {*}
     */
    valueOf : function() {
        return this._value;
    },

    /**
     * Returns `true` if promise is resolved.
     *
     * @returns {Boolean}
     */
    isResolved : function() {
        return this._status !== PROMISE_STATUS.PENDING;
    },

    /**
     * Returns `true` if promise is fulfilled.
     *
     * @returns {Boolean}
     */
    isFulfilled : function() {
        return this._status === PROMISE_STATUS.FULFILLED;
    },

    /**
     * Returns `true` if promise is rejected.
     *
     * @returns {Boolean}
     */
    isRejected : function() {
        return this._status === PROMISE_STATUS.REJECTED;
    },

    /**
     * Adds reactions to promise.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
     */
    then : function(onFulfilled, onRejected, onProgress, ctx) {
        var defer = new Deferred();
        this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
        return defer.promise();
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(undefined, onRejected)`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    'catch' : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(null, onRejected)`. It's alias for `catch`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds resolving reaction (to fulfillment and rejection both).
     *
     * @param {Function} onResolved Callback that to be called with the value after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(onResolved, ctx) {
        var _this = this,
            cb = function() {
                return onResolved.call(this, _this);
            };

        return this.then(cb, cb, ctx);
    },

    /**
     * Adds progress reaction.
     *
     * @param {Function} onProgress Callback to be called with the value when promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(onProgress, ctx) {
        return this.then(undef, undef, onProgress, ctx);
    },

    /**
     * Like `promise.then`, but "spreads" the array into a variadic value handler.
     * It is useful with `vow.all` and `vow.allResolved` methods.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
     *     // arg1 is "1", arg2 is "'two'" here
     * });
     *
     * defer1.resolve(1);
     * defer2.resolve('two');
     * ```
     */
    spread : function(onFulfilled, onRejected, ctx) {
        return this.then(
            function(val) {
                return onFulfilled.apply(this, val);
            },
            onRejected,
            ctx);
    },

    /**
     * Like `then`, but terminates a chain of promises.
     * If the promise has been rejected, throws it as an exception in a future turn of the event loop.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     *
     * @example
     * ```js
     * var defer = vow.defer();
     * defer.reject(Error('Internal error'));
     * defer.promise().done(); // exception to be thrown
     * ```
     */
    done : function(onFulfilled, onRejected, onProgress, ctx) {
        this
            .then(onFulfilled, onRejected, onProgress, ctx)
            .fail(throwException);
    },

    /**
     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
     * or immediately rejected if promise is rejected.
     *
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(delay) {
        var timer,
            promise = this.then(function(val) {
                var defer = new Deferred();
                timer = setTimeout(
                    function() {
                        defer.resolve(val);
                    },
                    delay);

                return defer.promise();
            });

        promise.always(function() {
            clearTimeout(timer);
        });

        return promise;
    },

    /**
     * Returns a new promise that will be rejected in `timeout` milliseconds
     * if the promise is not resolved beforehand.
     *
     * @param {Number} timeout
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promiseWithTimeout1 = defer.promise().timeout(50),
     *     promiseWithTimeout2 = defer.promise().timeout(200);
     *
     * setTimeout(
     *     function() {
     *         defer.resolve('ok');
     *     },
     *     100);
     *
     * promiseWithTimeout1.fail(function(reason) {
     *     // promiseWithTimeout to be rejected in 50ms
     * });
     *
     * promiseWithTimeout2.then(function(value) {
     *     // promiseWithTimeout to be fulfilled with "'ok'" value
     * });
     * ```
     */
    timeout : function(timeout) {
        var defer = new Deferred(),
            timer = setTimeout(
                function() {
                    defer.reject(new vow.TimedOutError('timed out'));
                },
                timeout);

        this.then(
            function(val) {
                defer.resolve(val);
            },
            function(reason) {
                defer.reject(reason);
            });

        defer.promise().always(function() {
            clearTimeout(timer);
        });

        return defer.promise();
    },

    _vow : true,

    _resolve : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        if(val === this) {
            this._reject(TypeError('Can\'t resolve promise with itself'));
            return;
        }

        this._status = PROMISE_STATUS.RESOLVED;

        if(val && !!val._vow) { // shortpath for vow.Promise
            val.isFulfilled()?
                this._fulfill(val.valueOf()) :
                val.isRejected()?
                    this._reject(val.valueOf()) :
                    val.then(
                        this._fulfill,
                        this._reject,
                        this._notify,
                        this);
            return;
        }

        if(isObject(val) || isFunction(val)) {
            var then;
            try {
                then = val.then;
            }
            catch(e) {
                this._reject(e);
                return;
            }

            if(isFunction(then)) {
                var _this = this,
                    isResolved = false;

                try {
                    then.call(
                        val,
                        function(val) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._resolve(val);
                        },
                        function(err) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._reject(err);
                        },
                        function(val) {
                            _this._notify(val);
                        });
                }
                catch(e) {
                    isResolved || this._reject(e);
                }

                return;
            }
        }

        this._fulfill(val);
    },

    _fulfill : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.FULFILLED;
        this._value = val;

        this._callCallbacks(this._fulfilledCallbacks, val);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _reject : function(reason) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.REJECTED;
        this._value = reason;

        this._callCallbacks(this._rejectedCallbacks, reason);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _notify : function(val) {
        this._callCallbacks(this._progressCallbacks, val);
    },

    _addCallbacks : function(defer, onFulfilled, onRejected, onProgress, ctx) {
        if(onRejected && !isFunction(onRejected)) {
            ctx = onRejected;
            onRejected = undef;
        }
        else if(onProgress && !isFunction(onProgress)) {
            ctx = onProgress;
            onProgress = undef;
        }

        var cb;

        if(!this.isRejected()) {
            cb = { defer : defer, fn : isFunction(onFulfilled)? onFulfilled : undef, ctx : ctx };
            this.isFulfilled()?
                this._callCallbacks([cb], this._value) :
                this._fulfilledCallbacks.push(cb);
        }

        if(!this.isFulfilled()) {
            cb = { defer : defer, fn : onRejected, ctx : ctx };
            this.isRejected()?
                this._callCallbacks([cb], this._value) :
                this._rejectedCallbacks.push(cb);
        }

        if(this._status <= PROMISE_STATUS.RESOLVED) {
            this._progressCallbacks.push({ defer : defer, fn : onProgress, ctx : ctx });
        }
    },

    _callCallbacks : function(callbacks, arg) {
        var len = callbacks.length;
        if(!len) {
            return;
        }

        var isResolved = this.isResolved(),
            isFulfilled = this.isFulfilled();

        nextTick(function() {
            var i = 0, cb, defer, fn;
            while(i < len) {
                cb = callbacks[i++];
                defer = cb.defer;
                fn = cb.fn;

                if(fn) {
                    var ctx = cb.ctx,
                        res;
                    try {
                        res = ctx? fn.call(ctx, arg) : fn(arg);
                    }
                    catch(e) {
                        defer.reject(e);
                        continue;
                    }

                    isResolved?
                        defer.resolve(res) :
                        defer.notify(res);
                }
                else {
                    isResolved?
                        isFulfilled?
                            defer.resolve(arg) :
                            defer.reject(arg) :
                        defer.notify(arg);
                }
            }
        });
    }
};

/** @lends Promise */
var staticMethods = {
    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return vow.cast(value);
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     */
    all : function(iterable) {
        return vow.all(iterable);
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` are fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    race : function(iterable) {
        return vow.anyResolved(iterable);
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        return vow.resolve(value);
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        return vow.reject(reason);
    }
};

for(var prop in staticMethods) {
    staticMethods.hasOwnProperty(prop) &&
        (Promise[prop] = staticMethods[prop]);
}

var vow = /** @exports vow */ {
    Deferred : Deferred,

    Promise : Promise,

    /**
     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
     * It's equivalent to `new vow.Deferred()`.
     *
     * @returns {vow:Deferred}
     */
    defer : function() {
        return new Deferred();
    },

    /**
     * Static equivalent to `promise.then`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    when : function(value, onFulfilled, onRejected, onProgress, ctx) {
        return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.fail`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onRejected Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(value, onRejected, ctx) {
        return vow.when(value, undef, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.always`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onResolved Callback that will to be invoked with the reason after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(value, onResolved, ctx) {
        return vow.when(value).always(onResolved, ctx);
    },

    /**
     * Static equivalent to `promise.progress`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onProgress Callback that will to be invoked with the reason after promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(value, onProgress, ctx) {
        return vow.when(value).progress(onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.spread`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    spread : function(value, onFulfilled, onRejected, ctx) {
        return vow.when(value).spread(onFulfilled, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.done`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     */
    done : function(value, onFulfilled, onRejected, onProgress, ctx) {
        vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Checks whether the given `value` is a promise-like object
     *
     * @param {*} value
     * @returns {Boolean}
     *
     * @example
     * ```js
     * vow.isPromise('something'); // returns false
     * vow.isPromise(vow.defer().promise()); // returns true
     * vow.isPromise({ then : function() { }); // returns true
     * ```
     */
    isPromise : function(value) {
        return isObject(value) && isFunction(value.then);
    },

    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return value && !!value._vow?
            value :
            vow.resolve(value);
    },

    /**
     * Static equivalent to `promise.valueOf`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {*}
     */
    valueOf : function(value) {
        return value && isFunction(value.valueOf)? value.valueOf() : value;
    },

    /**
     * Static equivalent to `promise.isFulfilled`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isFulfilled : function(value) {
        return value && isFunction(value.isFulfilled)? value.isFulfilled() : true;
    },

    /**
     * Static equivalent to `promise.isRejected`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isRejected : function(value) {
        return value && isFunction(value.isRejected)? value.isRejected() : false;
    },

    /**
     * Static equivalent to `promise.isResolved`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isResolved : function(value) {
        return value && isFunction(value.isResolved)? value.isResolved() : true;
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        var res = vow.defer();
        res.resolve(value);
        return res.promise();
    },

    /**
     * Returns a promise that has already been fulfilled with the given `value`.
     * If `value` is a promise, returned promise will be fulfilled with fulfill/rejection value of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    fulfill : function(value) {
        var defer = vow.defer(),
            promise = defer.promise();

        defer.resolve(value);

        return promise.isFulfilled()?
            promise :
            promise.then(null, function(reason) {
                return reason;
            });
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     * If `reason` is a promise, returned promise will be rejected with fulfill/rejection value of given promise.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        var defer = vow.defer();
        defer.reject(reason);
        return defer.promise();
    },

    /**
     * Invokes a given function `fn` with arguments `args`
     *
     * @param {Function} fn
     * @param {...*} [args]
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var promise1 = vow.invoke(function(value) {
     *         return value;
     *     }, 'ok'),
     *     promise2 = vow.invoke(function() {
     *         throw Error();
     *     });
     *
     * promise1.isFulfilled(); // true
     * promise1.valueOf(); // 'ok'
     * promise2.isRejected(); // true
     * promise2.valueOf(); // instance of Error
     * ```
     */
    invoke : function(fn, args) {
        var len = Math.max(arguments.length - 1, 0),
            callArgs;
        if(len) { // optimization for V8
            callArgs = Array(len);
            var i = 0;
            while(i < len) {
                callArgs[i++] = arguments[i];
            }
        }

        try {
            return vow.resolve(callArgs?
                fn.apply(global, callArgs) :
                fn.call(global));
        }
        catch(e) {
            return vow.reject(e);
        }
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * with array:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise(), 3])
     *     .then(function(value) {
     *          // value is "[1, 2, 3]" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     *
     * @example
     * with object:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
     *     .then(function(value) {
     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     */
    all : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            len = keys.length,
            res = isPromisesArray? [] : {};

        if(!len) {
            defer.resolve(res);
            return defer.promise();
        }

        var i = len;
        vow._forEach(
            iterable,
            function(value, idx) {
                res[keys[idx]] = value;
                if(!--i) {
                    defer.resolve(res);
                }
            },
            defer.reject,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are resolved.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
     *     promise1.isRejected(); // returns true
     *     promise1.valueOf(); // returns "'error'"
     *     promise2.isFulfilled(); // returns true
     *     promise2.valueOf(); // returns "'ok'"
     * });
     *
     * defer1.reject('error');
     * defer2.resolve('ok');
     * ```
     */
    allResolved : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            i = keys.length,
            res = isPromisesArray? [] : {};

        if(!i) {
            defer.resolve(res);
            return defer.promise();
        }

        var onResolved = function() {
                --i || defer.resolve(iterable);
            };

        vow._forEach(
            iterable,
            onResolved,
            onResolved,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    allPatiently : function(iterable) {
        return vow.allResolved(iterable).then(function() {
            var isPromisesArray = isArray(iterable),
                keys = isPromisesArray?
                    getArrayKeys(iterable) :
                    getObjectKeys(iterable),
                rejectedPromises, fulfilledPromises,
                len = keys.length, i = 0, key, promise;

            if(!len) {
                return isPromisesArray? [] : {};
            }

            while(i < len) {
                key = keys[i++];
                promise = iterable[key];
                if(vow.isRejected(promise)) {
                    rejectedPromises || (rejectedPromises = isPromisesArray? [] : {});
                    isPromisesArray?
                        rejectedPromises.push(promise.valueOf()) :
                        rejectedPromises[key] = promise.valueOf();
                }
                else if(!rejectedPromises) {
                    (fulfilledPromises || (fulfilledPromises = isPromisesArray? [] : {}))[key] = vow.valueOf(promise);
                }
            }

            if(rejectedPromises) {
                throw rejectedPromises;
            }

            return fulfilledPromises;
        });
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when all the items are rejected (with the reason of the first rejected item).
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    any : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        var i = 0, reason;
        vow._forEach(
            iterable,
            defer.resolve,
            function(e) {
                i || (reason = e);
                ++i === len && defer.reject(reason);
            },
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    anyResolved : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        vow._forEach(
            iterable,
            defer.resolve,
            defer.reject,
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Static equivalent to `promise.delay`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(value, delay) {
        return vow.resolve(value).delay(delay);
    },

    /**
     * Static equivalent to `promise.timeout`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} timeout
     * @returns {vow:Promise}
     */
    timeout : function(value, timeout) {
        return vow.resolve(value).timeout(timeout);
    },

    _forEach : function(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
        var len = keys? keys.length : promises.length,
            i = 0;

        while(i < len) {
            vow.when(
                promises[keys? keys[i] : i],
                wrapOnFulfilled(onFulfilled, i),
                onRejected,
                onProgress,
                ctx);
            ++i;
        }
    },

    TimedOutError : defineCustomErrorType('TimedOut')
};

var defineAsGlobal = true;
if(typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = vow;
    defineAsGlobal = false;
}

if(typeof modules === 'object' && isFunction(modules.define)) {
    modules.define('vow', function(provide) {
        provide(vow);
    });
    defineAsGlobal = false;
}

if(typeof define === 'function') {
    define(function(require, exports, module) {
        module.exports = vow;
    });
    defineAsGlobal = false;
}

defineAsGlobal && (global.vow = vow);

})(this);

}).call(this,require('_process'))

},{"_process":64}],27:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"global/window":28,"once":29,"parse-headers":33}],28:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],30:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21,"is-function":31}],31:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],32:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],33:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"for-each":30,"trim":32}],34:[function(require,module,exports){
var jalview = {};
module.exports = jalview;
var utils = require("./utils");

// http://www.jalview.org/help/html/features/featuresFormat.html
jalview.readHeader = function(lines) {
  var colors = {};
  var i = 0;
  var features = [];
  var currentGroup;

  for (; i < lines.length; i++) {
    var line = lines[i];
    if (line.indexOf("#") >= 0) {
      // no comments allowed -> stop
      break;
    }
    var columns = line.split(/\t/);
    var firstCell = columns[0].trim();
    if (firstCell === "GFF") {
      // this symbolizes the end 
      break;
    } else if (columns.length === 2) {
      if (firstCell === "startgroup") {
        currentGroup = columns[1].trim();
      } else if (firstCell === "endgroup") {
        currentGroup = "";
        continue;
      } else {
        // parse color
        colors[columns[0]] = jalview.parseColor(columns[1]);
      }
    } else if(columns.length >= 5){
      var arr = jalview.parseLine(columns);
      if (currentGroup) {
        arr.attributes.Parent = currentGroup;
      }
      features.push(arr);
    }
  }

  return {
    offset: i,
    colors: colors,
    features: features
  };
};

jalview.parseColor = function(cell) {
  if (cell.indexOf(",") >= 0) {
    // rgb code
    return utils.rgbToHex(cell.split(",").map(function(el) {
      return parseInt(el);
    }));
  }
  // color names with length == 6
  // 'bisque,maroon,orange,orchid,purple,salmon,sienna,tomato,violet,yellow'
  if (cell.length === 6 && parseInt(cell.charAt(0), 16) <= 16 && cell !== 'bisque') {
    // hex code
    return "#" + cell;
  }
  // color name
  return cell;
};


jalview.parseLine = function(columns) {
  var obj = {
    attributes: {}
  };
  obj.attributes.Name = columns[0].trim(); //desc
  obj.seqname = columns[1].trim(); // id
  obj.start = parseInt(columns[3]);
  obj.end = parseInt(columns[4]);
  obj.feature = columns[5].trim();
  if (obj.seqname === "ID_NOT_SPECIFIED") {
    obj.seqname = columns[2].trim(); // alternative id
  }
  return obj;
};

},{"./utils":35}],35:[function(require,module,exports){
var utils = {};
module.exports = utils;

utils.extractKeys = function extractKeys(attr) {
  // extract key-value definitions
  var attributes = {};
  var attrArr = attr.split(";");
  attrArr.forEach(function(el) {
    var keyArr, key, val;
    if (el.indexOf("=") > 0) {
      keyArr = el.split("=");
      key = keyArr[0];
      val = keyArr[1];
      attributes[key] = val;
    } else if (el.indexOf(" ") > 0) {
      keyArr = el.split(" ");
      key = keyArr[0];
      val = keyArr[1].replace(/"/g, '');
      attributes[key] = val;
    }
  });
  return attributes;
};

function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}

utils.rgbToHex = function(r, g, b) {
  if(r.length === 3){
    return utils.rgbToHex(r[0],r[1], r[2]);
  }
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
};

},{}],36:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"request":38,"vow":37}],37:[function(require,module,exports){
(function (process){
/**
 * @module vow
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @version 0.4.9
 * @license
 * Dual licensed under the MIT and GPL licenses:
 *   * http://www.opensource.org/licenses/mit-license.php
 *   * http://www.gnu.org/licenses/gpl.html
 */

(function(global) {

var undef,
    nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
                return fns.push(fn) === 1;
            },
            callFns = function() {
                var fnsToCall = fns, i = 0, len = fns.length;
                fns = [];
                while(i < len) {
                    fnsToCall[i++]();
                }
            };

        if(typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
            return function(fn) {
                enqueueFn(fn) && setImmediate(callFns);
            };
        }

        if(typeof process === 'object' && process.nextTick) { // nodejs < 0.10
            return function(fn) {
                enqueueFn(fn) && process.nextTick(callFns);
            };
        }

        if(global.postMessage) { // modern browsers
            var isPostMessageAsync = true;
            if(global.attachEvent) {
                var checkAsync = function() {
                        isPostMessageAsync = false;
                    };
                global.attachEvent('onmessage', checkAsync);
                global.postMessage('__checkAsync', '*');
                global.detachEvent('onmessage', checkAsync);
            }

            if(isPostMessageAsync) {
                var msg = '__promise' + +new Date,
                    onMessage = function(e) {
                        if(e.data === msg) {
                            e.stopPropagation && e.stopPropagation();
                            callFns();
                        }
                    };

                global.addEventListener?
                    global.addEventListener('message', onMessage, true) :
                    global.attachEvent('onmessage', onMessage);

                return function(fn) {
                    enqueueFn(fn) && global.postMessage(msg, '*');
                };
            }
        }

        var doc = global.document;
        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
            var createScript = function() {
                    var script = doc.createElement('script');
                    script.onreadystatechange = function() {
                        script.parentNode.removeChild(script);
                        script = script.onreadystatechange = null;
                        callFns();
                };
                (doc.documentElement || doc.body).appendChild(script);
            };

            return function(fn) {
                enqueueFn(fn) && createScript();
            };
        }

        return function(fn) { // old browsers
            enqueueFn(fn) && setTimeout(callFns, 0);
        };
    })(),
    throwException = function(e) {
        nextTick(function() {
            throw e;
        });
    },
    isFunction = function(obj) {
        return typeof obj === 'function';
    },
    isObject = function(obj) {
        return obj !== null && typeof obj === 'object';
    },
    toStr = Object.prototype.toString,
    isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
    },
    getArrayKeys = function(arr) {
        var res = [],
            i = 0, len = arr.length;
        while(i < len) {
            res.push(i++);
        }
        return res;
    },
    getObjectKeys = Object.keys || function(obj) {
        var res = [];
        for(var i in obj) {
            obj.hasOwnProperty(i) && res.push(i);
        }
        return res;
    },
    defineCustomErrorType = function(name) {
        var res = function(message) {
            this.name = name;
            this.message = message;
        };

        res.prototype = new Error();

        return res;
    },
    wrapOnFulfilled = function(onFulfilled, idx) {
        return function(val) {
            onFulfilled.call(this, val, idx);
        };
    };

/**
 * @class Deferred
 * @exports vow:Deferred
 * @description
 * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
 */

/**
 * @constructor
 * @description
 * You can use `vow.defer()` instead of using this constructor.
 *
 * `new vow.Deferred()` gives the same result as `vow.defer()`.
 */
var Deferred = function() {
    this._promise = new Promise();
};

Deferred.prototype = /** @lends Deferred.prototype */{
    /**
     * Returns corresponding promise.
     *
     * @returns {vow:Promise}
     */
    promise : function() {
        return this._promise;
    },

    /**
     * Resolves corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.then(function(value) {
     *     // value is "'success'" here
     * });
     *
     * defer.resolve('success');
     * ```
     */
    resolve : function(value) {
        this._promise.isResolved() || this._promise._resolve(value);
    },

    /**
     * Rejects corresponding promise with given `reason`.
     *
     * @param {*} reason
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.fail(function(reason) {
     *     // reason is "'something is wrong'" here
     * });
     *
     * defer.reject('something is wrong');
     * ```
     */
    reject : function(reason) {
        if(this._promise.isResolved()) {
            return;
        }

        if(vow.isPromise(reason)) {
            reason = reason.then(function(val) {
                var defer = vow.defer();
                defer.reject(val);
                return defer.promise();
            });
            this._promise._resolve(reason);
        }
        else {
            this._promise._reject(reason);
        }
    },

    /**
     * Notifies corresponding promise with given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.progress(function(value) {
     *     // value is "'20%'", "'40%'" here
     * });
     *
     * defer.notify('20%');
     * defer.notify('40%');
     * ```
     */
    notify : function(value) {
        this._promise.isResolved() || this._promise._notify(value);
    }
};

var PROMISE_STATUS = {
    PENDING   : 0,
    RESOLVED  : 1,
    FULFILLED : 2,
    REJECTED  : 3
};

/**
 * @class Promise
 * @exports vow:Promise
 * @description
 * The `Promise` class is used when you want to give to the caller something to subscribe to,
 * but not the ability to resolve or reject the deferred.
 */

/**
 * @constructor
 * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
 * @description
 * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
 * In other case you should use `vow.defer()` and `defer.promise()` methods.
 * @example
 * ```js
 * function fetchJSON(url) {
 *     return new vow.Promise(function(resolve, reject, notify) {
 *         var xhr = new XMLHttpRequest();
 *         xhr.open('GET', url);
 *         xhr.responseType = 'json';
 *         xhr.send();
 *         xhr.onload = function() {
 *             if(xhr.response) {
 *                 resolve(xhr.response);
 *             }
 *             else {
 *                 reject(new TypeError());
 *             }
 *         };
 *     });
 * }
 * ```
 */
var Promise = function(resolver) {
    this._value = undef;
    this._status = PROMISE_STATUS.PENDING;

    this._fulfilledCallbacks = [];
    this._rejectedCallbacks = [];
    this._progressCallbacks = [];

    if(resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
        var _this = this,
            resolverFnLen = resolver.length;

        resolver(
            function(val) {
                _this.isResolved() || _this._resolve(val);
            },
            resolverFnLen > 1?
                function(reason) {
                    _this.isResolved() || _this._reject(reason);
                } :
                undef,
            resolverFnLen > 2?
                function(val) {
                    _this.isResolved() || _this._notify(val);
                } :
                undef);
    }
};

Promise.prototype = /** @lends Promise.prototype */ {
    /**
     * Returns value of fulfilled promise or reason in case of rejection.
     *
     * @returns {*}
     */
    valueOf : function() {
        return this._value;
    },

    /**
     * Returns `true` if promise is resolved.
     *
     * @returns {Boolean}
     */
    isResolved : function() {
        return this._status !== PROMISE_STATUS.PENDING;
    },

    /**
     * Returns `true` if promise is fulfilled.
     *
     * @returns {Boolean}
     */
    isFulfilled : function() {
        return this._status === PROMISE_STATUS.FULFILLED;
    },

    /**
     * Returns `true` if promise is rejected.
     *
     * @returns {Boolean}
     */
    isRejected : function() {
        return this._status === PROMISE_STATUS.REJECTED;
    },

    /**
     * Adds reactions to promise.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
     */
    then : function(onFulfilled, onRejected, onProgress, ctx) {
        var defer = new Deferred();
        this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
        return defer.promise();
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(undefined, onRejected)`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    'catch' : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds rejection reaction only. It is shortcut for `promise.then(null, onRejected)`. It's alias for `catch`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(onRejected, ctx) {
        return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds resolving reaction (to fulfillment and rejection both).
     *
     * @param {Function} onResolved Callback that to be called with the value after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(onResolved, ctx) {
        var _this = this,
            cb = function() {
                return onResolved.call(this, _this);
            };

        return this.then(cb, cb, ctx);
    },

    /**
     * Adds progress reaction.
     *
     * @param {Function} onProgress Callback to be called with the value when promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(onProgress, ctx) {
        return this.then(undef, undef, onProgress, ctx);
    },

    /**
     * Like `promise.then`, but "spreads" the array into a variadic value handler.
     * It is useful with `vow.all` and `vow.allResolved` methods.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
     *     // arg1 is "1", arg2 is "'two'" here
     * });
     *
     * defer1.resolve(1);
     * defer2.resolve('two');
     * ```
     */
    spread : function(onFulfilled, onRejected, ctx) {
        return this.then(
            function(val) {
                return onFulfilled.apply(this, val);
            },
            onRejected,
            ctx);
    },

    /**
     * Like `then`, but terminates a chain of promises.
     * If the promise has been rejected, throws it as an exception in a future turn of the event loop.
     *
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     *
     * @example
     * ```js
     * var defer = vow.defer();
     * defer.reject(Error('Internal error'));
     * defer.promise().done(); // exception to be thrown
     * ```
     */
    done : function(onFulfilled, onRejected, onProgress, ctx) {
        this
            .then(onFulfilled, onRejected, onProgress, ctx)
            .fail(throwException);
    },

    /**
     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
     * or immediately rejected if promise is rejected.
     *
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(delay) {
        var timer,
            promise = this.then(function(val) {
                var defer = new Deferred();
                timer = setTimeout(
                    function() {
                        defer.resolve(val);
                    },
                    delay);

                return defer.promise();
            });

        promise.always(function() {
            clearTimeout(timer);
        });

        return promise;
    },

    /**
     * Returns a new promise that will be rejected in `timeout` milliseconds
     * if the promise is not resolved beforehand.
     *
     * @param {Number} timeout
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promiseWithTimeout1 = defer.promise().timeout(50),
     *     promiseWithTimeout2 = defer.promise().timeout(200);
     *
     * setTimeout(
     *     function() {
     *         defer.resolve('ok');
     *     },
     *     100);
     *
     * promiseWithTimeout1.fail(function(reason) {
     *     // promiseWithTimeout to be rejected in 50ms
     * });
     *
     * promiseWithTimeout2.then(function(value) {
     *     // promiseWithTimeout to be fulfilled with "'ok'" value
     * });
     * ```
     */
    timeout : function(timeout) {
        var defer = new Deferred(),
            timer = setTimeout(
                function() {
                    defer.reject(new vow.TimedOutError('timed out'));
                },
                timeout);

        this.then(
            function(val) {
                defer.resolve(val);
            },
            function(reason) {
                defer.reject(reason);
            });

        defer.promise().always(function() {
            clearTimeout(timer);
        });

        return defer.promise();
    },

    _vow : true,

    _resolve : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        if(val === this) {
            this._reject(TypeError('Can\'t resolve promise with itself'));
            return;
        }

        this._status = PROMISE_STATUS.RESOLVED;

        if(val && !!val._vow) { // shortpath for vow.Promise
            val.isFulfilled()?
                this._fulfill(val.valueOf()) :
                val.isRejected()?
                    this._reject(val.valueOf()) :
                    val.then(
                        this._fulfill,
                        this._reject,
                        this._notify,
                        this);
            return;
        }

        if(isObject(val) || isFunction(val)) {
            var then;
            try {
                then = val.then;
            }
            catch(e) {
                this._reject(e);
                return;
            }

            if(isFunction(then)) {
                var _this = this,
                    isResolved = false;

                try {
                    then.call(
                        val,
                        function(val) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._resolve(val);
                        },
                        function(err) {
                            if(isResolved) {
                                return;
                            }

                            isResolved = true;
                            _this._reject(err);
                        },
                        function(val) {
                            _this._notify(val);
                        });
                }
                catch(e) {
                    isResolved || this._reject(e);
                }

                return;
            }
        }

        this._fulfill(val);
    },

    _fulfill : function(val) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.FULFILLED;
        this._value = val;

        this._callCallbacks(this._fulfilledCallbacks, val);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _reject : function(reason) {
        if(this._status > PROMISE_STATUS.RESOLVED) {
            return;
        }

        this._status = PROMISE_STATUS.REJECTED;
        this._value = reason;

        this._callCallbacks(this._rejectedCallbacks, reason);
        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _notify : function(val) {
        this._callCallbacks(this._progressCallbacks, val);
    },

    _addCallbacks : function(defer, onFulfilled, onRejected, onProgress, ctx) {
        if(onRejected && !isFunction(onRejected)) {
            ctx = onRejected;
            onRejected = undef;
        }
        else if(onProgress && !isFunction(onProgress)) {
            ctx = onProgress;
            onProgress = undef;
        }

        var cb;

        if(!this.isRejected()) {
            cb = { defer : defer, fn : isFunction(onFulfilled)? onFulfilled : undef, ctx : ctx };
            this.isFulfilled()?
                this._callCallbacks([cb], this._value) :
                this._fulfilledCallbacks.push(cb);
        }

        if(!this.isFulfilled()) {
            cb = { defer : defer, fn : onRejected, ctx : ctx };
            this.isRejected()?
                this._callCallbacks([cb], this._value) :
                this._rejectedCallbacks.push(cb);
        }

        if(this._status <= PROMISE_STATUS.RESOLVED) {
            this._progressCallbacks.push({ defer : defer, fn : onProgress, ctx : ctx });
        }
    },

    _callCallbacks : function(callbacks, arg) {
        var len = callbacks.length;
        if(!len) {
            return;
        }

        var isResolved = this.isResolved(),
            isFulfilled = this.isFulfilled();

        nextTick(function() {
            var i = 0, cb, defer, fn;
            while(i < len) {
                cb = callbacks[i++];
                defer = cb.defer;
                fn = cb.fn;

                if(fn) {
                    var ctx = cb.ctx,
                        res;
                    try {
                        res = ctx? fn.call(ctx, arg) : fn(arg);
                    }
                    catch(e) {
                        defer.reject(e);
                        continue;
                    }

                    isResolved?
                        defer.resolve(res) :
                        defer.notify(res);
                }
                else {
                    isResolved?
                        isFulfilled?
                            defer.resolve(arg) :
                            defer.reject(arg) :
                        defer.notify(arg);
                }
            }
        });
    }
};

/** @lends Promise */
var staticMethods = {
    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return vow.cast(value);
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     */
    all : function(iterable) {
        return vow.all(iterable);
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` are fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    race : function(iterable) {
        return vow.anyResolved(iterable);
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        return vow.resolve(value);
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        return vow.reject(reason);
    }
};

for(var prop in staticMethods) {
    staticMethods.hasOwnProperty(prop) &&
        (Promise[prop] = staticMethods[prop]);
}

var vow = /** @exports vow */ {
    Deferred : Deferred,

    Promise : Promise,

    /**
     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
     * It's equivalent to `new vow.Deferred()`.
     *
     * @returns {vow:Deferred}
     */
    defer : function() {
        return new Deferred();
    },

    /**
     * Static equivalent to `promise.then`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    when : function(value, onFulfilled, onRejected, onProgress, ctx) {
        return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.fail`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onRejected Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    fail : function(value, onRejected, ctx) {
        return vow.when(value, undef, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.always`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onResolved Callback that will to be invoked with the reason after promise has been resolved
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    always : function(value, onResolved, ctx) {
        return vow.when(value).always(onResolved, ctx);
    },

    /**
     * Static equivalent to `promise.progress`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onProgress Callback that will to be invoked with the reason after promise has been notified
     * @param {Object} [ctx] Context of callback execution
     * @returns {vow:Promise}
     */
    progress : function(value, onProgress, ctx) {
        return vow.when(value).progress(onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.spread`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Object} [ctx] Context of callbacks execution
     * @returns {vow:Promise}
     */
    spread : function(value, onFulfilled, onRejected, ctx) {
        return vow.when(value).spread(onFulfilled, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.done`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will to be invoked with the value after promise has been fulfilled
     * @param {Function} [onRejected] Callback that will to be invoked with the reason after promise has been rejected
     * @param {Function} [onProgress] Callback that will to be invoked with the value after promise has been notified
     * @param {Object} [ctx] Context of callbacks execution
     */
    done : function(value, onFulfilled, onRejected, onProgress, ctx) {
        vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Checks whether the given `value` is a promise-like object
     *
     * @param {*} value
     * @returns {Boolean}
     *
     * @example
     * ```js
     * vow.isPromise('something'); // returns false
     * vow.isPromise(vow.defer().promise()); // returns true
     * vow.isPromise({ then : function() { }); // returns true
     * ```
     */
    isPromise : function(value) {
        return isObject(value) && isFunction(value.then);
    },

    /**
     * Coerces given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast : function(value) {
        return value && !!value._vow?
            value :
            vow.resolve(value);
    },

    /**
     * Static equivalent to `promise.valueOf`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {*}
     */
    valueOf : function(value) {
        return value && isFunction(value.valueOf)? value.valueOf() : value;
    },

    /**
     * Static equivalent to `promise.isFulfilled`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isFulfilled : function(value) {
        return value && isFunction(value.isFulfilled)? value.isFulfilled() : true;
    },

    /**
     * Static equivalent to `promise.isRejected`.
     * If given `value` is not an instance of `vow.Promise`, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isRejected : function(value) {
        return value && isFunction(value.isRejected)? value.isRejected() : false;
    },

    /**
     * Static equivalent to `promise.isResolved`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isResolved : function(value) {
        return value && isFunction(value.isResolved)? value.isResolved() : true;
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, returned promise will be adopted with the state of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve : function(value) {
        var res = vow.defer();
        res.resolve(value);
        return res.promise();
    },

    /**
     * Returns a promise that has already been fulfilled with the given `value`.
     * If `value` is a promise, returned promise will be fulfilled with fulfill/rejection value of given promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    fulfill : function(value) {
        var defer = vow.defer(),
            promise = defer.promise();

        defer.resolve(value);

        return promise.isFulfilled()?
            promise :
            promise.then(null, function(reason) {
                return reason;
            });
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     * If `reason` is a promise, returned promise will be rejected with fulfill/rejection value of given promise.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject : function(reason) {
        var defer = vow.defer();
        defer.reject(reason);
        return defer.promise();
    },

    /**
     * Invokes a given function `fn` with arguments `args`
     *
     * @param {Function} fn
     * @param {...*} [args]
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var promise1 = vow.invoke(function(value) {
     *         return value;
     *     }, 'ok'),
     *     promise2 = vow.invoke(function() {
     *         throw Error();
     *     });
     *
     * promise1.isFulfilled(); // true
     * promise1.valueOf(); // 'ok'
     * promise2.isRejected(); // true
     * promise2.valueOf(); // instance of Error
     * ```
     */
    invoke : function(fn, args) {
        var len = Math.max(arguments.length - 1, 0),
            callArgs;
        if(len) { // optimization for V8
            callArgs = Array(len);
            var i = 0;
            while(i < len) {
                callArgs[i++] = arguments[i];
            }
        }

        try {
            return vow.resolve(callArgs?
                fn.apply(global, callArgs) :
                fn.call(global));
        }
        catch(e) {
            return vow.reject(e);
        }
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are fulfilled,
     * or to be rejected when any of the `iterable` is rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * with array:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise(), 3])
     *     .then(function(value) {
     *          // value is "[1, 2, 3]" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     *
     * @example
     * with object:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
     *     .then(function(value) {
     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     */
    all : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            len = keys.length,
            res = isPromisesArray? [] : {};

        if(!len) {
            defer.resolve(res);
            return defer.promise();
        }

        var i = len;
        vow._forEach(
            iterable,
            function(value, idx) {
                res[keys[idx]] = value;
                if(!--i) {
                    defer.resolve(res);
                }
            },
            defer.reject,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only after all the items in `iterable` are resolved.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
     *     promise1.isRejected(); // returns true
     *     promise1.valueOf(); // returns "'error'"
     *     promise2.isFulfilled(); // returns true
     *     promise2.valueOf(); // returns "'ok'"
     * });
     *
     * defer1.reject('error');
     * defer2.resolve('ok');
     * ```
     */
    allResolved : function(iterable) {
        var defer = new Deferred(),
            isPromisesArray = isArray(iterable),
            keys = isPromisesArray?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            i = keys.length,
            res = isPromisesArray? [] : {};

        if(!i) {
            defer.resolve(res);
            return defer.promise();
        }

        var onResolved = function() {
                --i || defer.resolve(iterable);
            };

        vow._forEach(
            iterable,
            onResolved,
            onResolved,
            defer.notify,
            defer,
            keys);

        return defer.promise();
    },

    allPatiently : function(iterable) {
        return vow.allResolved(iterable).then(function() {
            var isPromisesArray = isArray(iterable),
                keys = isPromisesArray?
                    getArrayKeys(iterable) :
                    getObjectKeys(iterable),
                rejectedPromises, fulfilledPromises,
                len = keys.length, i = 0, key, promise;

            if(!len) {
                return isPromisesArray? [] : {};
            }

            while(i < len) {
                key = keys[i++];
                promise = iterable[key];
                if(vow.isRejected(promise)) {
                    rejectedPromises || (rejectedPromises = isPromisesArray? [] : {});
                    isPromisesArray?
                        rejectedPromises.push(promise.valueOf()) :
                        rejectedPromises[key] = promise.valueOf();
                }
                else if(!rejectedPromises) {
                    (fulfilledPromises || (fulfilledPromises = isPromisesArray? [] : {}))[key] = vow.valueOf(promise);
                }
            }

            if(rejectedPromises) {
                throw rejectedPromises;
            }

            return fulfilledPromises;
        });
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when all the items are rejected (with the reason of the first rejected item).
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    any : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        var i = 0, reason;
        vow._forEach(
            iterable,
            defer.resolve,
            function(e) {
                i || (reason = e);
                ++i === len && defer.reject(reason);
            },
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Returns a promise to be fulfilled only when any of the items in `iterable` is fulfilled,
     * or to be rejected when the first item is rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    anyResolved : function(iterable) {
        var defer = new Deferred(),
            len = iterable.length;

        if(!len) {
            defer.reject(Error());
            return defer.promise();
        }

        vow._forEach(
            iterable,
            defer.resolve,
            defer.reject,
            defer.notify,
            defer);

        return defer.promise();
    },

    /**
     * Static equivalent to `promise.delay`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay : function(value, delay) {
        return vow.resolve(value).delay(delay);
    },

    /**
     * Static equivalent to `promise.timeout`.
     * If given `value` is not a promise, then `value` is equivalent to fulfilled promise.
     *
     * @param {*} value
     * @param {Number} timeout
     * @returns {vow:Promise}
     */
    timeout : function(value, timeout) {
        return vow.resolve(value).timeout(timeout);
    },

    _forEach : function(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
        var len = keys? keys.length : promises.length,
            i = 0;

        while(i < len) {
            vow.when(
                promises[keys? keys[i] : i],
                wrapOnFulfilled(onFulfilled, i),
                onRejected,
                onProgress,
                ctx);
            ++i;
        }
    },

    TimedOutError : defineCustomErrorType('TimedOut')
};

var defineAsGlobal = true;
if(typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = vow;
    defineAsGlobal = false;
}

if(typeof modules === 'object' && isFunction(modules.define)) {
    modules.define('vow', function(provide) {
        provide(vow);
    });
    defineAsGlobal = false;
}

if(typeof define === 'function') {
    define(function(require, exports, module) {
        module.exports = vow;
    });
    defineAsGlobal = false;
}

defineAsGlobal && (global.vow = vow);

})(this);

}).call(this,require('_process'))

},{"_process":64}],38:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"global/window":39,"once":40,"parse-headers":44}],39:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],40:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],41:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21,"is-function":42}],42:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],43:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],44:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"for-each":41,"trim":43}],45:[function(require,module,exports){
module.exports.seq = require("./seq");

},{"./seq":46}],46:[function(require,module,exports){
module.exports = function(seq, name, id) {
    this.seq = seq;
    this.name = name;
    this.id = id;
    this.meta = {};
};

},{}],47:[function(require,module,exports){
// this is a light-weight build without the scrolling module
module.exports = require("./src/index.js");

},{"./src/index.js":53}],48:[function(require,module,exports){
module.exports = {
    render_x_axis_label: function () {
      var label = "Model Position";
      if (this.display_ali_map) {
        label = "Alignment Column";
      }
      this.called_on.find('.logo_xaxis').remove();
      this.called_on.prepend('<div class="logo_xaxis" class="centered" style="margin-left:40px"><p class="xaxis_text" style="width:10em;margin:1em auto">' + label + '</p></div>');

    },
    render_y_axis_label: function () {
      //attach a canvas for the y-axis
      this.dom_element.parent().before('<canvas class="logo_yaxis" height="'+this.options.height+'" width="55"></canvas>');
      var canvas = this.called_on.find('.logo_yaxis'),
      top_pix_height = 0,
      bottom_pix_height = 0,
      top_height = Math.abs(this.data.max_height),
      bottom_height = (isNaN(this.data.min_height_obs)) ? 0 : parseInt(this.data.min_height_obs, 10),
      context = null,
      axis_label = "Information Content (bits)";

      context = canvas[0].getContext('2d');
      //draw min/max tick marks
      context.beginPath();
      context.moveTo(55, 1);
      context.lineTo(40, 1);

      context.moveTo(55, this.info_content_height);
      context.lineTo(40, this.info_content_height);


      context.moveTo(55, (this.info_content_height / 2));
      context.lineTo(40, (this.info_content_height / 2));
      context.lineWidth = 1;
      context.strokeStyle = "#666666";
      context.stroke();

      //draw the label text
      context.fillStyle = "#666666";
      context.textAlign = "right";
      context.font = "bold 10px Arial";

      // draw the max label
      context.textBaseline = "top";
      context.fillText(parseFloat(this.data.max_height).toFixed(1), 38, 0);
      context.textBaseline = "middle";

      // draw the midpoint labels
      context.fillText(parseFloat(this.data.max_height / 2).toFixed(1), 38, (this.info_content_height / 2));
      // draw the min label
      context.fillText('0', 38, this.info_content_height);

      // draw the axis label
      if (this.data.height_calc === 'score') {
        axis_label = "Score (bits)";
      }

      context.save();
      context.translate(5, this.height / 2 - 20);
      context.rotate(-Math.PI / 2);
      context.textAlign = "center";
      context.font = "normal 12px Arial";
      context.fillText(axis_label, 1, 0);
      context.restore();

      // draw the insert row labels
      context.fillText('occupancy', 55, this.info_content_height + 7);
      if (this.show_inserts) {
        context.fillText('ins. prob.', 50, 280);
        context.fillText('ins. len.', 46, 296);
      }
    }
}; 

},{}],49:[function(require,module,exports){
var canv_support = null;

module.exports = function canvasSupport() {
  if (!canv_support) {
    var elem = document.createElement('canvas');
    canv_support = !!(elem.getContext && elem.getContext('2d'));
  }
  return canv_support;
}

},{}],50:[function(require,module,exports){
module.exports = {
  'A': '#FF9966',
  'C': '#009999',
  'D': '#FF0000',
  'E': '#CC0033',
  'F': '#00FF00',
  'G': '#f2f20c',
  'H': '#660033',
  'I': '#CC9933',
  'K': '#663300',
  'L': '#FF9933',
  'M': '#CC99CC',
  'N': '#336666',
  'P': '#0099FF',
  'Q': '#6666CC',
  'R': '#990000',
  'S': '#0000FF',
  'T': '#00FFFF',
  'V': '#FFCC33',
  'W': '#66CC66',
  'Y': '#006600'
};

},{}],51:[function(require,module,exports){
module.exports = {
    'A': '#cbf751',
    'C': '#5ec0cc',
    'G': '#ffdf59',
    'T': '#b51f16',
    'U': '#b51f16'
  };

},{}],52:[function(require,module,exports){
var $ = require("jbone");

module.exports = function($el,logo, logo_graphic){

  $el.find('.logo_settings_switch, .logo_settings .close').on('click', function (e) {
    e.preventDefault();
    $('.logo_settings').toggle();
  });

  $el.find('.logo_reset').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({'target': logo.default_zoom});
  });

  $el.find('.logo_change').on('click', function (e) {
    e.preventDefault();
  });

  $el.find('.logo_zoomin').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({'distance': 0.1, 'direction': '+'});
  });

  $el.find('.logo_zoomout').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({'distance': 0.1, 'direction': '-'});
  });

  $el.find('.logo_scale').on('change', function (e) {
    logo.toggleScale(this.value);
  });

  $el.find('.logo_color').on('change', function (e) {
    logo.toggleColorscheme(this.value);
  });

  $el.find('.logo_ali_map').on('change', function (e) {
    logo.toggleAliMap(this.value);
  });

  $el.find('.logo_position').on('change', function () {
    if (!this.value.match(/^\d+$/m)) {
      return;
    }
    logo.scrollToColumn(this.value, 1);
  });

  logo_graphic.on('dblclick', function (e) {
    // need to get coordinates of mouse click
    console.log("dblclick", logo);

    offset = logo.logo_graphic.offset(),
    x = parseInt((e.pageX - offset.left), 10),

    // get mouse position in the window
    window_position = e.pageX - $el.parent().offset().left,

    // get column number
    col = logo.columnFromCoordinates(x),

    console.log("col", col);

    // choose new zoom level and zoom in.
    current = logo.zoom;

    if (current < 1) {
      logo.changeZoom({'target': 1, offset: window_position, column: col});
    } else {
      logo.changeZoom({'target': 0.3, offset: window_position, column: col});
    }

    return;
  });

  $(document).on($el.attr('id') + ".scrolledTo", function (e, left, top, zoom) {
    logo.render({target: left});
  });

  $(document).on('keydown', function (e) {
    if (!e.ctrlKey) {
      if (e.which === 61 || e.which === 107) {
        zoom += 0.1;
        logo.changeZoom({'distance': 0.1, 'direction': '+'});
      }
      if (e.which === 109 || e.which === 0) {
        zoom = zoom - 0.1;
        logo.changeZoom({'distance': 0.1, 'direction': '-'});
      }
    }
  });
}

},{"jbone":67}],53:[function(require,module,exports){
_ = require("underscore");

//var ConsensusColors = require("./consensusColors.js");
var canvasSupport = require("./canvasSupport.js");
var render = require("./render/render.js");
var Letter = require("./model/letter.js");
var view = require("backbone-viewj");
var axis = require("./axis");
var eventListener = require("./eventListener.js");
var settings = require("./info/settings.js");

var jbone = require("jbone");

module.exports = view.extend({

  options: {
    xaxis: true,
    yaxis: true,
    height: 300,
    column_width: 34,
    debug: true,
    scale_height_enabled: true,
    scaled_max: true,
    zoom_buttons: true,
    colorscheme: 'default',
    data: undefined,
    start: 1,
    end: undefined,
    zoom: 0.4,
    colors: undefined,
    divider: false,
    show_probs: false,
    divider_step: 5,
    show_divider: false,
    border: false,
    settings: false,
    scroller: true,
    positionMarker: true
  },

  loadDefault: function(options){
    this.data = options.data;

    // never show the alignment coordinates by default as that would get
    // really confusing.
    this.display_ali_map = 0;

    this.alphabet = options.data.alphabet || 'dna';

    this.start = options.start;
    //this.end = options.end || this.data.heightArr.length;
    this.zoom = parseFloat(options.zoom) || 0.4;
    this.default_zoom = this.zoom;

    this.column_width = options.column_width;
    this.height = options.height;
    this.canvas_width = 5000;
    this.scale_height_enabled = options.scale_height_enabled;

    // this needs to be set to null here so that we can initialise it after
    // the render function has fired and the width determined.
    this.scrollme = null;

    this.previous_target = 0;
    // keeps track of which canvas elements have been drawn and which ones haven't.
    this.rendered = [];
    this.previous_zoom = 0;

    if(this.data.max_height == undefined){
      this.data.max_height = this.calcMaxHeight(this.data.heightArr); 
    }

    // only show insert when we actually have the data
    if(!this.data.insert_probs || !this.data.delete_probs){
      this.options.show_probs = false;
    }

    if (options.scaled_max) {
      this.data.max_height = options.data.max_height_obs || this.data.max_height || 2;
    } else {
      this.data.max_height = options.data.max_height_theory || this.data.max_height || 2;
    }

    if(options.colors){
      this.changeColors(options.colors);
    }else{
      if (this.alphabet === 'aa') {
        this.aa_colors = require("./colors/aa.js");
        this.changeColors(this.aa_colors);
      }else{
        this.dna_colors = require("./colors/dna.js");
        this.changeColors(this.dna_colors);
      }
    }
  },
  initialize: function(options) {
    if (!canvasSupport()) {
      this.el.textContent = "Your browser doesn't support canvas.";
      return;
    }
    if(options.data == undefined){
      this.el.textContent = "No data added.";
    }

    // load default settings
    _.extend(this.options,options);
    var opt = this.options;
    this.loadDefault(opt);

    if(!this.options.show_probs){
      this.info_content_height = this.height;
    }else{
      // turn off the insert rows if the hmm used the observed or weighted processing flags.
      if (this.data.processing && /^observed|weighted/.test(this.data.processing)) {
        this.show_inserts = 0;
        this.info_content_height = this.height - 14;
      } else {
        this.show_inserts = 1;
        this.info_content_height = this.height - 44;
      }
    }
    this.$el = jbone(this.el);

    this.initDivs();

    if(this.options.settings){
      var form = settings(this,opt);
      this.$el.append(form);
    }

    eventListener(this.$el,this, this.logo_graphic);
    /*
       if (opt.columnInfo) {
       var columnInfo = require("./info/column_info.js");
       columnInfo(this);
       }
       */

  },
  initDivs: function(){
    var logo_graphic = mk("div");
    logo_graphic.className = "logo_graphic";
    this.logo_graphic = jbone(logo_graphic);

    var container = mk("div");
    container.className = "logo_container";
    container.style.height = this.height;
    this.container = jbone(container);

    this.container.append(logo_graphic);

    // add some internal divs for scrolling etc.
    this.$el.append(container);

    if(this.options.divider){
      var divider = mk("div");
      divider.className = "logo_divider";
      this.$el.append(divider);
    }

    this.dom_element = jbone(logo_graphic);
    this.called_on = this.$el;

    if(this.options.xaxis){
      axis.render_x_axis_label.call(this);
    }
    if(this.options.yaxis){
      axis.render_y_axis_label.call(this);
    }else{
      this.container[0].style.marginLeft = "0px";
    }

  },

  render: function(){
    render.call(this); 
    return this;
  },

  changeColors: function(colors){
    this.colors = colors;
    var bUseColorObject = (colors != undefined && colors.type != undefined);
    if(bUseColorObject){
      this.colorscheme = "dynamic";
    }
    this.buildAlphabet();
  },

  buildAlphabet: function(){
    /*
       if (this.alphabet === 'aa') {
       var probs_arr = this.data.probs_arr;
       if (probs_arr) {
       var cc = new ConsensusColors();
       this.cmap = cc.color_map(probs_arr);
       }
       }
       */

    //build the letter canvases
    this.letters = {};
    var colors = this.colors;
    if(this.colorscheme == "dynamic"){
      var tColors = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
      colors = {};
      tColors.forEach(function(e){
        colors[e] = "";
      });
    }
    for (var letter in colors) {
      if (colors.hasOwnProperty(letter)) {
        var loptions = {color: colors[letter]};
        this.letters[letter] = new Letter(letter, loptions);
      }
    }
  },

  toggleColorscheme: function (scheme) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();

    if (scheme) {
      if (scheme === 'default') {
        this.colorscheme = 'default';
      } else {
        this.colorscheme = 'consensus';
      }
    } else {
      if (this.colorscheme === 'default') {
        this.colorscheme = 'consensus';
      } else {
        this.colorscheme = 'default';
      }
    }

    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },

  toggleScale: function (scale) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();

    if (scale) {
      if (scale === 'obs') {
        this.data.max_height = this.data.max_height_obs;
      } else {
        this.data.max_height = this.data.max_height_theory;
      }
    } else {
      // toggle the max height
      if (this.data.max_height === this.data.max_height_obs) {
        this.data.max_height = this.data.max_height_theory;
      } else {
        this.data.max_height = this.data.max_height_obs;
      }
    }
    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];
    //update the y-axis
    if(this.logoYAxis){
      this.logoYAxis.remove();
      //this.called_on.find('.logo_yaxis').remove();
    }
    axis.render_y_axis_label.call(this);

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },
  toggleAliMap: function (coords) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();

    if (coords) {
      if (coords === 'model') {
        this.display_ali_map = 0;
      } else {
        this.display_ali_map = 1;
      }
    } else {
      // toggle the max height
      if (this.display_ali_map === 1) {
        this.display_ali_map = 0;
      } else {
        this.display_ali_map = 1;
      }
    }
    axis.render_x_axis_label(this);

    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },

  currentColumn: function () {
    var before_left = this.scrollme.scroller.getValues().left,
    col_width = (this.column_width * this.zoom),
    col_count = before_left / col_width,
    half_visible_columns = (this.container.width() / col_width) / 2,
    col_total = Math.ceil(col_count + half_visible_columns);
    return col_total;
  },

  changeZoom: function (options) {
    var zoom_level = 0.3,
    expected_width = null;
    if (options.target) {
      zoom_level = options.target;
    } else if (options.distance) {
      zoom_level = (parseFloat(this.zoom) - parseFloat(options.distance)).toFixed(1);
      if (options.direction === '+') {
        zoom_level = (parseFloat(this.zoom) + parseFloat(options.distance)).toFixed(1);
      }
    }

    if (zoom_level > 1) {
      zoom_level = 1;
    } else if (zoom_level < 0.1) {
      zoom_level = 0.1;
    }

    // see if we need to zoom or not
    expected_width = (this.logo_graphic.width() * zoom_level) / this.zoom;
    if (expected_width > this.container.width()) {
      // if a center is not specified, then use the current center of the view
      if (!options.column) {
        //work out my current position
        var col_total = this.currentColumn();

        this.zoom = zoom_level;
        this.render({zoom: this.zoom});
        this.scrollme.reflow();

        //scroll to previous position
        this.scrollToColumn(col_total);
      } else { // center around the mouse click position.
        this.zoom = zoom_level;
        this.render({zoom: this.zoom});
        this.scrollme.reflow();

        var coords = this.coordinatesFromColumn(options.column);
        this.scrollme.scroller.scrollTo(coords - options.offset);
      }
    }
    return this.zoom;

  },

  columnFromCoordinates: function (x) {
    var column = Math.ceil(x / (this.column_width * this.zoom));
    return column;
  },

  coordinatesFromColumn: function (col) {
    var new_column = col - 1,
    x = (new_column  * (this.column_width * this.zoom)) + ((this.column_width * this.zoom) / 2);
    return x;
  },

  scrollToColumn: function (num, animate) {
    var half_view = (this.logo_container.width() / 2),
    new_left = this.coordinatesFromColumn(num);
    this.scrollme.scroller.scrollTo(new_left - half_view, 0, animate);
  },
  calcMaxHeight: function(columns){
    // loops over all columns and return the max height seen 
    return columns.reduce(function(m,c){
      var col = 0;
      for(var k in c){
        col += c[k];
      }
      return col > m ? col : m;
    },0);
  }


});

var mk = function(name){
  return document.createElement(name);
}

},{"./axis":48,"./canvasSupport.js":49,"./colors/aa.js":50,"./colors/dna.js":51,"./eventListener.js":52,"./info/settings.js":54,"./model/letter.js":55,"./render/render.js":59,"backbone-viewj":9,"jbone":67,"underscore":91}],54:[function(require,module,exports){
var $ = require("jbone");

module.exports = function(logo,options){
  var form = $('<form class="logo_form"><fieldset><label for="position">Column number</label>' +
               '<input type="text" name="position" class="logo_position"></input>' +
               '<button class="button logo_change">Go</button></fieldset>' +
               '</form>');

  var settings = $('<div class="logo_settings"></div>');
  settings.append('<span class="close">x</span>');



  /* we don't want to toggle if the max height_obs is greater than max theoretical
   * as letters will fall off the top.
   */
  if (logo.scale_height_enabled && (logo.data.max_height_obs < logo.data.max_height_theory)) {
    var obs_checked = '',
    theory_checked = '',
    theory_help = '',
    obs_help = '';

    if (logo.data.max_height_obs === logo.data.max_height) {
      obs_checked = 'checked';
    } else {
      theory_checked = 'checked';
    }
  }



  var scale_controls = '<fieldset><legend>Scale</legend>' +
    '<label><input type="radio" name="scale" class="logo_scale" value="obs" ' + obs_checked +
    '/>Maximum Observed ' + obs_help +
    '</label></br>' +
    '<label><input type="radio" name="scale" class="logo_scale" value="theory" ' + theory_checked +
    '/>Maximum Theoretical ' + theory_help +
    '</label>' +
    '</fieldset>';

  settings.append(scale_controls);

  if (logo.data.height_calc !== 'score' && logo.data.alphabet === 'aa' && logo.data.probs_arr) {

    var def_color = null,
    con_color = null,
    def_help = '',
    con_help = '';

    if (logo.colorscheme === 'default') {
      def_color = 'checked';
    } else {
      con_color = 'checked';
    };

    if (options.help) {
      def_help = '<a class="help" href="/help#colors_default" title="Each letter receives its own color.">' +
        '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
      con_help = '<a class="help" href="/help#colors_consensus" title="Letters are colored as in Clustalx and Jalview, with colors depending on composition of the column.">' +
        '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
    }

    var color_controls = '<fieldset><legend>Color Scheme</legend>' +
      '<label><input type="radio" name="color" class="logo_color" value="default" ' + def_color +
      '/>Default ' + def_help +
      '</label></br>' +
      '<label><input type="radio" name="color" class="logo_color" value="consensus" ' + con_color +
      '/>Consensus Colors ' + con_help +
      '</label>' +
      '</fieldset>';
    settings.append(color_controls);
  }


  if (logo.data.ali_map) {
    var mod_checked = null,
    ali_checked = null,
    mod_help = '',
    ali_help = '';

    if (logo.display_ali_map === 0) {
      mod_checked = 'checked';
    } else {
      ali_checked = 'checked';
    }

    if (options.help) {
      mod_help = '<a class="help" href="/help#coords_model" title="The coordinates along the top of the plot show the model position.">' +
        '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
      ali_help = '<a class="help" href="/help#coords_ali" title="The coordinates along the top of the plot show the column in the alignment associated with the model">' +
        '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
    }

    var ali_controls = '<fieldset><legend>Coordinates</legend>' +
      '<label><input type="radio" name="coords" class="logo_ali_map" value="model" ' + mod_checked +
      '/>Model ' + mod_help +
      '</label></br>' +
      '<label><input type="radio" name="coords" class="logo_ali_map" value="alignment" ' + ali_checked +
      '/>Alignment ' + ali_help +
      '</label>' +
      '</fieldset>';
    settings.append(ali_controls);
  }


  var controls = $('<div class="logo_controls"></div>');
  if (logo.zoom_enabled) {
    controls.append('<button class="logo_zoomout button">-</button>' +
                    '<button class="logo_zoomin button">+</button>');
  }

  if (settings.children().length > 0) {
    controls.append('<button class="logo_settings_switch button">Settings</button>');
    controls.append(settings);
  }

  form.append(controls);

  return form;
}

},{"jbone":67}],55:[function(require,module,exports){
module.exports = function Letter(letter, options) {
  options = options || {};
  this.value = letter;
  this.width = parseInt(options.width, 10) || 100;

  //W is 30% wider than the other letters, so need to make sure
  //it gets modified accordingly.
  if (this.value === 'W') {
    this.width += (this.width * 30) / 100;
  }

  this.height = parseInt(options.height, 10) || 100;

  this.color = options.color || '#000000';
  // if the height and width are changed from the default, then
  // this will also need to be changed as it cant be calculated
  // dynamically.
  this.fontSize = options.fontSize || 138;

  this.scaled = function () { };

  this.draw = function (ext_ctx, target_height, target_width, x, y, color) {
    var h_ratio = target_height / this.height,
    w_ratio = target_width / this.width,
    prev_font = ext_ctx.font;
    ext_ctx.transform(w_ratio, 0, 0, h_ratio, x, y);
    ext_ctx.fillStyle = color || this.color;
    ext_ctx.textAlign = "center";
    ext_ctx.font = "bold " + this.fontSize + "px Arial";

    ext_ctx.fillText(this.value, 0, 0);
    //restore the canvas settings
    ext_ctx.setTransform(1, 0, 0, 1, 0, 0);
    ext_ctx.fillStyle = '#000000';
    ext_ctx.font = prev_font;
  };

}

},{}],56:[function(require,module,exports){
module.exports = function draw_border(context, y, width) {
  context.beginPath();
  context.moveTo(0, y);
  context.lineTo(width, y);
  context.lineWidth = 1;
  context.strokeStyle = "#999999";
  context.stroke();
}

},{}],57:[function(require,module,exports){
module.exports = function draw_column_number(context, x, y, col_width, col_num, fontsize, right) {
  context.font = fontsize + "px Arial";
  context.textAlign = right ? "right" : "center";
  context.fillStyle = "#666666";
  context.fillText(col_num, x + (col_width / 2), y);
}

},{}],58:[function(require,module,exports){
module.exports = function draw_ticks(context, x, y, height, color) {
  color = color || '#999999';
  context.beginPath();
  context.moveTo(x, y);
  context.lineTo(x, y + height);
  context.lineWidth = 1;
  context.strokeStyle = color;
  context.stroke();
}

},{}],59:[function(require,module,exports){
var renderWithText = require("./render_with_text.js");
var renderWithRect = require("./render_with_rects.js");
var jbone = require("jbone");

// the main render function that draws the logo based on the provided options.
module.exports = function (options) {
  if (!this.data) {
    return;
  }
  options    = options || {};
  var zoom   = options.zoom || this.zoom,
  target = options.target || 1,
  scaled = options.scaled || null;
  var parent_width = this.dom_element.parent().attr('width'),
  max_canvas_width = 1,
  end = null,
  start = null,
  i = 0;

  /*
  if (target === this.previous_target) {
    return;
  }
  */

  this.previous_target = target;


  if (options.start) {
    this.start = options.start;
  }
  if (options.end) {
    this.end = options.end;
  }

  if (zoom <= 0.1) {
    zoom = 0.1;
  } else if (zoom >= 1) {
    zoom = 1;
  }

  this.zoom = zoom;

  end = this.end || this.data.heightArr.length;
  start = this.start || 1;
  end     = (end > this.data.heightArr.length) ? this.data.heightArr.length : end;
  end     = (end < start) ? start : end;

  start     = (start > end) ? end : start;
  start     = (start > 1) ? start : 1;

  this.y = this.height - 20;
  // Check to see if the logo will fit on the screen at full zoom.
  this.max_width = this.column_width * ((end - start) + 1);
  // If it fits then zoom out and disable zooming.
  if (parent_width > this.max_width) {
    zoom = 1;
    this.zoom_enabled = false;
  }
  this.zoom = zoom;

  this.zoomed_column = this.column_width * zoom;
  this.total_width = this.zoomed_column * ((end - start) + 1);

  // If zoom is not maxed and we still aren't filling the window
  // then ramp up the zoom level until it fits, then disable zooming.
  // Then we get a decent logo with out needing to zoom in or out.
  if (zoom < 1) {
    while (this.total_width < parent_width) {
      this.zoom += 0.1;
      this.zoomed_column = this.column_width * this.zoom;
      this.total_width = this.zoomed_column * ((end - start) + 1);
      this.zoom_enabled = false;
      if (zoom >= 1) {
        break;
      }
    }
  }

  if (target > this.total_width) {
    target = this.total_width;
  }
  this.dom_element.attr({'width': this.total_width + 'px'}).css({width: this.total_width + 'px'});

  this.canvas_width = this.total_width;
  var canvas_count = Math.ceil(this.total_width / this.canvas_width);
  this.columns_per_canvas = Math.ceil(this.canvas_width / this.zoomed_column);


  if (this.previous_zoom !== this.zoom) {
    this.dom_element.find('canvas').remove();
    this.previous_zoom = this.zoom;
    this.rendered = [];
  }

  this.canvases = [];
  this.contexts = [];


  for (i = 0; i < canvas_count; i++) {

    var split_start = (this.columns_per_canvas * i) + start,
    split_end   = split_start + this.columns_per_canvas - 1;
    if (split_end > end) {
      split_end = end;
    }

    var adjusted_width = ((split_end - split_start) + 1) * this.zoomed_column;

    if (adjusted_width > max_canvas_width) {
      max_canvas_width = adjusted_width;
    }

    var canv_start = max_canvas_width * i,
    canv_end = canv_start + adjusted_width;

    if (target < canv_end + (canv_end / 2) && target > canv_start - (canv_start / 2)) {
      // Check that we aren't redrawing the canvas and if not, then attach it and draw.
      //if (this.rendered[i] !== 1) {

        this.canvases[i] = attach_canvas(this.dom_element, this.height, adjusted_width, i, max_canvas_width);
        this.contexts[i] = this.canvases[i].getContext('2d');
        this.contexts[i].setTransform(1, 0, 0, 1, 0, 0);
        this.contexts[i].clearRect(0, 0, adjusted_width, this.height);
        this.contexts[i].fillStyle = "#ffffff";
        this.contexts[i].fillRect(0, 0, canv_end, this.height);


        if (this.zoomed_column > 12) {
          var fontsize = parseInt(10 * zoom, 10);
          fontsize = (fontsize > 10) ? 10 : fontsize;
          if (this.debug) {
            renderWithRect.call(this,split_start, split_end, i, 1);
          }
          renderWithText.call(this,split_start, split_end, i, fontsize);
        } else {
          renderWithRect.call(this,split_start, split_end, i);
        }
        //this.rendered[i] = 1;
      //}
    }

  }

  // check if the scroller object has been initialised and if not then do so.
  // we do this here as opposed to at object creation, because we need to
  // make sure the logo has been rendered and the width is correct, otherwise
  // we get a weird initial state where the canvas will bounce back to the
  // beginning the first time it is scrolled, because it thinks it has a
  // width of 0.
  if (!this.scrollme && this.options.scroller) {
    this.scrollme = new EasyScroller(this.dom_element[0], {
      scrollingX: 1,
      scrollingY: 0,
      eventTarget: this.called_on
    });
  }

  if (target !== 1) {
    this.scrollme.reflow();
  }
  return;
};


function attach_canvas(DOMid, height, width, id, canv_width) {
  var canvas = jbone(DOMid).find('#canv_' + id);

  if (!canvas.length) {
    jbone(DOMid).append('<canvas class="canvas_logo" id="canv_' + id + '"  height="' + height + '" width="' + width + '" style="left:' + canv_width * id + 'px"></canvas>');
    canvas = jbone(DOMid).find('#canv_' + id);
  }

  jbone(canvas).attr('width', width).attr('height', height);

  return canvas[0];
}

},{"./render_with_rects.js":60,"./render_with_text.js":61,"jbone":67}],60:[function(require,module,exports){
var draw_border = require("./draw/border.js");
var draw_ticks = require("./draw/ticks.js");
var draw_column_number = require("./draw/column_number.js");

module.exports = function (start, end, context_num, borders) {
  var x = 0,
  column_num = start,
  column_label = null,
  i = 0,
  top_height = Math.abs(this.data.max_height),
  bottom_height = Math.abs(this.data.min_height_obs),
  total_height = top_height + bottom_height,
  top_percentage    = Math.round((Math.abs(this.data.max_height) * 100) / total_height),
  //convert % to pixels
  top_pix_height = Math.round((this.info_content_height * top_percentage) / 100),
  bottom_pix_height = this.info_content_height - top_pix_height,
  mod = 10;


  for (i = start; i <= end; i++) {
    if (this.data.mmline && this.data.mmline[i - 1] === 1) {
      this.contexts[context_num].fillStyle = '#cccccc';
      this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
    } else {
      var column = this.data.heightArr[i - 1],
      previous_height = 0,
      previous_neg_height = top_pix_height,
      letters = column.length,
      j = 0;
      for(var j in column){
        values = [j,column[j]];
        if (values[1] > 0.01) {
          var letter_height = parseFloat(values[1]) / this.data.max_height,
          x_pos = x,
          glyph_height = (this.info_content_height - 2) * letter_height,
          y_pos = (this.info_content_height - 2) - previous_height - glyph_height,
          color = null;


          if(this.colorscheme === 'dynamic'){
            color = this.colors.getColor(values[0], {pos: i - 1} )
          }else{
            if(this.colorscheme === 'consensus') {
              color = this.cmap[i - 1][values[0]] || "#7a7a7a";
            } else {
              color = this.colors[values[0]];
            }
          }

          if (borders) {
            this.contexts[context_num].strokeStyle = color;
            this.contexts[context_num].strokeRect(x_pos, y_pos, this.zoomed_column, glyph_height);
          } else {
            this.contexts[context_num].fillStyle = color;
            this.contexts[context_num].fillRect(x_pos, y_pos, this.zoomed_column, glyph_height);
          }

          previous_height = previous_height + glyph_height;
        }
      }
    }


    if (this.zoom < 0.2) {
      mod = 20;
    } else if (this.zoom < 0.3) {
      mod = 10;
    }

    if(this.options.positionMarker){
      if (i % mod === 0) {
        // draw column dividers
        if(this.options.show_probs){
          draw_ticks(this.contexts[context_num], x + this.zoomed_column, this.height - 30, parseFloat(this.height), '#dddddd');
        }
        // draw top ticks
        draw_ticks(this.contexts[context_num], x + this.zoomed_column, 0, 5);

        // if ali_coordinates exist and toggle is set then display the
        // alignment coordinates and not the model coordinates.
        if (this.display_ali_map) {
          column_label = this.data.ali_map[i - 1];
        } else {
          column_label = column_num;
        }
        // draw column numbers
        draw_column_number(this.contexts[context_num], x - 2,  10, this.zoomed_column, column_label, 10, true);
      }

    }


    // draw insert probabilities/lengths
    if(this.options.show_probs){
      draw_small_insert(
        this.contexts[context_num],
        x,
        this.height - 42,
        this.zoomed_column,
        this.data.insert_probs[i - 1],
        this.data.insert_lengths[i - 1],
        this.data.delete_probs[i - 1],
        this.show_inserts
      );
    }

    if(this.options.show_probs){
      // draw other dividers
      if (this.show_inserts) {
        draw_border(this.contexts[context_num], this.height - 45, this.total_width);
      } else {
        draw_border(this.contexts[context_num], this.height - 15, this.total_width);
      }
    }

    if(this.options.border){
      draw_border(this.contexts[context_num], 0, this.total_width);
    }

    x += this.zoomed_column;
    column_num++;
  }

};


function draw_small_insert(context, x, y, col_width, in_odds, in_length, del_odds, show_inserts) {
  var fill = "#ffffff";
  if (show_inserts) {
    if (in_odds > 0.1) {
      fill = '#d7301f';
    } else if (in_odds > 0.05) {
      fill = '#fc8d59';
    } else if (in_odds > 0.03) {
      fill = '#fdcc8a';
    }
    context.fillStyle = fill;
    context.fillRect(x, y + 15, col_width, 10);

    fill = "#ffffff";
    // draw insert length
    if (in_length > 9) {
      fill = '#d7301f';
    } else if (in_length > 7) {
      fill = '#fc8d59';
    } else if (in_length > 4) {
      fill = '#fdcc8a';
    }
    context.fillStyle = fill;
    context.fillRect(x, y + 30, col_width, 10);
  } else {
    y  = y + 30;
  }

  fill = "#ffffff";
  // draw delete odds
  if (del_odds < 0.75) {
    fill = '#2171b5';
  } else if (del_odds < 0.85) {
    fill = '#6baed6';
  } else if (del_odds < 0.95) {
    fill = '#bdd7e7';
  }
  context.fillStyle = fill;
  context.fillRect(x, y, col_width, 10);
}



},{"./draw/border.js":56,"./draw/column_number.js":57,"./draw/ticks.js":58}],61:[function(require,module,exports){
var draw_border = require("./draw/border.js");
var draw_ticks = require("./draw/ticks.js");
var draw_column_number = require("./draw/column_number.js");

module.exports = function (start, end, context_num, fontsize) {
  var x = 0,
  column_num = start,
  column_label = null,
  i = 0,
  top_height = Math.abs(this.data.max_height),
  bottom_height = (isNaN(this.data.min_height_obs)) ? 0 : parseInt(this.data.min_height_obs, 10),
  total_height = top_height + Math.abs(bottom_height),
  top_percentage    = Math.round((Math.abs(this.data.max_height) * 100) / total_height),
  //convert % to pixels
  top_pix_height = Math.round((this.info_content_height * top_percentage) / 100),
  bottom_pix_height = this.info_content_height - top_pix_height,
  // this is used to transform the 256px high letters into the correct size
  // when displaying negative values, so that they fit above the 0 line.
  top_pix_conversion = top_pix_height / this.info_content_height,
  bottom_pix_conversion = bottom_pix_height / this.info_content_height;

  // add 3 extra columns so that numbers don't get clipped at the end of a canvas
  // that ends before a large column. DF0000830 was suffering at zoom level 0.6,
  // column 2215. This adds a little extra overhead, but is the easiest fix for now.
  if (end + 3 <= this.end) {
    end += 3;
  }

  for (i = start; i <= end; i++) {
    if (this.data.mmline && this.data.mmline[i - 1] === 1) {
      this.contexts[context_num].fillStyle = '#cccccc';
      this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
    } else {
      var column = this.data.heightArr[i - 1],
      col_positions = [];
      if (column) {
        var previous_height = 0,
        letters = column.length,
        previous_neg_height = top_pix_height,
        j = 0,
        color = null;

        for(var j in column){
          var letter = column[j],
          values = [j,letter];
          x_pos = x + (this.zoomed_column / 2),
          letter_height = null;

          // we don't render anything with a value between 0 and 0.01. These
          // letters would be too small to be meaningful on any scale, so we
          // just squash them out.
          if (values[1] > 0.01) {
            letter_height = parseFloat(values[1]) / this.data.max_height;
            var y_pos = (this.info_content_height - 2) - previous_height,
            glyph_height = (this.info_content_height - 2) * letter_height;

            col_positions[j] = [glyph_height, this.zoomed_column, x_pos, y_pos];
            previous_height = previous_height + glyph_height;
          }
        }

        // render the letters in reverse order so that the larger letters on the top
        // don't clobber the smaller letters below them.
        //for (j = letters; j >= 0; j--) {
        for(var j in column){
          if (col_positions[j] && this.letters[j]) {

            if(this.colorscheme === 'dynamic'){
              color = this.colors.getColor(j, {pos: i - 1} );
            }else{
              if (this.colorscheme === 'consensus') {
                color = this.cmap[i - 1][j] || "#7a7a7a";
              } else {
                color = null;
              }
            }
            this.letters[j].draw(this.contexts[context_num], col_positions[j][0], col_positions[j][1], col_positions[j][2], col_positions[j][3], color);
          }
        }
      }
    }


    // if ali_coordinates exist and toggle is set then display the
    // alignment coordinates and not the model coordinates.
    if (this.display_ali_map) {
      column_label = this.data.ali_map[i - 1];
    } else {
      column_label = column_num;
    }

    if(this.options.show_divider){
      if (this.zoom < 0.7) {
        if (i % this.options.divider_step === 0) {
          draw_column_divider(this,{
            context_num : context_num,
            x : x,
            fontsize: 10,
            column_num: column_label,
            ralign: true
          });
        }
      } else {
        draw_column_divider(this,{
          context_num : context_num,
          x : x,
          fontsize: fontsize,
          column_num: column_label
        });
      }
    }

    if(this.options.show_probs){
      draw_delete_odds(this.contexts[context_num], x, this.height, this.zoomed_column, this.data.delete_probs[i - 1], fontsize, this.show_inserts);
      //draw insert length ticks
      draw_ticks(this.contexts[context_num], x, this.height - 15, 5);
      if (this.show_inserts) {
        draw_insert_odds(this.contexts[context_num], x, this.height, this.zoomed_column, this.data.insert_probs[i - 1], fontsize);
        draw_insert_length(this.contexts[context_num], x, this.height - 5, this.zoomed_column, this.data.insert_lengths[i - 1], fontsize);

        // draw delete probability ticks
        draw_ticks(this.contexts[context_num], x, this.height - 45, 5);
        // draw insert probability ticks
        draw_ticks(this.contexts[context_num], x, this.height - 30, 5);
      }

    }

    x += this.zoomed_column;
    column_num++;
  }


  if(this.options.show_probs){
    // draw other dividers
    if (this.show_inserts) {
      draw_border(this.contexts[context_num], this.height - 30, this.total_width);
      draw_border(this.contexts[context_num], this.height - 45, this.total_width);
    }
    draw_border(this.contexts[context_num], this.height - 15, this.total_width);
  }
  if(this.options.border){
    draw_border(this.contexts[context_num], 0, this.total_width);
  }
};


function draw_delete_odds(context, x, height, col_width, text, fontsize, show_inserts) {
  var y        = height - 4,
  fill     = '#ffffff',
  textfill = '#555555';

  if (show_inserts) {
    y = height - 35;
  }

  if (text < 0.75) {
    fill     = '#2171b5';
    textfill = '#ffffff';
  } else if (text < 0.85) {
    fill = '#6baed6';
  } else if (text < 0.95) {
    fill = '#bdd7e7';
  }

  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);
}

function draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill) {
  context.font = fontsize + "px Arial";
  context.fillStyle = fill;
  context.fillRect(x, y - 10, col_width, 14);
  context.textAlign = "center";
  context.fillStyle = textfill;
  context.fillText(text, x + (col_width / 2), y);
}

function draw_column_divider(inst, opts) {
  var div_x = opts.ralign ? opts.x + inst.zoomed_column : opts.x,
  num_x = opts.ralign ? opts.x + 2 : opts.x;
  // draw column dividers
  draw_ticks(inst.contexts[opts.context_num], div_x, inst.height - 30, -30 - inst.height, '#dddddd');
  // draw top ticks
  draw_ticks(inst.contexts[opts.context_num], div_x, 0, 5);
  // draw column numbers
  draw_column_number(inst.contexts[opts.context_num], num_x, 10, inst.zoomed_column, opts.column_num, opts.fontsize, opts.ralign);
};



function draw_insert_odds(context, x, height, col_width, text, fontsize) {
  var y        = height - 20,
  fill     = '#ffffff',
  textfill = '#555555';

  if (text > 0.1) {
    fill     = '#d7301f';
    textfill = '#ffffff';
  } else if (text > 0.05) {
    fill = '#fc8d59';
  } else if (text > 0.03) {
    fill = '#fdcc8a';
  }

  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);

  //draw vertical line to indicate where the insert would occur
  if (text > 0.03) {
    draw_ticks(context, x + col_width, height - 30, -30 - height, fill);
  }
}
function draw_insert_length(context, x, y, col_width, text, fontsize) {
  var fill = '#ffffff',
  textfill = '#555555';

  if (text > 9) {
    fill     = '#d7301f';
    textfill = '#ffffff';
  } else if (text > 7) {
    fill = '#fc8d59';
  } else if (text > 4) {
    fill = '#fdcc8a';
  }
  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);
}

},{"./draw/border.js":56,"./draw/column_number.js":57,"./draw/ticks.js":58}],62:[function(require,module,exports){
/*
 * JavaScript Canvas to Blob 2.0.5
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */
var CanvasPrototype = window.HTMLCanvasElement &&
window.HTMLCanvasElement.prototype,
  hasBlobConstructor = window.Blob && (function () {
    try {
      return Boolean(new Blob());
    } catch (e) {
      return false;
    }
  }()),
  hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array &&
  (function () {
    try {
      return new Blob([new Uint8Array(100)]).size === 100;
    } catch (e) {
      return false;
    }
  }()),
  BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder ||
  window.MozBlobBuilder || window.MSBlobBuilder,
  dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob &&
  window.ArrayBuffer && window.Uint8Array && function (dataURI) {
    var byteString,
    arrayBuffer,
    intArray,
      i,
      mimeString,
        bb;
    if (dataURI.split(',')[0].indexOf('base64') >= 0) {
      // Convert base64 to raw binary data held in a string:
      byteString = atob(dataURI.split(',')[1]);
    } else {
      // Convert base64/URLEncoded data component to raw binary data:
      byteString = decodeURIComponent(dataURI.split(',')[1]);
    }
    // Write the bytes of the string to an ArrayBuffer:
    arrayBuffer = new ArrayBuffer(byteString.length);
    intArray = new Uint8Array(arrayBuffer);
    for (i = 0; i < byteString.length; i += 1) {
      intArray[i] = byteString.charCodeAt(i);
    }
    // Separate out the mime component:
    mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    // Write the ArrayBuffer (or ArrayBufferView) to a blob:
    if (hasBlobConstructor) {
      return new Blob(
          [hasArrayBufferViewSupport ? intArray : arrayBuffer],
          {type: mimeString}
          );
    }
    bb = new BlobBuilder();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeString);
  };
if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
  if (CanvasPrototype.mozGetAsFile) {
    CanvasPrototype.toBlob = function (callback, type, quality) {
      if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
        callback(dataURLtoBlob(this.toDataURL(type, quality)));
      } else {
        callback(this.mozGetAsFile('blob', type));
      }
    };
  } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
    CanvasPrototype.toBlob = function (callback, type, quality) {
      callback(dataURLtoBlob(this.toDataURL(type, quality)));
    };
  }
}

module.exports = dataURLtoBlob;

},{}],63:[function(require,module,exports){
/* FileSaver.js
 *  A saveAs() FileSaver implementation.
 *  2014-05-27
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
  "use strict";
  // IE <10 is explicitly unsupported
  if (typeof navigator !== "undefined" &&
      /MSIE [1-9]\./.test(navigator.userAgent)) {
    return;
  }
  var
      doc = view.document
      // only get URL when necessary in case Blob.js hasn't overridden it yet
    , get_URL = function() {
      return view.URL || view.webkitURL || view;
    }
    , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
    , can_use_save_link = !view.externalHost && "download" in save_link
    , click = function(node) {
      var event = doc.createEvent("MouseEvents");
      event.initMouseEvent(
        "click", true, false, view, 0, 0, 0, 0, 0
        , false, false, false, false, 0, null
      );
      node.dispatchEvent(event);
    }
    , webkit_req_fs = view.webkitRequestFileSystem
    , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
    , throw_outside = function(ex) {
      (view.setImmediate || view.setTimeout)(function() {
        throw ex;
      }, 0);
    }
    , force_saveable_type = "application/octet-stream"
    , fs_min_size = 0
    , deletion_queue = []
    , process_deletion_queue = function() {
      var i = deletion_queue.length;
      while (i--) {
        var file = deletion_queue[i];
        if (typeof file === "string") { // file is an object URL
          get_URL().revokeObjectURL(file);
        } else { // file is a File
          file.remove();
        }
      }
      deletion_queue.length = 0; // clear queue
    }
    , dispatch = function(filesaver, event_types, event) {
      event_types = [].concat(event_types);
      var i = event_types.length;
      while (i--) {
        var listener = filesaver["on" + event_types[i]];
        if (typeof listener === "function") {
          try {
            listener.call(filesaver, event || filesaver);
          } catch (ex) {
            throw_outside(ex);
          }
        }
      }
    }
    , FileSaver = function(blob, name) {
      // First try a.download, then web filesystem, then object URLs
      var
          filesaver = this
        , type = blob.type
        , blob_changed = false
        , object_url
        , target_view
        , get_object_url = function() {
          var object_url = get_URL().createObjectURL(blob);
          deletion_queue.push(object_url);
          return object_url;
        }
        , dispatch_all = function() {
          dispatch(filesaver, "writestart progress write writeend".split(" "));
        }
        // on any filesys errors revert to saving with object URLs
        , fs_error = function() {
          // don't create more object URLs than needed
          if (blob_changed || !object_url) {
            object_url = get_object_url(blob);
          }
          if (target_view) {
            target_view.location.href = object_url;
          } else {
            window.open(object_url, "_blank");
          }
          filesaver.readyState = filesaver.DONE;
          dispatch_all();
        }
        , abortable = function(func) {
          return function() {
            if (filesaver.readyState !== filesaver.DONE) {
              return func.apply(this, arguments);
            }
          };
        }
        , create_if_not_found = {create: true, exclusive: false}
        , slice
      ;
      filesaver.readyState = filesaver.INIT;
      if (!name) {
        name = "download";
      }
      if (can_use_save_link) {
        object_url = get_object_url(blob);
        save_link.href = object_url;
        save_link.download = name;
        click(save_link);
        filesaver.readyState = filesaver.DONE;
        dispatch_all();
        return;
      }
      // Object and web filesystem URLs have a problem saving in Google Chrome when
      // viewed in a tab, so I force save with application/octet-stream
      // http://code.google.com/p/chromium/issues/detail?id=91158
      if (view.chrome && type && type !== force_saveable_type) {
        slice = blob.slice || blob.webkitSlice;
        blob = slice.call(blob, 0, blob.size, force_saveable_type);
        blob_changed = true;
      }
      // Since I can't be sure that the guessed media type will trigger a download
      // in WebKit, I append .download to the filename.
      // https://bugs.webkit.org/show_bug.cgi?id=65440
      if (webkit_req_fs && name !== "download") {
        name += ".download";
      }
      if (type === force_saveable_type || webkit_req_fs) {
        target_view = view;
      }
      if (!req_fs) {
        fs_error();
        return;
      }
      fs_min_size += blob.size;
      req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
        fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
          var save = function() {
            dir.getFile(name, create_if_not_found, abortable(function(file) {
              file.createWriter(abortable(function(writer) {
                writer.onwriteend = function(event) {
                  target_view.location.href = file.toURL();
                  deletion_queue.push(file);
                  filesaver.readyState = filesaver.DONE;
                  dispatch(filesaver, "writeend", event);
                };
                writer.onerror = function() {
                  var error = writer.error;
                  if (error.code !== error.ABORT_ERR) {
                    fs_error();
                  }
                };
                "writestart progress write abort".split(" ").forEach(function(event) {
                  writer["on" + event] = filesaver["on" + event];
                });
                writer.write(blob);
                filesaver.abort = function() {
                  writer.abort();
                  filesaver.readyState = filesaver.DONE;
                };
                filesaver.readyState = filesaver.WRITING;
              }), fs_error);
            }), fs_error);
          };
          dir.getFile(name, {create: false}, abortable(function(file) {
            // delete file if it already exists
            file.remove();
            save();
          }), abortable(function(ex) {
            if (ex.code === ex.NOT_FOUND_ERR) {
              save();
            } else {
              fs_error();
            }
          }));
        }), fs_error);
      }), fs_error);
    }
    , FS_proto = FileSaver.prototype
    , saveAs = function(blob, name) {
      return new FileSaver(blob, name);
    }
  ;
  FS_proto.abort = function() {
    var filesaver = this;
    filesaver.readyState = filesaver.DONE;
    dispatch(filesaver, "abort");
  };
  FS_proto.readyState = FS_proto.INIT = 0;
  FS_proto.WRITING = 1;
  FS_proto.DONE = 2;

  FS_proto.error =
  FS_proto.onwritestart =
  FS_proto.onprogress =
  FS_proto.onwrite =
  FS_proto.onabort =
  FS_proto.onerror =
  FS_proto.onwriteend =
    null;

  view.addEventListener("unload", process_deletion_queue, false);
  saveAs.unload = function() {
    process_deletion_queue();
    view.removeEventListener("unload", process_deletion_queue, false);
  };
  return saveAs;
}(
     typeof self !== "undefined" && self
  || typeof window !== "undefined" && window
  || this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

amdDefine = window.define;
if( typeof amdDefine === "undefined" && (typeof window.almond !== "undefined" 
    && "define" in window.almond )){
  amdDefine = window.almond.define;
}

if (typeof module !== "undefined" && module !== null) {
  module.exports = saveAs;
} else if ((typeof amdDefine !== "undefined" && amdDefine !== null) && (amdDefine.amd != null)) {
  amdDefine("saveAs",[], function() {
    return saveAs;
  });
}

},{}],64:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],65:[function(require,module,exports){
module.exports = function (css, customDocument) {
  var doc = customDocument || document;
  if (doc.createStyleSheet) {
    var sheet = doc.createStyleSheet()
    sheet.cssText = css;
    return sheet.ownerNode;
  } else {
    var head = doc.getElementsByTagName('head')[0],
        style = doc.createElement('style');

    style.type = 'text/css';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(doc.createTextNode(css));
    }

    head.appendChild(style);
    return style;
  }
};

module.exports.byUrl = function(url) {
  if (document.createStyleSheet) {
    return document.createStyleSheet(url).ownerNode;
  } else {
    var head = document.getElementsByTagName('head')[0],
        link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = url;

    head.appendChild(link);
    return link;
  }
};

},{}],66:[function(require,module,exports){
var Utils = {};


/*
Remove an element and provide a function that inserts it into its original position
https://developers.google.com/speed/articles/javascript-dom
@param element {Element} The element to be temporarily removed
@return {Function} A function that inserts the element into its original position
 */

Utils.removeToInsertLater = function(element) {
  var nextSibling, parentNode;
  parentNode = element.parentNode;
  nextSibling = element.nextSibling;
  parentNode.removeChild(element);
  return function() {
    if (nextSibling) {
      parentNode.insertBefore(element, nextSibling);
    } else {
      parentNode.appendChild(element);
    }
  };
};


/*
fastest possible way to destroy all sub nodes (aka childs)
http://jsperf.com/innerhtml-vs-removechild/15
@param element {Element} The element for which all childs should be removed
 */

Utils.removeAllChilds = function(element) {
  var count;
  count = 0;
  while (element.firstChild) {
    count++;
    element.removeChild(element.firstChild);
  }
};

module.exports = Utils;

},{}],67:[function(require,module,exports){
/*!
 * jBone v1.0.24 - 2015-03-30 - Library for DOM manipulation
 *
 * https://github.com/kupriyanenko/jbone
 *
 * Copyright 2015 Alexey Kupriyanenko
 * Released under the MIT license.
 */

(function (win) {

var
// cache previous versions
_$ = win.$,
_jBone = win.jBone,

// Quick match a standalone tag
rquickSingleTag = /^<(\w+)\s*\/?>$/,

// A simple way to check for HTML strings
// Prioritize #id over <tag> to avoid XSS via location.hash
rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

// Alias for function
slice = [].slice,
splice = [].splice,
keys = Object.keys,

// Alias for global variables
doc = document,

isString = function(el) {
    return typeof el === "string";
},
isObject = function(el) {
    return el instanceof Object;
},
isFunction = function(el) {
    return ({}).toString.call(el) === "[object Function]";
},
isArray = function(el) {
    return Array.isArray(el);
},
jBone = function(element, data) {
    return new fn.init(element, data);
},
fn;

// set previous values and return the instance upon calling the no-conflict mode
jBone.noConflict = function() {
    win.$ = _$;
    win.jBone = _jBone;

    return jBone;
};

fn = jBone.fn = jBone.prototype = {
    init: function(element, data) {
        var elements, tag, wraper, fragment;

        if (!element) {
            return this;
        }
        if (isString(element)) {
            // Create single DOM element
            if (tag = rquickSingleTag.exec(element)) {
                this[0] = doc.createElement(tag[1]);
                this.length = 1;

                if (isObject(data)) {
                    this.attr(data);
                }

                return this;
            }
            // Create DOM collection
            if ((tag = rquickExpr.exec(element)) && tag[1]) {
                fragment = doc.createDocumentFragment();
                wraper = doc.createElement("div");
                wraper.innerHTML = element;
                while (wraper.lastChild) {
                    fragment.appendChild(wraper.firstChild);
                }
                elements = slice.call(fragment.childNodes);

                return jBone.merge(this, elements);
            }
            // Find DOM elements with querySelectorAll
            if (jBone.isElement(data)) {
                return jBone(data).find(element);
            }

            try {
                elements = doc.querySelectorAll(element);

                return jBone.merge(this, elements);
            } catch (e) {
                return this;
            }
        }
        // Wrap DOMElement
        if (element.nodeType) {
            this[0] = element;
            this.length = 1;

            return this;
        }
        // Run function
        if (isFunction(element)) {
            return element();
        }
        // Return jBone element as is
        if (element instanceof jBone) {
            return element;
        }

        // Return element wrapped by jBone
        return jBone.makeArray(element, this);
    },

    pop: [].pop,
    push: [].push,
    reverse: [].reverse,
    shift: [].shift,
    sort: [].sort,
    splice: [].splice,
    slice: [].slice,
    indexOf: [].indexOf,
    forEach: [].forEach,
    unshift: [].unshift,
    concat: [].concat,
    join: [].join,
    every: [].every,
    some: [].some,
    filter: [].filter,
    map: [].map,
    reduce: [].reduce,
    reduceRight: [].reduceRight,
    length: 0
};

fn.constructor = jBone;

fn.init.prototype = fn;

jBone.setId = function(el) {
    var jid = el.jid;

    if (el === win) {
        jid = "window";
    } else if (el.jid === undefined) {
        el.jid = jid = ++jBone._cache.jid;
    }

    if (!jBone._cache.events[jid]) {
        jBone._cache.events[jid] = {};
    }
};

jBone.getData = function(el) {
    el = el instanceof jBone ? el[0] : el;

    var jid = el === win ? "window" : el.jid;

    return {
        jid: jid,
        events: jBone._cache.events[jid]
    };
};

jBone.isElement = function(el) {
    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);
};

jBone._cache = {
    events: {},
    jid: 0
};

function isArraylike(obj) {
    var length = obj.length,
        type = typeof obj;

    if (isFunction(type) || obj === win) {
        return false;
    }

    if (obj.nodeType === 1 && length) {
        return true;
    }

    return isArray(type) || length === 0 ||
        typeof length === "number" && length > 0 && (length - 1) in obj;
}

fn.pushStack = function(elems) {
    var ret = jBone.merge(this.constructor(), elems);

    return ret;
};

jBone.merge = function(first, second) {
    var l = second.length,
        i = first.length,
        j = 0;

    while (j < l) {
        first[i++] = second[j++];
    }

    first.length = i;

    return first;
};

jBone.contains = function(container, contained) {
    var result;

    container.reverse().some(function(el) {
        if (el.contains(contained)) {
            return result = el;
        }
    });

    return result;
};

jBone.extend = function(target) {
    var tg;

    splice.call(arguments, 1).forEach(function(source) {
        tg = target; //caching target for perf improvement

        if (source) {
            for (var prop in source) {
                tg[prop] = source[prop];
            }
        }
    });

    return target;
};

jBone.makeArray = function(arr, results) {
    var ret = results || [];

    if (arr !== null) {
        if (isArraylike(arr)) {
            jBone.merge(ret, isString(arr) ? [arr] : arr);
        } else {
            ret.push(arr);
        }
    }

    return ret;
};

jBone.unique = function(array) {
    if (array == null) {
        return [];
    }

    var result = [];

    for (var i = 0, length = array.length; i < length; i++) {
        var value = array[i];
        if (result.indexOf(value) < 0) {
            result.push(value);
        }
    }
    return result;
};

function BoneEvent(e, data) {
    var key, setter;

    this.originalEvent = e;

    setter = function(key, e) {
        if (key === "preventDefault") {
            this[key] = function() {
                this.defaultPrevented = true;
                return e[key]();
            };
        } else if (key === "stopImmediatePropagation") {
            this[key] = function() {
                this.immediatePropagationStopped = true;
                return e[key]();
            };
        } else if (isFunction(e[key])) {
            this[key] = function() {
                return e[key]();
            };
        } else {
            this[key] = e[key];
        }
    };

    for (key in e) {
        if (e[key] || typeof e[key] === "function") {
            setter.call(this, key, e);
        }
    }

    jBone.extend(this, data, {
        isImmediatePropagationStopped: function() {
            return !!this.immediatePropagationStopped;
        }
    });
}

jBone.Event = function(event, data) {
    var namespace, eventType;

    if (event.type && !data) {
        data = event;
        event = event.type;
    }

    namespace = event.split(".").splice(1).join(".");
    eventType = event.split(".")[0];

    event = doc.createEvent("Event");
    event.initEvent(eventType, true, true);

    return jBone.extend(event, {
        namespace: namespace,
        isDefaultPrevented: function() {
            return event.defaultPrevented;
        }
    }, data);
};

jBone.event = {
    add: function(el, types, handler, data, selector) {
        var eventHandler = function() {
                jBone.event.dispatch.apply(el, arguments);
            },
            events, eventType, t, event;

        jBone.setId(el);
        events = jBone.getData(el).events;

        types = types.split(" ");
        t = types.length;
        while (t--) {
            event = types[t];

            eventType = event.split(".")[0];
            events[eventType] = events[eventType] || [];

            if (!events[eventType].length) {
                el.addEventListener && el.addEventListener(eventType, eventHandler, false);
            }

            events[eventType].push({
                namespace: event.split(".").splice(1).join("."),
                fn: eventHandler,
                selector: selector,
                data: data,
                originfn: handler
            });
        }
    },

    dispatch: function(e) {
        var i = 0,
            el = this,
            handlerQueue = jBone.getData(el).events[e.type],
            length = handlerQueue.length,
            expectedTarget,
            handler,
            event,
            eventOptions;

        for (; i < length; i++) {
            eventOptions = {};
            handler = handlerQueue[i];
            handler.data && (eventOptions.data = handler.data);

            if (event && event.isImmediatePropagationStopped()) {
                return;
            }

            if (!handler.selector) {
                event = new BoneEvent(e, eventOptions);

                if (!(e.namespace && e.namespace !== handler.namespace)) {
                    handler.originfn.call(el, event);
                }
            } else if (~jBone(el).find(handler.selector).indexOf(e.target) || (expectedTarget = jBone.contains(jBone(el).find(handler.selector), e.target))) {
                expectedTarget = expectedTarget || e.target;
                eventOptions.currentTarget = expectedTarget;
                event = new BoneEvent(e, eventOptions);

                if (!(e.namespace && e.namespace !== handler.namespace)) {
                    handler.originfn.call(expectedTarget, event);
                }
            }
        }
    }
};

fn.on = function(types) {
    var args = arguments,
        length = this.length,
        i = 0,
        handler = slice.call(args, -1)[0],
        selector, data;

    // .on('click', '.selector', function() {})
    if (args.length === 3 && isString(args[1])) {
        selector = args[1];
    }
    // .on('click', { key: value }, function() {})
    else if (args.length === 3 && isObject(args[1])) {
        data = args[1];
    }
    // .on('click', '.selector', { key: value }, function() {})
    else if (args.length === 4) {
        selector = args[1];
        data = args[2];
    }

    for (; i < length; i++) {
        jBone.event.add(this[i], types, handler, data, selector);
    }

    return this;
};

fn.one = function(event) {
    var args = arguments,
        i = 0,
        length = this.length,
        oneArgs = slice.call(args, 1, args.length - 1),
        callback = slice.call(args, -1)[0],
        addListener;

    addListener = function(el) {
        var $el =  jBone(el);

        event.split(" ").forEach(function(event) {
            var fn = function(e) {
                $el.off(event, fn);
                callback.call(el, e);
            };

            $el.on.apply($el, [event].concat(oneArgs, fn));
        });
    };

    for (; i < length; i++) {
        addListener(this[i]);
    }

    return this;
};

fn.trigger = function(event) {
    var events = [],
        i = 0,
        length = this.length,
        dispatchEvents;

    if (!event) {
        return this;
    }

    if (isString(event)) {
        events = event.split(" ").map(function(event) {
            return jBone.Event(event);
        });
    } else {
        event = event instanceof Event ? event : jBone.Event(event);
        events = [event];
    }

    dispatchEvents = function(el) {
        events.forEach(function(event) {
            if (!event.type) {
                return;
            }

            el.dispatchEvent && el.dispatchEvent(event);
        });
    };

    for (; i < length; i++) {
        dispatchEvents(this[i]);
    }

    return this;
};

fn.off = function(event, fn) {
    var i = 0,
        length = this.length,
        removeListener = function(events, eventType, index, el, e) {
            var callback;

            // get callback
            if ((fn && e.originfn === fn) || !fn) {
                callback = e.fn;
            }

            if (events[eventType][index].fn === callback) {
                el.removeEventListener(eventType, callback);

                // remove handler from cache
                jBone._cache.events[jBone.getData(el).jid][eventType].splice(index, 1);
            }
        },
        events, namespace, removeListeners, eventType;

    removeListeners = function(el) {
        var l, eventsByType, e;

        events = jBone.getData(el).events;

        if (!events) {
            return;
        }

        // remove all events
        if (!event && events) {
            return keys(events).forEach(function(eventType) {
                eventsByType = events[eventType];
                l = eventsByType.length;

                while(l--) {
                    removeListener(events, eventType, l, el, eventsByType[l]);
                }
            });
        }

        event.split(" ").forEach(function(event) {
            eventType = event.split(".")[0];
            namespace = event.split(".").splice(1).join(".");

            // remove named events
            if (events[eventType]) {
                eventsByType = events[eventType];
                l = eventsByType.length;

                while(l--) {
                    e = eventsByType[l];
                    if (!namespace || (namespace && e.namespace === namespace)) {
                        removeListener(events, eventType, l, el, e);
                    }
                }
            }
            // remove all namespaced events
            else if (namespace) {
                keys(events).forEach(function(eventType) {
                    eventsByType = events[eventType];
                    l = eventsByType.length;

                    while(l--) {
                        e = eventsByType[l];
                        if (e.namespace.split(".")[0] === namespace.split(".")[0]) {
                            removeListener(events, eventType, l, el, e);
                        }
                    }
                });
            }
        });
    };

    for (; i < length; i++) {
        removeListeners(this[i]);
    }

    return this;
};

fn.find = function(selector) {
    var results = [],
        i = 0,
        length = this.length,
        finder = function(el) {
            if (isFunction(el.querySelectorAll)) {
                [].forEach.call(el.querySelectorAll(selector), function(found) {
                    results.push(found);
                });
            }
        };

    for (; i < length; i++) {
        finder(this[i]);
    }

    return jBone(results);
};

fn.get = function(index) {
    return index != null ?

        // Return just the one element from the set
        (index < 0 ? this[index + this.length] : this[index]) :

        // Return all the elements in a clean array
        slice.call(this);
};

fn.eq = function(index) {
    return jBone(this[index]);
};

fn.parent = function() {
    var results = [],
        parent,
        i = 0,
        length = this.length;

    for (; i < length; i++) {
        if (!~results.indexOf(parent = this[i].parentElement) && parent) {
            results.push(parent);
        }
    }

    return jBone(results);
};

fn.toArray = function() {
    return slice.call(this);
};

fn.is = function() {
    var args = arguments;

    return this.some(function(el) {
        return el.tagName.toLowerCase() === args[0];
    });
};

fn.has = function() {
    var args = arguments;

    return this.some(function(el) {
        return el.querySelectorAll(args[0]).length;
    });
};

fn.add = function(selector, context) {
    return this.pushStack(
        jBone.unique(
            jBone.merge(this.get(), jBone(selector, context))
        )
    );
};

fn.attr = function(key, value) {
    var args = arguments,
        i = 0,
        length = this.length,
        setter;

    if (isString(key) && args.length === 1) {
        return this[0] && this[0].getAttribute(key);
    }

    if (args.length === 2) {
        setter = function(el) {
            el.setAttribute(key, value);
        };
    } else if (isObject(key)) {
        setter = function(el) {
            keys(key).forEach(function(name) {
                el.setAttribute(name, key[name]);
            });
        };
    }

    for (; i < length; i++) {
        setter(this[i]);
    }

    return this;
};

fn.removeAttr = function(key) {
    var i = 0,
        length = this.length;

    for (; i < length; i++) {
        this[i].removeAttribute(key);
    }

    return this;
};

fn.val = function(value) {
    var i = 0,
        length = this.length;

    if (arguments.length === 0) {
        return this[0] && this[0].value;
    }

    for (; i < length; i++) {
        this[i].value = value;
    }

    return this;
};

fn.css = function(key, value) {
    var args = arguments,
        i = 0,
        length = this.length,
        setter;

    // Get attribute
    if (isString(key) && args.length === 1) {
        return this[0] && win.getComputedStyle(this[0])[key];
    }

    // Set attributes
    if (args.length === 2) {
        setter = function(el) {
            el.style[key] = value;
        };
    } else if (isObject(key)) {
        setter = function(el) {
            keys(key).forEach(function(name) {
                el.style[name] = key[name];
            });
        };
    }

    for (; i < length; i++) {
        setter(this[i]);
    }

    return this;
};

fn.data = function(key, value) {
    var args = arguments, data = {},
        i = 0,
        length = this.length,
        setter,
        setValue = function(el, key, value) {
            if (isObject(value)) {
                el.jdata = el.jdata || {};
                el.jdata[key] = value;
            } else {
                el.dataset[key] = value;
            }
        },
        getValue = function(value) {
            if (value === "true") {
                return true;
            } else if (value === "false") {
                return false;
            } else {
                return value;
            }
        };

    // Get all data
    if (args.length === 0) {
        this[0].jdata && (data = this[0].jdata);

        keys(this[0].dataset).forEach(function(key) {
            data[key] = getValue(this[0].dataset[key]);
        }, this);

        return data;
    }
    // Get data by name
    if (args.length === 1 && isString(key)) {
        return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);
    }

    // Set data
    if (args.length === 1 && isObject(key)) {
        setter = function(el) {
            keys(key).forEach(function(name) {
                setValue(el, name, key[name]);
            });
        };
    } else if (args.length === 2) {
        setter = function(el) {
            setValue(el, key, value);
        };
    }

    for (; i < length; i++) {
        setter(this[i]);
    }

    return this;
};

fn.removeData = function(key) {
    var i = 0,
        length = this.length,
        jdata, dataset;

    for (; i < length; i++) {
        jdata = this[i].jdata;
        dataset = this[i].dataset;

        if (key) {
            jdata && jdata[key] && delete jdata[key];
            delete dataset[key];
        } else {
            for (key in jdata) {
                delete jdata[key];
            }

            for (key in dataset) {
                delete dataset[key];
            }
        }
    }

    return this;
};

fn.addClass = function(className) {
    var i = 0,
        j = 0,
        length = this.length,
        classes = className.trim().split(/\s+/);

    for (; i < length; i++) {
        j = 0;

        for (j = 0; j < classes.length; j++) {
            this[i].classList.add(classes[j]);
        }
    }

    return this;
};

fn.removeClass = function(className) {
    var i = 0,
        j = 0,
        length = this.length,
        classes = className.trim().split(/\s+/);

    for (; i < length; i++) {
        j = 0;

        for (j = 0; j < classes.length; j++) {
            this[i].classList.remove(classes[j]);
        }
    }

    return this;
};

fn.toggleClass = function(className, force) {
    var i = 0,
        length = this.length,
        method = "toggle";

    force === true && (method = "add") || force === false && (method = "remove");

    for (; i < length; i++) {
        this[i].classList[method](className);
    }

    return this;
};

fn.hasClass = function(className) {
    var i = 0, length = this.length;

    for (; i < length; i++) {
        if (this[i].classList.contains(className)) {
            return true;
        }
    }

    return false;
};

fn.html = function(value) {
    var args = arguments,
        el;

    // add HTML into elements
    if (args.length === 1 && value !== undefined) {
        return this.empty().append(value);
    }
    // get HTML from element
    else if (args.length === 0 && (el = this[0])) {
        return el.innerHTML;
    }

    return this;
};

fn.append = function(appended) {
    var i = 0,
        length = this.length,
        setter;

    // create jBone object and then append
    if (isString(appended) && rquickExpr.exec(appended)) {
        appended = jBone(appended);
    }
    // create text node for inserting
    else if (!isObject(appended)) {
        appended = document.createTextNode(appended);
    }

    appended = appended instanceof jBone ? appended : jBone(appended);

    setter = function(el, i) {
        appended.forEach(function(node) {
            if (i) {
                el.appendChild(node.cloneNode(true));
            } else {
                el.appendChild(node);
            }
        });
    };

    for (; i < length; i++) {
        setter(this[i], i);
    }

    return this;
};

fn.appendTo = function(to) {
    jBone(to).append(this);

    return this;
};

fn.empty = function() {
    var i = 0,
        length = this.length,
        el;

    for (; i < length; i++) {
        el = this[i];

        while (el.lastChild) {
            el.removeChild(el.lastChild);
        }
    }

    return this;
};

fn.remove = function() {
    var i = 0,
        length = this.length,
        el;

    // remove all listners
    this.off();

    for (; i < length; i++) {
        el = this[i];

        // remove data and nodes
        delete el.jdata;
        el.parentNode && el.parentNode.removeChild(el);
    }

    return this;
};

if (typeof module === "object" && module && typeof module.exports === "object") {
    // Expose jBone as module.exports in loaders that implement the Node
    // module pattern (including browserify). Do not create the global, since
    // the user will be storing it themselves locally, and globals are frowned
    // upon in the Node module world.
    module.exports = jBone;
}
// Register as a AMD module
else if (typeof define === "function" && define.amd) {
    define(function() {
        return jBone;
    });

    win.jBone = win.$ = jBone;
} else if (typeof win === "object" && typeof win.document === "object") {
    win.jBone = win.$ = jBone;
}

}(window));

},{}],68:[function(require,module,exports){
var koalajs = {};

// pass an alternative default value
koalajs.d = koalajs.defaultValue = function defaultValue(obj, defValue) {
  if (obj === undefined) {
    if (typeof obj === "function") {
      return defValue();
    }
    return defValue;
  }
  return obj;
};

// alias for getElementById
koalajs.id = function mk(el) {
  return document.getElementById(el);
};

// alias for createElement
koalajs.mk = function mk(el) {
  return document.createElement(el);
};

if (module !== undefined && module.exports !== undefined) {
  module.exports = koalajs;
}

},{}],69:[function(require,module,exports){
module.exports = require("./lib/menubuilder");

},{"./lib/menubuilder":70}],70:[function(require,module,exports){
var MenuBuilder, jbone, view;

jbone = require("jbone");
view = require("backbone-viewj");

module.exports = MenuBuilder = view.extend({
  initialize: function(opts) {
    this._nodes = [];
    this.name = opts.name || "";
    this.el.className += "smenubar";
  },
  render: function() {

    // remove all childs
    var fc = this.el.firstChild;
    while (fc) {
      this.el.removeChild(fc);
      fc = this.el.firstChild;
    }

    // replace child
    this.el.appendChild(this.buildDOM());
  },
  setName: function(name) {
    this.name = name;
  },
  addNode: function(label, callback, opts) {
    var style;
    if (opts != null) {
      style = opts.style;
    }
    if (this._nodes == null) {
      this._nodes = [];
    }
    this._nodes.push({
      label: label,
      callback: callback,
      style: style
    });
  },

  getNode: function(label) {
    var rNode = undefined;
    this._nodes.forEach(function(el) {
      if (el.label === label) {
        rNode = el;
      }
    });
    return rNode;
  },

  modifyNode: function(label, callback, opts) {
    var node = this.getNode(label);
    node.callback = callback || node.callback;
    opts = opts || {};
    node.style = opts.style || node.style;
  },

  renameNode: function(label, newLabel) {
    var node = this.getNode(label);
    node.label = newLabel || node.label;
  },

  removeNode: function(label) {
    var node = this.getNode(label);
    this._nodes.splice(this._nodes.indexOf(node), 1);
  },

  removeAllNodes: function() {
    this._nodes = [];
  },

  buildDOM: function() {
    var span = document.createElement("span");
    span.appendChild(this._buildM({
      nodes: this._nodes,
      name: this.name
    }));
    return span;
  },
  _buildM: function(data) {
    var displayedButton, frag, key, li, node, style, _ref;
    var nodes = data.nodes;
    var name = data.name;
    var menu = document.createElement("div");
    menu.className = "smenu-dropdown smenu-dropdown-tip";
    menu.style.display = "none";

    var menuUl = document.createElement("ul");
    menuUl.className = "smenu-dropdown-menu";

    // currently we support one-level
    for (var i = 0, _len = nodes.length; i < _len; i++) {
      node = nodes[i];
      li = document.createElement("li");
      li.textContent = node.label;
      _ref = node.style;
      for (key in _ref) {
        style = _ref[key];
        li.style[key] = style;
      }
      li.addEventListener("click", node.callback);
      this.trigger("new:node", li);
      menuUl.appendChild(li);
    }
    this.trigger("new:menu", menuUl);
    menu.appendChild(menuUl);

    displayedButton = document.createElement("a");
    displayedButton.textContent = name;
    displayedButton.className = "smenubar_alink";
    this.trigger("new:button", displayedButton);

    // HACK to be able to hide the submenu
    // listens globally for click events
    jbone(displayedButton).on("click", (function(_this) {
      return function(e) {
        _this._showMenu(e, menu, displayedButton);
        return window.setTimeout(function() {
          return jbone(document.body).one("click", function(e) {
            return menu.style.display = "none";
          });
        }, 5);
      };
    })(this));

    frag = document.createDocumentFragment();
    frag.appendChild(menu);
    frag.appendChild(displayedButton);
    return frag;
  },

  // internal method to display the lower menu on a click
  _showMenu: function(e, menu, target) {
    var rect;
    menu.style.display = "block";
    menu.style.position = "absolute";
    rect = target.getBoundingClientRect();
    menu.style.left = rect.left + "px";
    menu.style.top = (rect.top + target.offsetHeight) + "px";
  }
});

},{"backbone-viewj":9,"jbone":67}],71:[function(require,module,exports){
var Mouse;

module.exports = Mouse = {
  rel: function(e) {
    var mouseX, mouseY, rect, target;
    mouseX = e.offsetX;
    mouseY = e.offsetY;
    if (mouseX == undefined) {
      rect = target.getBoundingClientRect();
      target = e.target || e.srcElement;
      if (mouseX == undefined) {
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
      }
      if (mouseX == undefined) {
        mouseX = e.pageX - target.offsetLeft;
        mouseY = e.pageY - target.offsetTop;
      }
      if (mouseX == undefined) {
        console.log(e, "no mouse event defined. your browser sucks");
        return;
      }
    }
    return [mouseX, mouseY];
  },
  abs: function(e) {
    var mouseX, mouseY;
    mouseX = e.pageX;
    mouseY = e.pageY;
    if (mouseX == undefined) {
      mouseX = e.layerX;
      mouseY = e.layerY;
    }
    if (mouseX == undefined) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    }
    if (mouseX == undefined) {
      mouseX = e.x;
      mouseY = e.y;
    }
    return [mouseX, mouseY];
  },
  wheelDelta: function(e) {
    var delta;
    delta = [e.deltaX, e.deltaY];
    if (delta[0] == undefined) {
      // in case there is a more detailed scroll sensor - use it
      if (e.mozMovementX) {
        delta = [0, e.mozMovementX];
      }
    }
    // safety first
    if (isNaN(delta[0])) {
      delta[0] = 0;
    }
    if (isNaN(delta[1])) {
      delta[1] = 0;
    }
    return delta;
  }
};

},{}],72:[function(require,module,exports){
module.exports = {
  A: "#00a35c",
  R: "#00fc03",
  N: "#00eb14",
  D: "#00eb14",
  C: "#0000ff",
  Q: "#00f10e",
  E: "#00f10e",
  G: "#009d62",
  H: "#00d52a",
  I: "#0054ab",
  L: "#007b84",
  K: "#00ff00",
  M: "#009768",
  F: "#008778",
  P: "#00e01f",
  S: "#00d52a",
  T: "#00db24",
  W: "#00a857",
  Y: "#00e619",
  V: "#005fa0",
  B: "#00eb14",
  X: "#00b649",
  Z: "#00f10e"
};

},{}],73:[function(require,module,exports){
module.exports = {
  A: "#BBBBBB",
  B: "grey",
  C: "yellow",
  D: "red",
  E: "red",
  F: "magenta",
  G: "brown",
  H: "#00FFFF",
  I: "#BBBBBB",
  J: "#fff",
  K: "#00FFFF",
  L: "#BBBBBB",
  M: "#BBBBBB",
  N: "green",
  O: "#fff",
  P: "brown",
  Q: "green",
  R: "#00FFFF",
  S: "green",
  T: "green",
  U: "#fff",
  V: "#BBBBBB",
  W: "magenta",
  X: "grey",
  Y: "magenta",
  Z: "grey",
  Gap: "grey"
};

},{}],74:[function(require,module,exports){
module.exports = {
  A: "orange",
  B: "#fff",
  C: "green",
  D: "red",
  E: "red",
  F: "blue",
  G: "orange",
  H: "red",
  I: "green",
  J: "#fff",
  K: "red",
  L: "green",
  M: "green",
  N: "#fff",
  O: "#fff",
  P: "orange",
  Q: "#fff",
  R: "red",
  S: "orange",
  T: "orange",
  U: "#fff",
  V: "green",
  W: "blue",
  X: "#fff",
  Y: "blue",
  Z: "#fff",
  Gap: "#fff"
};

},{}],75:[function(require,module,exports){
module.exports = {
  A: "#80a0f0",
  R: "#f01505",
  N: "#00ff00",
  D: "#c048c0",
  C: "#f08080",
  Q: "#00ff00",
  E: "#c048c0",
  G: "#f09048",
  H: "#15a4a4",
  I: "#80a0f0",
  L: "#80a0f0",
  K: "#f01505",
  M: "#80a0f0",
  F: "#80a0f0",
  P: "#ffff00",
  S: "#00ff00",
  T: "#00ff00",
  W: "#80a0f0",
  Y: "#15a4a4",
  V: "#80a0f0",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

},{}],76:[function(require,module,exports){
module.exports = {
  A: "#e718e7",
  R: "#6f906f",
  N: "#1be41b",
  D: "#778877",
  C: "#23dc23",
  Q: "#926d92",
  E: "#ff00ff",
  G: "#00ff00",
  H: "#758a75",
  I: "#8a758a",
  L: "#ae51ae",
  K: "#a05fa0",
  M: "#ef10ef",
  F: "#986798",
  P: "#00ff00",
  S: "#36c936",
  T: "#47b847",
  W: "#8a758a",
  Y: "#21de21",
  V: "#857a85",
  B: "#49b649",
  X: "#758a75",
  Z: "#c936c9"
};

},{}],77:[function(require,module,exports){
module.exports = {
  A: "#ad0052",
  B: "#0c00f3",
  C: "#c2003d",
  D: "#0c00f3",
  E: "#0c00f3",
  F: "#cb0034",
  G: "#6a0095",
  H: "#1500ea",
  I: "#ff0000",
  J: "#fff",
  K: "#0000ff",
  L: "#ea0015",
  M: "#b0004f",
  N: "#0c00f3",
  O: "#fff",
  P: "#4600b9",
  Q: "#0c00f3",
  R: "#0000ff",
  S: "#5e00a1",
  T: "#61009e",
  U: "#fff",
  V: "#f60009",
  W: "#5b00a4",
  X: "#680097",
  Y: "#4f00b0",
  Z: "#0c00f3"
};

},{}],78:[function(require,module,exports){
var schemes = require("./schemeclass");
var StaticSchemeClass = schemes.stat;
var DynSchemeClass = schemes.dyn;

var Buried = require("./buried");
var Cinema = require("./cinema");
var Clustal = require("./clustal");
var Clustal2 = require("./clustal2");
var Helix = require("./helix");
var Hydro = require("./hydrophobicity");
var Lesk = require("./lesk");
var Mae = require("./mae");
var Nucleotide = require("./nucleotide");
var Purine = require("./purine");
var Strand = require("./strand");
var Taylor = require("./taylor");
var Turn = require("./turn");
var Zappo = require("./zappo");

var staticSchemes = {
  buried: Buried,
  buried_index: Buried,
  cinema: Cinema,
  clustal2: Clustal2,
  clustal: Clustal,
  helix: Helix,
  helix_propensity: Helix,
  hydro: Hydro,
  lesk: Lesk,
  mae: Mae,
  nucleotide: Nucleotide,
  purine: Purine,
  purine_pyrimidine: Purine,
  strand: Strand,
  strand_propensity: Strand,
  taylor: Taylor,
  turn: Turn,
  turn_propensity: Turn,
  zappo: Zappo
};

var pid = require("./pid_colors.js");

var dynSchemes = {
  pid: pid
};

module.exports = Colors = function(opt){
  this.maps = clone(staticSchemes);  
  this.dyn = clone(dynSchemes);
  this.opt = opt;
}
Colors.getScheme = function(scheme){
  return staticSchemes[scheme];
}
Colors.prototype.getScheme = function(scheme) {
  var color = this.maps[scheme];
  if (color === undefined) {
    color = {};
    if(this.dyn[scheme] != undefined){
      return new DynSchemeClass(this.dyn[scheme],this.opt);
    }
  }
  return new StaticSchemeClass(color);
};

Colors.prototype.addStaticScheme = function(name,scheme) {
  this.maps[name] = scheme;
}

Colors.prototype.addDynScheme = function(name,scheme) {
  this.dyn[name] = scheme;
}

// small helper to clone an object
function clone(obj) {
  if (null == obj || "object" != typeof obj) return obj;
  var copy = obj.constructor();
  for (var attr in obj) {
    if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
  }
  return copy;
}

},{"./buried":72,"./cinema":73,"./clustal":74,"./clustal2":75,"./helix":76,"./hydrophobicity":77,"./lesk":79,"./mae":80,"./nucleotide":81,"./pid_colors.js":82,"./purine":83,"./schemeclass":84,"./strand":85,"./taylor":86,"./turn":87,"./zappo":88}],79:[function(require,module,exports){
module.exports = {
  A: " orange",
  B: " #fff",
  C: " green",
  D: " red",
  E: " red",
  F: " green",
  G: " orange",
  H: " magenta",
  I: " green",
  J: " #fff",
  K: " red",
  L: " green",
  M: " green",
  N: " magenta",
  O: " #fff",
  P: " green",
  Q: " magenta",
  R: " red",
  S: " orange",
  T: " orange",
  U: " #fff",
  V: " green",
  W: " green",
  X: " #fff",
  Y: " green",
  Z: " #fff",
  Gap: " #fff"
};

},{}],80:[function(require,module,exports){
module.exports = {
  A: " #77dd88",
  B: " #fff",
  C: " #99ee66",
  D: " #55bb33",
  E: " #55bb33",
  F: " #9999ff",
  G: " #77dd88",
  H: " #5555ff",
  I: " #66bbff",
  J: " #fff",
  K: " #ffcc77",
  L: " #66bbff",
  M: " #66bbff",
  N: " #55bb33",
  O: " #fff",
  P: " #eeaaaa",
  Q: " #55bb33",
  R: " #ffcc77",
  S: " #ff4455",
  T: " #ff4455",
  U: " #fff",
  V: " #66bbff",
  W: " #9999ff",
  X: " #fff",
  Y: " #9999ff",
  Z: " #fff",
  Gap: " #fff"
};

},{}],81:[function(require,module,exports){
module.exports = {
  A: " #64F73F",
  C: " #FFB340",
  G: " #EB413C",
  T: " #3C88EE",
  U: " #3C88EE"
};

},{}],82:[function(require,module,exports){
var pid;
module.exports = pid = {};

// calculating the conservation is expensive 
// we only want to do it once
pid.init = function(){
  this.cons = this.opt.conservation();
}

pid.run = function(letter,opts){
  var cons = this.cons[opts.pos];
  if(cons > 0.8){
    return "#6464ff";
  }else if(cons > 0.6){
    return "#9da5ff";
  }else if(cons > 0.4){
    return "#cccccc";
  }else{
    return "#ffffff";
  }
}

},{}],83:[function(require,module,exports){
module.exports = {
  A: " #FF83FA",
  C: " #40E0D0",
  G: " #FF83FA",
  R: " #FF83FA",
  T: " #40E0D0",
  U: " #40E0D0",
  Y: " #40E0D0"
};

},{}],84:[function(require,module,exports){
var StaticSchemeClass = function(map){
  this.defaultColor = "#ffffff";
  this.type = "static";
  this.map = map;
  this.getColor = function(letter){
    if(this.map[letter] !== undefined){
      return this.map[letter]; 
    }else{
      return this.defaultColor;
    }
  };
};

var DynSchemeClass = function(fun,opt){
  this.type = "dyn";
  this.opt = opt;
  // init
  if(fun.init !== undefined){
    fun.init.call(this);
    this.getColor = fun.run;
    this.reset = fun.init;
  }else{
    this.getColor = fun;
  }
};
module.exports.stat = StaticSchemeClass;
module.exports.dyn = DynSchemeClass;

},{}],85:[function(require,module,exports){
module.exports = {
  A: "#5858a7",
  R: "#6b6b94",
  N: "#64649b",
  D: "#2121de",
  C: "#9d9d62",
  Q: "#8c8c73",
  E: "#0000ff",
  G: "#4949b6",
  H: "#60609f",
  I: "#ecec13",
  L: "#b2b24d",
  K: "#4747b8",
  M: "#82827d",
  F: "#c2c23d",
  P: "#2323dc",
  S: "#4949b6",
  T: "#9d9d62",
  W: "#c0c03f",
  Y: "#d3d32c",
  V: "#ffff00",
  B: "#4343bc",
  X: "#797986",
  Z: "#4747b8"
};

},{}],86:[function(require,module,exports){
module.exports = {
  A: "#ccff00",
  R: "#0000ff",
  N: "#cc00ff",
  D: "#ff0000",
  C: "#ffff00",
  Q: "#ff00cc",
  E: "#ff0066",
  G: "#ff9900",
  H: "#0066ff",
  I: "#66ff00",
  L: "#33ff00",
  K: "#6600ff",
  M: "#00ff00",
  F: "#00ff66",
  P: "#ffcc00",
  S: "#ff3300",
  T: "#ff6600",
  W: "#00ccff",
  Y: "#00ffcc",
  V: "#99ff00",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

},{}],87:[function(require,module,exports){
module.exports = {
  A: "#2cd3d3",
  R: "#708f8f",
  N: "#ff0000",
  D: "#e81717",
  C: "#a85757",
  Q: "#3fc0c0",
  E: "#778888",
  G: "#ff0000",
  H: "#708f8f",
  I: "#00ffff",
  L: "#1ce3e3",
  K: "#7e8181",
  M: "#1ee1e1",
  F: "#1ee1e1",
  P: "#f60909",
  S: "#e11e1e",
  T: "#738c8c",
  W: "#738c8c",
  Y: "#9d6262",
  V: "#07f8f8",
  B: "#f30c0c",
  X: "#7c8383",
  Z: "#5ba4a4"
};

},{}],88:[function(require,module,exports){
module.exports = {
  A: "#ffafaf",
  R: "#6464ff",
  N: "#00ff00",
  D: "#ff0000",
  C: "#ffff00",
  Q: "#00ff00",
  E: "#ff0000",
  G: "#ff00ff",
  H: "#6464ff",
  I: "#ffafaf",
  L: "#ffafaf",
  K: "#6464ff",
  M: "#ffafaf",
  F: "#ffc800",
  P: "#ff00ff",
  S: "#00ff00",
  T: "#00ff00",
  W: "#ffc800",
  Y: "#ffc800",
  V: "#ffafaf",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

},{}],89:[function(require,module,exports){
/*
 * msa-seqtools
 * https://github.com/greenify/msa-seqtools
 *
 * Copyright (c) 2014 greenify
 * Licensed under the MIT license.
 */

var st = {};
module.exports = st;

// extract IDs and push them to the meta dict
st.getMeta = function(label) {
  if (st.contains(label, "|")) {
    var identifiers = label.split("|");
    var k = 0;
    var database, databaseID;
    var meta = {};
    while (k < identifiers.length - 1) {
      database = identifiers[k];
      databaseID = identifiers[k + 1];
      meta[database] = databaseID;
      k += 2;
    }
    // assume the last entry is the label
    var name = identifiers[identifiers.length - 1];
    // check whether there is a uniprot id
    if (name.indexOf("=") >= 0 && name.indexOf("OS") >= 0) {
      var ds = {};
      var details = name.split(" ");
      ds.en = details[0];
      details = details.splice(1);
      var nameLength = findSepInArr(details, "=");
      var detailsTmp = details.splice(nameLength - 1);
      name = details.join(" ");
      details = detailsTmp;
      k = 0;
      var block = [];
      details.forEach(function(item) {
        block.push(item);
        if (item.indexOf("=") >= 0) {
          strToDict(block.join(" "), "=", ds);
          block = [];
        }
      });
      return {
        name: name,
        ids: meta,
        details: ds
      };
    }
    return {
      name: name,
      ids: meta
    };
  }
  return {
    name: label
  };
};

var findSepInArr = function(arr, sep) {
  for (var i = 0; i < arr.lenght; i++) {
    if (arr[i].indexOf(i)) {
      return i;
    }
  }
  return arr.length - 1;
};

var strToDict = function(str, sep, toJoin) {
  toJoin = toJoin || {};
  var entries = str.split(sep);
  toJoin[entries[0].toLowerCase()] = entries[1];
  return toJoin;
};

var identDB = {
  "sp": {
    link: "http://www.uniprot.org/%s",
    name: "Uniprot"
  },
  "tr": {
    link: "http://www.uniprot.org/%s",
    name: "Trembl"
  },
  "gb": {
    link: "http://www.ncbi.nlm.nih.gov/nuccore/%s",
    name: "Genbank"
  },
  "pdb": {
    link: "http://www.rcsb.org/pdb/explore/explore.do?structureId=%s",
    name: "PDB"
  }
};

st.buildLinks = function(meta) {
  var links = {};
  meta = meta || {};
  Object.keys(meta).forEach(function(id) {
    if (id in identDB) {
      var entry = identDB[id];
      var link = entry.link.replace("%s", meta[id]);
      links[entry.name] = link;
    }
  });
  return links;
};


// search for a text
st.contains = function(text, search) {
  return ''.indexOf.call(text, search, 0) !== -1;
};

// split after e.g. 80 chars
st.splitNChars = function(txt, num) {
  var i, _ref;
  num = num || 80;
  var result = [];
  for (i = 0, _ref = txt.length - 1; i <= _ref; i += num) {
    result.push(txt.substr(i, num));
  }
  return result;
};

st.model = function Seq(seq, name, id) {
  this.seq = seq;
  this.name = name;
  this.id = id;
  this.ids = {};
};

},{}],90:[function(require,module,exports){
var _ = require("underscore");

var stat = function(seqs) {
  // if someone forgets new
  if (this.constructor !== stat) {
    return new stat(seqs);
  }
  if (seqs === undefined || typeof seqs === "string") {
    throw new TypeError("you need to give the seq stat an array");
  }
  //if(seqs.length == 0){
  //throw new TypeError("you need to give the seq stat a real array");
  //}
  this.resetSeqs(seqs);
  this.alphabetSize = 4;
  this._useBackground = false;
  this.ignoredChars = ["-", "*"];
};

stat.prototype.addSeq = function addSeq(seq) {
  this.seqs.push(seq);
  this._reset();
};

stat.prototype.removeSeq = function addSeq(seq) {
  // check for int or string
  if (typeof seq === 'number') {
    this.seqs.splice(seq, 1);
  } else {
    // identify matches (we could have multiple)
    _.each(this.seqs, function(s, i) {
      if (seq === s) {
        this.seqs.splice(i, 1);
      }
    }.bind(this));
  }
  this._reset();
};

stat.prototype.addSeqs = function addSeqs(seqs) {
  seqs.forEach(function(seq) {
    this.addSeq(seq);
  }.bind(this));
};

stat.prototype.resetSeqs = function reset(seqs) {
  this.seqs = [];

  // support sequence models
  if (!(seqs instanceof Array)){
    this.mseqs = seqs;
    var mSeqsPluck = function() {
      var seqArr = this.mseqs.pluck("seq");
      this.resetSeqs(seqArr);
    };
    seqs.on("add change reset ", mSeqsPluck, this);
    mSeqsPluck.call(this);
  } else {
    this.addSeqs(seqs);
    this._reset();
    this.trigger("reset");
  }
};

var calcValues = ["consensus", "frequency", "maxLength", "ic", "gaps"];

stat.prototype._reset = function _reset() {
  for (var i = 0; i < calcValues.length; i++) {
    this["_" + calcValues[i]] = undefined;
  }
  this._identity = undefined;
  this._background = undefined;
};

// -----------------------------------------------------------------------------
// BEGIN: setter/getter
// -----------------------------------------------------------------------------

stat.prototype.setBackground = function setBackground(b) {
  this._useBackground = b;
  this._reset();
};

stat.prototype.useBackground = function useBackground() {
  this.setBackground(true);
};

stat.prototype.setDNA = function setNucleotide() {
  this.alphabetSize = 4;
};

stat.prototype.setProtein = function setDNA() {
  this.alphabetSize = 20;
};

// -----------------------------------------------------------------------------
// BEGIN: auto wrappers
// -----------------------------------------------------------------------------

// neat auto-wrappers
calcValues.forEach(function(key) {
  stat.prototype[key] = function() {
    if (this["_" + key] === undefined) {
      this[key + "Calc"]();
    }
    return this["_" + key];
  };
});

stat.prototype.identity = function identitiy(seq) {
  // do not cache if its called with a special compare seq
  var ident;
  if (this._identity === undefined || seq) {
    ident = this.identityCalc(seq);
    this._identity = undefined;
  }
  return this._identity || ident;
};

// set your own background with obj.bg
stat.prototype.background = function background() {
  if (this.bg !== undefined) {
    return this.bg;
  }
  if (this._background === undefined) {
    this.backgroundCalc();
  }
  return this._background;
};


// -----------------------------------------------------------------------------
// BEGIN: calc tools
// -----------------------------------------------------------------------------

// calculates the relative frequency of a base at a given position
// this is needed e.g. for the entropy calculation
// seqs: array of sequences (strings)
// opts:
//    all: boolean (use to show the frequencies for all letters [including the ignored ones]
//    (default false)
// @returns array of all positions with a dictionary of all bases with their relative frequency
stat.prototype.frequencyCalc = function frequencyCalc(opts) {
  var occs, totalPerPos;
  occs = new Array(this.maxLength());
  totalPerPos = new Array(this.seqs.length);
  var ignoredChars = this.ignoredChars;
  if(opts !== undefined && opts.all){
    ignoredChars = []; 
  }

  // count the occurrences of the chars at a position
  _.each(this.seqs, function(el) {
    _.each(el, function(c, pos) {
      if (ignoredChars.indexOf(c) >= 0) return;
      if (occs[pos] === undefined) {
        occs[pos] = {};
      }
      if (occs[pos][c] === undefined) {
        occs[pos][c] = 0;
      }
      occs[pos][c] ++;
      if (totalPerPos[pos] === undefined) {
        totalPerPos[pos] = 0;
      }
      totalPerPos[pos] ++;
    });
  });

  // normalize to 1
  _.each(occs, function(el, pos) {
    return _.each(el, function(val, c) {
      return (occs[pos][c] = val / totalPerPos[pos]);
    });
  });
  this._frequency = occs;
  return occs;
};

// seqs: array of sequences (strings)
stat.prototype.backgroundCalc = function backgroundCalc() {
  var occ = {};
  var total = 0;

  // count the occurences of the chars of a position
  _.each(this.seqs, function(el) {
    _.each(el, function(c) {
      if (occ[c] === undefined) {
        occ[c] = 0;
      }
      occ[c] ++;
      return total++;
    });
  });

  // normalize to 1
  occ = _.mapValues(occ, function(val) {
    return val / total;
  });
  this._background = occ;
  return occ;
};


// information content after Shannon
// * gaps are excluded
stat.prototype.icCalc = function icCalc() {
  var f = this.frequency();
  if (this._useBackground) {
    var b = this.background();
  }
  var ignoredChars = this.ignoredChars;
  var useBackground = this._useBackground;
  var ic = _.map(f, function(el) {
    return _.reduce(el, function(memo, val, c) {
      if (ignoredChars.indexOf(c) >= 0) return memo;
      if (useBackground) {
        val = val / b[c];
      }
      return memo - val * (Math.log(val) / Math.log(2));
    }, 0);
  });
  this._ic = ic;
  return ic;
};

// sequence conservation after Schneider and Stephens (1990)
// @cite Schneider, T.D. and Stephens, R.M. 1990. Sequence logos: A new way to
// display consensus sequences. Nucleic Acids Res. 18: 6097â€“6100.
stat.prototype.conservation = function conservation(alphabetSize) {
  var ic = this.ic();
  alphabetSize = alphabetSize || this.alphabetSize;
  var icMax = Math.log(alphabetSize) / Math.log(2);
  var conserv = _.map(ic, function(el) {
    return icMax - el;
  });
  return conserv;
};

// sequence conservation after Schneider and Stephens (1990)
// conservation for each amino acid
// * gaps are excluded
stat.prototype.conservResidue = function conservation(input) {
  var alphabetSize = input ? input.alphabetSize : undefined;
  var ic;
  var ignoredChars = this.ignoredChars;
  if (input !== undefined && input.scaled) {
    ic = this.scale(this.conservation(alphabetSize));
  } else {
    ic = this.conservation(alphabetSize);
  }
  var f = this.frequency();
  var keys;
  var conserv = _.map(f, function(el, i) {
    keys = _.reject(_.keys(el), function(c) {
      return ignoredChars.indexOf(c) >= 0;
    });
    var obj = {};
    _.each(keys, function(key) {
      obj[key] = el[key] * ic[i];
    });
    return obj;
  });
  return conserv;
};

// type 2 sequence logo method
// scales relative to background
stat.prototype.conservResidue2 = function conservation(alphabetSize) {
  var f = this.frequency();
  var ic = this.conservation(alphabetSize);
  var b = this.background();
  var conserv = _.map(f, function(el, i) {
    return _.map(el, function(val) {
      var sum = _.reduce(f[i], function(memo, e) {
        return memo + e / b[i];
      }, 0);
      return ((val / b[i]) / sum) * ic[i];
    }, 0);
  });
  return conserv;
};

// scale information content or conservation to 1
stat.prototype.scale = function conservation(ic, alphabetSize) {
  alphabetSize = alphabetSize || this.alphabetSize;
  var icMax = Math.log(alphabetSize) / Math.log(2);
  var conserv = _.map(ic, function(el) {
    return el / icMax;
  });
  return conserv;
};

stat.prototype.maxLengthCalc = function() {
  this._maxLength = _.max(this.seqs, function(seq) {
    return seq.length;
  }).length;
};

// seqs: array of sequences (strings)
// @returns consenus sequence
stat.prototype.consensusCalc = function consensusCal() {
  var occs = new Array(this.maxLength());

  // count the occurrences of the chars of a position
  _.each(this.seqs, function(el) {
    _.each(el, function(c, pos) {
      if (occs[pos] === undefined) {
        occs[pos] = {};
      }
      if (occs[pos][c] === undefined) {
        occs[pos][c] = 0;
      }
      occs[pos][c] ++;
    });
  });

  // now pick the char with most occurrences
  this._consensus = _.reduce(occs, function(memo, occ) {
    var keys;
    keys = _.keys(occ);
    return memo += _.max(keys, function(key) {
      return occ[key];
    });
  }, "");

  return this._consensus;
};

// seqs: array of sequences (strings)
// consensus: calculated consensus seq
// calculates for each sequence
// * matches with the consensus seq
// * identity = matchedChars / totalChars (excluding gaps)
// @returns: array of length of the seqs with the identity to the consensus (double)
stat.prototype.identityCalc = function identitiyCalc(compareSeq) {
  var consensus = compareSeq || this.consensus();
  this._identity = this.seqs.map(function(seq) {
    var matches = 0;
    var total = 0;
    for (var i = 0; i < seq.length; i++) {
      if (seq[i] !== "-" && consensus[i] !== "-") {
        total++;
        if (seq[i] === consensus[i]) {
          matches++;
        }
      }
    }
    return matches / total;
  });
  return this._identity;
};

// percentage of gaps per column
stat.prototype.gapsCalc = function gapsCount() {
  var occs = new Array(this.maxLength());
  // count the occurrences of the chars of a position
  _.each(this.seqs, function(el) {
    _.each(el, function(c, pos) {
      if (occs[pos] === undefined) {
        occs[pos] = {
          g: 0,
          t: 0
        };
      }
      c = c === "-" ? "g" : "t";
      occs[pos][c] ++;
    });
  });

  // now pick the char with most occurrences
  this._gaps = _.map(occs, function(el) {
    return el.g / (el.g + el.t);
  });
  return this._gaps;
};

_.mixin({
  mapValues: function(obj, f_val) {
    return _.object(_.keys(obj), _.map(obj, f_val));
  }
});

require("biojs-events").mixin(stat.prototype);

module.exports = stat;

},{"biojs-events":13,"underscore":91}],91:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result â€” either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],92:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],93:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],94:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21,"is-function":95}],95:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],96:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],97:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"for-each":94,"trim":96}],98:[function(require,module,exports){
var Colors, Colorscheme, Model;

Colors = require("msa-colorschemes");

Model = require("backbone-thin").Model;

module.exports = Colorscheme = Model.extend({
  defaults: {
    scheme: "taylor",
    colorBackground: true,
    showLowerCase: true,
    opacity: 0.6
  },
  initialize: function(data, seqs, stat) {
    this.colors = new Colors({
      seqs: seqs,
      conservation: function() {
        return stat.scale(stat.conservation());
      }
    });
    return stat.on("reset", function() {
      if (this.getSelectedScheme().type === "dyn") {
        return this.getSelectedScheme().reset();
      }
    }, this);
  },
  addStaticScheme: function(name, dict) {
    return this.colors.addStaticScheme(name, dict);
  },
  addDynScheme: function(name, fun) {
    return this.colors.addDynScheme(name, fun);
  },
  getScheme: function(name) {
    return this.colors.getScheme(name);
  },
  getSelectedScheme: function() {
    return this.colors.getScheme(this.get("scheme"));
  }
});



},{"backbone-thin":4,"msa-colorschemes":78}],99:[function(require,module,exports){
var Columns, Model, _;

Model = require("backbone-thin").Model;

_ = require("underscore");

module.exports = Columns = Model.extend({
  initialize: function(o, stat) {
    if (this.get("hidden") == null) {
      this.set("hidden", []);
    }
    return this.stats = stat;
  },
  calcHiddenColumns: function(n) {
    var hidden, i, j, len, newX;
    hidden = this.get("hidden");
    newX = n;
    for (j = 0, len = hidden.length; j < len; j++) {
      i = hidden[j];
      if (i <= newX) {
        newX++;
      }
    }
    return newX - n;
  }
});



},{"backbone-thin":4,"underscore":91}],100:[function(require,module,exports){
var Config, Model;

Model = require("backbone-thin").Model;

module.exports = Config = Model.extend({
  defaults: {
    registerMouseHover: false,
    registerMouseClicks: true,
    importProxy: "https://cors-anywhere.herokuapp.com/",
    eventBus: true,
    alphabetSize: 20,
    dropImport: false,
    debug: false,
    hasRef: false
  }
});



},{"backbone-thin":4}],101:[function(require,module,exports){
var Loader, Model, Package;

Loader = require("../utils/loader");

Model = require("backbone-thin").Model;

module.exports = Package = Model.extend({
  initialize: function(g) {
    return this.g = g;
  },
  development: {
    "msa-tnt": "/node_modules/msa-tnt/build/bundle.js",
    "biojs-io-newick": "/node_modules/biojs-io-newick/build/biojs-io-newick.min.js"
  },
  loadPackage: function(pkg, cb) {
    var p;
    try {
      p = require(pkg);
      return cb(p);
    } catch (_error) {
      return Loader.loadScript(this._pkgURL(pkg), cb);
    }
  },
  loadPackages: function(pkgs, cb) {
    var cbs;
    cbs = Loader.joinCb(function() {
      return cb();
    }, pkgs.length);
    return pkgs.forEach((function(_this) {
      return function(pkg) {
        return _this.loadPackage(pkg, cbs);
      };
    })(this));
  },
  _pkgURL: function(pkg) {
    var url;
    if (this.g.config.get("debug")) {
      url = this.development[pkg];
    } else {
      url = "http://wzrd.in/bundle/" + pkg + "@latest";
    }
    return url;
  }
});



},{"../utils/loader":132,"backbone-thin":4}],102:[function(require,module,exports){
var ColumnSelection, Model, PosSelection, RowSelection, Selection, _;

_ = require("underscore");

Model = require("backbone-thin").Model;

Selection = Model.extend({
  defaults: {
    type: "super"
  }
});

RowSelection = Selection.extend({
  defaults: _.extend({}, Selection.prototype.defaults, {
    type: "row",
    seqId: ""
  }),
  inRow: function(seqId) {
    return seqId === this.get("seqId");
  },
  inColumn: function(rowPos) {
    return true;
  },
  getLength: function() {
    return 1;
  }
});

ColumnSelection = Selection.extend({
  defaults: _.extend({}, Selection.prototype.defaults, {
    type: "column",
    xStart: -1,
    xEnd: -1
  }),
  inRow: function() {
    return true;
  },
  inColumn: function(rowPos) {
    return xStart <= rowPos && rowPos <= xEnd;
  },
  getLength: function() {
    return xEnd - xStart;
  }
});

PosSelection = RowSelection.extend(_.extend({}, _.pick(ColumnSelection, "inColumn"), _.pick(ColumnSelection, "getLength"), {
  defaults: _.extend({}, ColumnSelection.prototype.defaults, RowSelection.prototype.defaults, {
    type: "pos"
  })
}));

module.exports.sel = Selection;

module.exports.possel = PosSelection;

module.exports.rowsel = RowSelection;

module.exports.columnsel = ColumnSelection;



},{"backbone-thin":4,"underscore":91}],103:[function(require,module,exports){
var Collection, SelectionManager, _, sel;

sel = require("./Selection");

_ = require("underscore");

Collection = require("backbone-thin").Collection;

module.exports = SelectionManager = Collection.extend({
  model: sel.sel,
  initialize: function(data, opts) {
    if (opts != null) {
      this.g = opts.g;
      this.listenTo(this.g, "residue:click", function(e) {
        return this._handleE(e.evt, new sel.possel({
          xStart: e.rowPos,
          xEnd: e.rowPos,
          seqId: e.seqId
        }));
      });
      this.listenTo(this.g, "row:click", function(e) {
        return this._handleE(e.evt, new sel.rowsel({
          seqId: e.seqId
        }));
      });
      return this.listenTo(this.g, "column:click", function(e) {
        return this._handleE(e.evt, new sel.columnsel({
          xStart: e.rowPos,
          xEnd: e.rowPos + e.stepSize - 1
        }));
      });
    }
  },
  getSelForRow: function(seqId) {
    return this.filter(function(el) {
      return el.inRow(seqId);
    });
  },
  getSelForColumns: function(rowPos) {
    return this.filter(function(el) {
      return el.inColumn(rowPos);
    });
  },
  addJSON: function(model) {
    return this.add(this._fromJSON(model));
  },
  _fromJSON: function(model) {
    switch (model.type) {
      case "column":
        return new sel.columnsel(model);
      case "row":
        return new sel.rowsel(model);
      case "pos":
        return new sel.possel(model);
    }
  },
  resetJSON: function(arr) {
    arr = _.map(arr, this._fromJSON);
    return this.reset(arr);
  },
  getBlocksForRow: function(seqId, maxLen) {
    var blocks, i, j, k, len, ref, ref1, results, results1, seli, selis;
    selis = this.filter(function(el) {
      return el.inRow(seqId);
    });
    blocks = [];
    for (i = 0, len = selis.length; i < len; i++) {
      seli = selis[i];
      if (seli.attributes.type === "row") {
        blocks = (function() {
          results = [];
          for (var j = 0; 0 <= maxLen ? j <= maxLen : j >= maxLen; 0 <= maxLen ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this);
        break;
      } else {
        blocks = blocks.concat((function() {
          results1 = [];
          for (var k = ref = seli.attributes.xStart, ref1 = seli.attributes.xEnd; ref <= ref1 ? k <= ref1 : k >= ref1; ref <= ref1 ? k++ : k--){ results1.push(k); }
          return results1;
        }).apply(this));
      }
    }
    return blocks;
  },
  getAllColumnBlocks: function(conf) {
    var blocks, filtered, i, j, len, maxLen, ref, ref1, results, seli, withPos;
    maxLen = conf.maxLen;
    withPos = conf.withPos;
    blocks = [];
    if (conf.withPos) {
      filtered = this.filter(function(el) {
        return el.get('xStart') != null;
      });
    } else {
      filtered = this.filter(function(el) {
        return el.get('type') === "column";
      });
    }
    for (i = 0, len = filtered.length; i < len; i++) {
      seli = filtered[i];
      blocks = blocks.concat((function() {
        results = [];
        for (var j = ref = seli.attributes.xStart, ref1 = seli.attributes.xEnd; ref <= ref1 ? j <= ref1 : j >= ref1; ref <= ref1 ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this));
    }
    blocks = _.uniq(blocks);
    return blocks;
  },
  invertRow: function(rows) {
    var el, i, inverted, len, s, selRows;
    selRows = this.where({
      type: "row"
    });
    selRows = _.map(selRows, function(el) {
      return el.attributes.seqId;
    });
    inverted = _.filter(rows, function(el) {
      if (selRows.indexOf(el) >= 0) {
        return false;
      }
      return true;
    });
    s = [];
    for (i = 0, len = inverted.length; i < len; i++) {
      el = inverted[i];
      s.push(new sel.rowsel({
        seqId: el
      }));
    }
    return this.reset(s);
  },
  invertCol: function(columns) {
    var el, i, inverted, len, s, selColumns, xEnd, xStart;
    selColumns = this.where({
      type: "column"
    });
    selColumns = _.reduce(selColumns, function(memo, el) {
      var i, ref, ref1, results;
      return memo.concat((function() {
        results = [];
        for (var i = ref = el.attributes.xStart, ref1 = el.attributes.xEnd; ref <= ref1 ? i <= ref1 : i >= ref1; ref <= ref1 ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this));
    }, []);
    inverted = _.filter(columns, function(el) {
      if (selColumns.indexOf(el) >= 0) {
        return false;
      }
      return true;
    });
    if (inverted.length === 0) {
      return;
    }
    s = [];
    xStart = xEnd = inverted[0];
    for (i = 0, len = inverted.length; i < len; i++) {
      el = inverted[i];
      if (xEnd + 1 === el) {
        xEnd = el;
      } else {
        s.push(new sel.columnsel({
          xStart: xStart,
          xEnd: xEnd
        }));
        xStart = xEnd = el;
      }
    }
    if (xStart !== xEnd) {
      s.push(new sel.columnsel({
        xStart: xStart,
        xEnd: inverted[inverted.length - 1]
      }));
    }
    return this.reset(s);
  },
  _handleE: function(e, selection) {
    if (e.ctrlKey || e.metaKey) {
      return this.add(selection);
    } else {
      return this.reset([selection]);
    }
  },
  _reduceColumns: function() {
    return this.each(function(el, index, arr) {
      var cols, i, j, left, lefts, len, len1, right, rights, xEnd, xStart;
      cols = _.filter(arr, function(el) {
        return el.get('type') === 'column';
      });
      xStart = el.get('xStart');
      xEnd = el.get('xEnd');
      lefts = _.filter(cols, function(el) {
        return el.get('xEnd') === (xStart - 1);
      });
      for (i = 0, len = lefts.length; i < len; i++) {
        left = lefts[i];
        left.set('xEnd', xStart);
      }
      rights = _.filter(cols, function(el) {
        return el.get('xStart') === (xEnd + 1);
      });
      for (j = 0, len1 = rights.length; j < len1; j++) {
        right = rights[j];
        right.set('xStart', xEnd);
      }
      if (lefts.length > 0 || rights.length > 0) {
        console.log("removed el");
        return el.collection.remove(el);
      }
    });
  }
});



},{"./Selection":102,"backbone-thin":4,"underscore":91}],104:[function(require,module,exports){
var Config, Model;

Model = require("backbone-thin").Model;

module.exports = Config = Model.extend({
  defaults: {
    searchText: ""
  }
});



},{"backbone-thin":4}],105:[function(require,module,exports){
var Model, Visibility;

Model = require("backbone-thin").Model;

module.exports = Visibility = Model.extend({
  defaults: {
    searchBox: -10,
    overviewBox: 30,
    headerBox: -1,
    alignmentBody: 0
  }
});



},{"backbone-thin":4}],106:[function(require,module,exports){
var Model, Visibility;

Model = require("backbone-thin").Model;

module.exports = Visibility = Model.extend({
  defaults: {
    sequences: true,
    markers: true,
    metacell: false,
    conserv: false,
    overviewbox: false,
    seqlogo: false,
    gapHeader: false,
    leftHeader: true,
    labels: true,
    labelName: true,
    labelId: true,
    labelPartition: false,
    labelCheckbox: false,
    metaGaps: true,
    metaIdentity: true,
    metaLinks: true
  },
  constructor: function(attributes, options) {
    this.calcDefaults(options.model);
    return Model.apply(this, arguments);
  },
  initialize: function() {
    this.listenTo(this, "change:metaLinks change:metaIdentity change:metaGaps", function() {
      return this.trigger("change:metacell");
    }, this);
    this.listenTo(this, "change:labelName change:labelId change:labelPartition change:labelCheckbox", function() {
      return this.trigger("change:labels");
    }, this);
    return this.listenTo(this, "change:markers change:conserv change:seqlogo change:gapHeader", function() {
      return this.trigger("change:header");
    }, this);
  },
  calcDefaults: function(seqs) {
    var ids, seq;
    if (seqs.length > 0) {
      seq = seqs.at(0);
      ids = seq.get("ids");
      if (ids !== void 0 && Object.keys(ids).length === 0) {
        return this.defaults.metaLinks = false;
      }
    }
  }
});



},{"backbone-thin":4}],107:[function(require,module,exports){
var Model, Zoomer;

Model = require("backbone-thin").Model;

module.exports = Zoomer = Model.extend({
  constructor: function(attributes, options) {
    this.calcDefaults(options.model);
    Model.apply(this, arguments);
    this.g = options.g;
    this.listenTo(this, "change:labelIdLength change:labelNameLength change:labelPartLength change:labelCheckLength", function() {
      return this.trigger("change:labelWidth", this.getLabelWidth());
    }, this);
    this.listenTo(this, "change:metaLinksWidth change:metaIdentWidth change:metaGapWidth", function() {
      return this.trigger("change:metaWidth", this.getMetaWidth());
    }, this);
    return this;
  },
  defaults: {
    alignmentWidth: "auto",
    alignmentHeight: 225,
    columnWidth: 15,
    rowHeight: 15,
    autoResize: true,
    textVisible: true,
    labelIdLength: 50,
    labelNameLength: 100,
    labelPartLength: 15,
    labelCheckLength: 15,
    labelFontsize: 13,
    labelLineHeight: "13px",
    markerFontsize: "10px",
    stepSize: 1,
    markerStepSize: 2,
    markerHeight: 20,
    residueFont: "13",
    canvasEventScale: 1,
    boxRectHeight: 2,
    boxRectWidth: 2,
    overviewboxPaddingTop: 10,
    menuFontsize: "14px",
    menuItemFontsize: "14px",
    menuItemLineHeight: "14px",
    menuMarginLeft: "3px",
    menuPadding: "3px 4px 3px 4px",
    metaGapWidth: 35,
    metaIdentWidth: 40,
    metaLinksWidth: 25,
    _alignmentScrollLeft: 0,
    _alignmentScrollTop: 0
  },
  calcDefaults: function(model) {
    var maxLen;
    maxLen = model.getMaxLength();
    if (maxLen < 200 && model.length < 30) {
      return this.defaults.boxRectWidth = this.defaults.boxRectHeight = 5;
    }
  },
  getAlignmentWidth: function(n) {
    if (this.get("autoResize") && n !== void 0) {
      return this.get("columnWidth") * n;
    }
    if (this.get("alignmentWidth") === void 0 || this.get("alignmentWidth") === "auto" || this.get("alignmentWidth") === 0) {
      return this._adjustWidth();
    } else {
      return this.get("alignmentWidth");
    }
  },
  setLeftOffset: function(n) {
    var val;
    val = n;
    val = Math.max(0, val);
    val -= this.g.columns.calcHiddenColumns(val);
    return this.set("_alignmentScrollLeft", val * this.get('columnWidth'));
  },
  setTopOffset: function(n) {
    var height, i, j, ref, seq, val;
    val = Math.max(0, n - 1);
    height = 0;
    for (i = j = 0, ref = val; j <= ref; i = j += 1) {
      seq = this.model.at(i);
      height += seq.attributes.height || 1;
    }
    return this.set("_alignmentScrollTop", height * this.get("rowHeight"));
  },
  getLeftBlockWidth: function() {
    var paddingLeft;
    paddingLeft = 0;
    if (this.g.vis.get("labels")) {
      paddingLeft += this.getLabelWidth();
    }
    if (this.g.vis.get("metacell")) {
      paddingLeft += this.getMetaWidth();
    }
    return paddingLeft;
  },
  getMetaWidth: function() {
    var val;
    val = 0;
    if (this.g.vis.get("metaGaps")) {
      val += this.get("metaGapWidth");
    }
    if (this.g.vis.get("metaIdentity")) {
      val += this.get("metaIdentWidth");
    }
    if (this.g.vis.get("metaLinks")) {
      val += this.get("metaLinksWidth");
    }
    return val;
  },
  getLabelWidth: function() {
    var val;
    val = 0;
    if (this.g.vis.get("labelName")) {
      val += this.get("labelNameLength");
    }
    if (this.g.vis.get("labelId")) {
      val += this.get("labelIdLength");
    }
    if (this.g.vis.get("labelPartition")) {
      val += this.get("labelPartLength");
    }
    if (this.g.vis.get("labelCheckbox")) {
      val += this.get("labelCheckLength");
    }
    return val;
  },
  _adjustWidth: function() {
    var calcWidth, maxWidth, parentWidth, val;
    if (!(this.el !== void 0 && this.model !== void 0)) {
      return;
    }
    if ((this.el.parentNode != null) && this.el.parentNode.offsetWidth !== 0) {
      parentWidth = this.el.parentNode.offsetWidth;
    } else {
      parentWidth = document.body.clientWidth - 35;
    }
    maxWidth = parentWidth - this.getLeftBlockWidth();
    calcWidth = this.getAlignmentWidth(this.model.getMaxLength() - this.g.columns.get('hidden').length);
    val = Math.min(maxWidth, calcWidth);
    val = Math.floor(val / this.get("columnWidth")) * this.get("columnWidth");
    return this.attributes.alignmentWidth = val;
  },
  autoResize: function() {
    if (this.get("autoResize")) {
      return this._adjustWidth(this.el, this.model);
    }
  },
  autoHeight: function(max) {
    var val;
    val = this.getMaxAlignmentHeight();
    if (max !== void 0 && max > 0) {
      val = Math.min(val, max);
    }
    return this.set("alignmentHeight", val);
  },
  setEl: function(el, model) {
    this.el = el;
    return this.model = model;
  },
  _checkScrolling: function(scrollObj, opts) {
    var xScroll, yScroll;
    xScroll = scrollObj[0];
    yScroll = scrollObj[1];
    this.set("_alignmentScrollLeft", xScroll, opts);
    return this.set("_alignmentScrollTop", yScroll, opts);
  },
  getMaxAlignmentHeight: function() {
    var height;
    height = 0;
    this.model.each(function(seq) {
      return height += seq.attributes.height || 1;
    });
    return height * this.get("rowHeight");
  },
  getMaxAlignmentWidth: function() {
    return this.model.getMaxLength() * this.get("columnWidth");
  }
});



},{"backbone-thin":4}],108:[function(require,module,exports){
var MSA;

MSA = require("./msa");

module.exports = function() {
  var msa;
  msa = function(args) {
    return MSA.apply(this, args);
  };
  msa.prototype = MSA.prototype;
  return new msa(arguments);
};

module.exports.msa = MSA;

module.exports.model = require("./model");

module.exports.menu = require("./menu");

module.exports.utils = require("./utils");

module.exports.selection = require("./g/selection/Selection");

module.exports.selcol = require("./g/selection/SelectionCol");

module.exports.view = require("backbone-viewj");

module.exports.boneView = require("backbone-childs");

module.exports._ = require('underscore');

module.exports.$ = require('jbone');

module.exports.io = {};

module.exports.io.xhr = require('xhr');

module.exports.io.fasta = require('biojs-io-fasta');

module.exports.io.clustal = require('biojs-io-clustal');

module.exports.io.gff = require('biojs-io-gff');

module.exports.version = "0.2.0";



},{"./g/selection/Selection":102,"./g/selection/SelectionCol":103,"./menu":110,"./model":126,"./msa":127,"./utils":131,"backbone-childs":2,"backbone-viewj":9,"biojs-io-clustal":"biojs-io-clustal","biojs-io-fasta":"biojs-io-fasta","biojs-io-gff":"biojs-io-gff","jbone":67,"underscore":91,"xhr":"xhr"}],109:[function(require,module,exports){
var ColorMenu, DebugMenu, ExportMenu, ExtraMenu, FilterMenu, HelpMenu, ImportMenu, MenuView, OrderingMenu, SelectionMenu, VisMenu, boneView;

boneView = require("backbone-childs");

ImportMenu = require("./views/ImportMenu");

FilterMenu = require("./views/FilterMenu");

SelectionMenu = require("./views/SelectionMenu");

VisMenu = require("./views/VisMenu");

ColorMenu = require("./views/ColorMenu");

OrderingMenu = require("./views/OrderingMenu");

ExtraMenu = require("./views/ExtraMenu");

ExportMenu = require("./views/ExportMenu");

HelpMenu = require("./views/HelpMenu");

DebugMenu = require("./views/DebugMenu");

module.exports = MenuView = boneView.extend({
  initialize: function(data) {
    this.msa = data.msa;
    this.addView("10_import", new ImportMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("20_filter", new FilterMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("30_selection", new SelectionMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("40_vis", new VisMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("50_color", new ColorMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("60_ordering", new OrderingMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("70_extra", new ExtraMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("80_export", new ExportMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("90_help", new HelpMenu({
      g: this.msa.g
    }));
    if (this.msa.g.config.get("debug")) {
      return this.addView("95_debug", new DebugMenu({
        g: this.msa.g
      }));
    }
  },
  render: function() {
    this.renderSubviews();
    this.el.setAttribute("class", "smenubar");
    return this.el.appendChild(document.createElement("p"));
  }
});



},{"./views/ColorMenu":112,"./views/DebugMenu":113,"./views/ExportMenu":114,"./views/ExtraMenu":115,"./views/FilterMenu":116,"./views/HelpMenu":117,"./views/ImportMenu":118,"./views/OrderingMenu":119,"./views/SelectionMenu":120,"./views/VisMenu":121,"backbone-childs":2}],110:[function(require,module,exports){
module.exports.defaultmenu = require("./defaultmenu");

module.exports.menubuilder = require("./menubuilder");



},{"./defaultmenu":109,"./menubuilder":111}],111:[function(require,module,exports){
var MenuBuilder, builder;

builder = require("menu-builder");

module.exports = MenuBuilder = builder.extend({
  buildDOM: function() {
    this.on("new:node", this.buildNode);
    this.on("new:button", this.buildButton);
    this.on("new:menu", this.buildMenu);
    return builder.prototype.buildDOM.call(this);
  },
  buildNode: function(li) {
    if (this.g != null) {
      return li.style.lineHeight = this.g.zoomer.get("menuItemLineHeight");
    }
  },
  buildButton: function(btn) {
    if (this.g != null) {
      btn.style.fontSize = this.g.zoomer.get("menuFontsize");
      btn.style.marginLeft = this.g.zoomer.get("menuMarginLeft");
      return btn.style.padding = this.g.zoomer.get("menuPadding");
    }
  },
  buildMenu: function(menu) {
    if (this.g != null) {
      return menu.style.fontSize = this.g.zoomer.get("menuItemFontsize");
    }
  }
});



},{"menu-builder":69}],112:[function(require,module,exports){
var ColorMenu, MenuBuilder, _, dom;

MenuBuilder = require("../menubuilder");

_ = require("underscore");

dom = require("dom-helper");

module.exports = ColorMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.listenTo(this.g.colorscheme, "change", function() {
      return this.render();
    });
  },
  render: function() {
    var colorschemes, j, len, menuColor, scheme, text;
    menuColor = this.setName("Color scheme");
    this.removeAllNodes();
    colorschemes = this.getColorschemes();
    for (j = 0, len = colorschemes.length; j < len; j++) {
      scheme = colorschemes[j];
      this.addScheme(menuColor, scheme);
    }
    text = "Background";
    if (this.g.colorscheme.get("colorBackground")) {
      text = "Hide " + text;
    } else {
      text = "Show " + text;
    }
    this.addNode(text, (function(_this) {
      return function() {
        return _this.g.colorscheme.set("colorBackground", !_this.g.colorscheme.get("colorBackground"));
      };
    })(this));
    this.grey(menuColor);
    dom.removeAllChilds(this.el);
    this.el.appendChild(this.buildDOM());
    return this;
  },
  addScheme: function(menuColor, scheme) {
    var current, style;
    style = {};
    current = this.g.colorscheme.get("scheme");
    if (current === scheme.id) {
      style.backgroundColor = "#77ED80";
    }
    return this.addNode(scheme.name, (function(_this) {
      return function() {
        return _this.g.colorscheme.set("scheme", scheme.id);
      };
    })(this), {
      style: style
    });
  },
  getColorschemes: function() {
    var schemes;
    schemes = [];
    schemes.push({
      name: "Zappo",
      id: "zappo"
    });
    schemes.push({
      name: "Taylor",
      id: "taylor"
    });
    schemes.push({
      name: "Hydrophobicity",
      id: "hydro"
    });
    schemes.push({
      name: "Lesk",
      id: "lesk"
    });
    schemes.push({
      name: "Cinema",
      id: "cinema"
    });
    schemes.push({
      name: "MAE",
      id: "mae"
    });
    schemes.push({
      name: "Clustal",
      id: "clustal"
    });
    schemes.push({
      name: "Clustal2",
      id: "clustal2"
    });
    schemes.push({
      name: "Turn",
      id: "turn"
    });
    schemes.push({
      name: "Strand",
      id: "strand"
    });
    schemes.push({
      name: "Buried",
      id: "buried"
    });
    schemes.push({
      name: "Helix",
      id: "helix"
    });
    schemes.push({
      name: "Nucleotide",
      id: "nucleotide"
    });
    schemes.push({
      name: "Purine",
      id: "purine"
    });
    schemes.push({
      name: "PID",
      id: "pid"
    });
    schemes.push({
      name: "No color",
      id: "foo"
    });
    return schemes;
  },
  grey: function(menuColor) {
    this.addNode("Shade", (function(_this) {
      return function() {
        _this.g.colorscheme.set("showLowerCase", false);
        return _this.model.each(function(seq) {
          var grey, residues;
          residues = seq.get("seq");
          grey = [];
          _.each(residues, function(el, index) {
            if (el === el.toLowerCase()) {
              return grey.push(index);
            }
          });
          return seq.set("grey", grey);
        });
      };
    })(this));
    this.addNode("Shade by threshold", (function(_this) {
      return function() {
        var conserv, grey, i, j, maxLen, ref, threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        conserv = _this.g.stats.scale(_this.g.stats.conservation());
        grey = [];
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (conserv[i] < threshold) {
            grey.push(i);
          }
        }
        return _this.model.each(function(seq) {
          return seq.set("grey", grey);
        });
      };
    })(this));
    this.addNode("Shade selection", (function(_this) {
      return function() {
        var maxLen;
        maxLen = _this.model.getMaxLength();
        return _this.model.each(function(seq) {
          var blocks;
          blocks = _this.g.selcol.getBlocksForRow(seq.get("id"), maxLen);
          return seq.set("grey", blocks);
        });
      };
    })(this));
    return this.addNode("Reset shade", (function(_this) {
      return function() {
        _this.g.colorscheme.set("showLowerCase", true);
        return _this.model.each(function(seq) {
          return seq.set("grey", []);
        });
      };
    })(this));
  }
});



},{"../menubuilder":111,"dom-helper":66,"underscore":91}],113:[function(require,module,exports){
var DebugMenu, MenuBuilder;

MenuBuilder = require("../menubuilder");

module.exports = DebugMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function() {
    this.setName("Debug");
    this.addNode("Get the code", (function(_this) {
      return function() {
        return window.open("https://github.com/greenify/msa");
      };
    })(this));
    this.addNode("Toggle mouseover events", (function(_this) {
      return function() {
        _this.g.config.set("registerMouseHover", !_this.g.config.get("registerMouseHover"));
        return _this.g.onAll(function() {
          return console.log(arguments);
        });
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../menubuilder":111}],114:[function(require,module,exports){
var ExportMenu, Exporter, FastaExporter, MenuBuilder, _;

MenuBuilder = require("../menubuilder");

FastaExporter = require("biojs-io-fasta").writer;

_ = require("underscore");

Exporter = require("../../utils/export");

module.exports = ExportMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.msa = data.msa;
    return this.el.style.display = "inline-block";
  },
  render: function() {
    this.setName("Export");
    this.addNode("View in Jalview", (function(_this) {
      return function() {
        var url;
        url = _this.g.config.get('url');
        if (url == null) {
          return alert("Sequence weren't imported via an URL");
        } else {
          if (url.indexOf("localhost" || url === "dragimport")) {
            return Exporter.publishWeb(_this.msa, function(link) {
              return Exporter.openInJalview(link, _this.g.colorscheme.get("scheme"));
            });
          } else {
            return Exporter.openInJalview(url, _this.g.colorscheme.get("scheme"));
          }
        }
      };
    })(this));
    this.addNode("Publish to the web", (function(_this) {
      return function() {
        return Exporter.publishWeb(_this.msa, function(link) {
          return window.open(link, '_blank');
        });
      };
    })(this));
    this.addNode("Share link", (function(_this) {
      return function() {
        return Exporter.shareLink(_this.msa, function(link) {
          return window.open(link, '_blank');
        });
      };
    })(this));
    this.addNode("Export sequences", (function(_this) {
      return function() {
        return Exporter.saveAsFile(_this.msa, "all.fasta");
      };
    })(this));
    this.addNode("Export selection", (function(_this) {
      return function() {
        return Exporter.saveSelection(_this.msa, "selection.fasta");
      };
    })(this));
    this.addNode("Export features", (function(_this) {
      return function() {
        return Exporter.saveAnnots(_this.msa, "features.gff3");
      };
    })(this));
    this.addNode("Export image", (function(_this) {
      return function() {
        return Exporter.saveAsImg(_this.msa, "biojs-msa.png");
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../../utils/export":129,"../menubuilder":111,"biojs-io-fasta":"biojs-io-fasta","underscore":91}],115:[function(require,module,exports){
var ExtraMenu, Loader, MenuBuilder, Seq, xhr;

MenuBuilder = require("../menubuilder");

Seq = require("../../model/Sequence");

Loader = require("../../utils/loader");

xhr = require("xhr");

module.exports = ExtraMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.msa = data.msa;
  },
  render: function() {
    var msa, stats;
    this.setName("Extras");
    stats = this.g.stats;
    msa = this.msa;
    this.addNode("Add consensus seq", (function(_this) {
      return function() {
        var con, seq;
        con = stats.consensus();
        seq = new Seq({
          seq: con,
          id: "0c",
          name: "consenus"
        });
        _this.model.add(seq);
        _this.model.setRef(seq);
        _this.model.comparator = function(seq) {
          return !seq.get("ref");
        };
        return _this.model.sort();
      };
    })(this));
    this.addNode("Calc Tree", function() {
      var cbs, newickStr, nwkData;
      newickStr = "";
      cbs = Loader.joinCb(function() {
        return msa.u.tree.showTree(nwkData);
      }, 2, this);
      msa.u.tree.loadTree(cbs);
      nwkData = {
        name: "root",
        children: [
          {
            name: "c1",
            branch_length: 4,
            children: msa.seqs.filter(function(f, i) {
              return i % 2 === 0;
            })
          }, {
            name: "c2",
            children: msa.seqs.filter(function(f, i) {
              return i % 2 === 1;
            }),
            branch_length: 4
          }
        ]
      };
      msa.seqs.each(function(s) {
        return s.set("branch_length", 2);
      });
      return cbs();
    });
    this.addNode("Increase font size", (function(_this) {
      return function() {
        var columnWidth, nColumnWidth, nFontSize;
        columnWidth = _this.g.zoomer.get("columnWidth");
        nColumnWidth = columnWidth + 5;
        _this.g.zoomer.set("columnWidth", nColumnWidth);
        _this.g.zoomer.set("rowHeight", nColumnWidth);
        nFontSize = nColumnWidth * 0.7;
        _this.g.zoomer.set("residueFont", nFontSize);
        return _this.g.zoomer.set("labelFontSize", nFontSize);
      };
    })(this));
    this.addNode("Decrease font size", (function(_this) {
      return function() {
        var columnWidth, nColumnWidth, nFontSize;
        columnWidth = _this.g.zoomer.get("columnWidth");
        nColumnWidth = columnWidth - 2;
        _this.g.zoomer.set("columnWidth", nColumnWidth);
        _this.g.zoomer.set("rowHeight", nColumnWidth);
        nFontSize = nColumnWidth * 0.6;
        _this.g.zoomer.set("residueFont", nFontSize);
        _this.g.zoomer.set("labelFontSize", nFontSize);
        if (_this.g.zoomer.get("columnWidth") < 8) {
          return _this.g.zoomer.set("textVisible", false);
        }
      };
    })(this));
    this.addNode("Minimized width", (function(_this) {
      return function() {
        return _this.g.zoomer.set("alignmentWidth", 600);
      };
    })(this));
    this.addNode("Minimized height", (function(_this) {
      return function() {
        return _this.g.zoomer.set("alignmentHeight", 120);
      };
    })(this));
    this.addNode("Jump to a column", (function(_this) {
      return function() {
        var offset;
        offset = prompt("Column", "20");
        if (offset < 0 || offset > _this.model.getMaxLength() || isNaN(offset)) {
          alert("invalid column");
          return;
        }
        return _this.g.zoomer.setLeftOffset(offset);
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../../model/Sequence":125,"../../utils/loader":132,"../menubuilder":111,"xhr":"xhr"}],116:[function(require,module,exports){
var FilterMenu, MenuBuilder, _;

MenuBuilder = require("../menubuilder");

_ = require("underscore");

module.exports = FilterMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function() {
    this.setName("Filter");
    this.addNode("Hide columns by threshold", (function(_this) {
      return function(e) {
        var conserv, hidden, i, j, maxLen, ref, threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        hidden = [];
        conserv = _this.g.stats.scale(_this.g.stats.conservation());
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (conserv[i] < threshold) {
            hidden.push(i);
          }
        }
        return _this.g.columns.set("hidden", hidden);
      };
    })(this));
    this.addNode("Hide columns by selection", (function(_this) {
      return function() {
        var hidden, hiddenOld;
        hiddenOld = _this.g.columns.get("hidden");
        hidden = hiddenOld.concat(_this.g.selcol.getAllColumnBlocks({
          maxLen: _this.model.getMaxLength(),
          withPos: true
        }));
        _this.g.selcol.reset([]);
        return _this.g.columns.set("hidden", hidden);
      };
    })(this));
    this.addNode("Hide columns by gaps", (function(_this) {
      return function() {
        var gapContent, gaps, hidden, i, j, maxLen, ref, threshold, total;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        hidden = [];
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          gaps = 0;
          total = 0;
          _this.model.each(function(el) {
            if (el.get('seq')[i] === "-") {
              gaps++;
            }
            return total++;
          });
          gapContent = gaps / total;
          if (gapContent > threshold) {
            hidden.push(i);
          }
        }
        return _this.g.columns.set("hidden", hidden);
      };
    })(this));
    this.addNode("Hide seqs by identity", (function(_this) {
      return function() {
        var threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        return _this.model.each(function(el) {
          if (el.get('identity') < threshold) {
            return el.set('hidden', true);
          }
        });
      };
    })(this));
    this.addNode("Hide seqs by selection", (function(_this) {
      return function() {
        var hidden, ids;
        hidden = _this.g.selcol.where({
          type: "row"
        });
        ids = _.map(hidden, function(el) {
          return el.get('seqId');
        });
        _this.g.selcol.reset([]);
        return _this.model.each(function(el) {
          if (ids.indexOf(el.get('id')) >= 0) {
            return el.set('hidden', true);
          }
        });
      };
    })(this));
    this.addNode("Hide seqs by gaps", (function(_this) {
      return function() {
        var threshold;
        threshold = prompt("Enter threshold (in percent)", 40);
        return _this.model.each(function(el, i) {
          var gaps, seq;
          seq = el.get('seq');
          gaps = _.reduce(seq, (function(memo, c) {
            if (c === '-') {
              memo++;
            }
            return memo;
          }), 0);
          if (gaps > threshold) {
            return el.set('hidden', true);
          }
        });
      };
    })(this));
    this.addNode("Reset", (function(_this) {
      return function() {
        _this.g.columns.set("hidden", []);
        return _this.model.each(function(el) {
          if (el.get('hidden')) {
            return el.set('hidden', false);
          }
        });
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../menubuilder":111,"underscore":91}],117:[function(require,module,exports){
var HelpMenu, MenuBuilder;

MenuBuilder = require("../menubuilder");

module.exports = HelpMenu = MenuBuilder.extend({
  initialize: function(data) {
    return this.g = data.g;
  },
  render: function() {
    this.setName("Help");
    this.addNode("About the project", (function(_this) {
      return function() {
        return window.open("https://github.com/greenify/msa");
      };
    })(this));
    this.addNode("Report issues", (function(_this) {
      return function() {
        return window.open("https://github.com/greenify/msa/issues");
      };
    })(this));
    this.addNode("User manual", (function(_this) {
      return function() {
        return window.open("https://github.com/greenify/msa/wiki");
      };
    })(this));
    this.el.style.display = "inline-block";
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../menubuilder":111}],118:[function(require,module,exports){
var ImportMenu, MenuBuilder, k;

MenuBuilder = require("../menubuilder");

k = require("koala-js");

module.exports = ImportMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.msa = data.msa;
  },
  render: function() {
    var msa, uploader;
    msa = this.msa;
    uploader = k.mk("input");
    uploader.type = "file";
    uploader.style.display = "none";
    uploader.multiple = true;
    uploader.addEventListener("change", function() {
      var files;
      files = uploader.files || [];
      return msa.u.file.importFiles(files);
    });
    this.el.appendChild(uploader);
    this.setName("Import");
    this.addNode("URL", (function(_this) {
      return function(e) {
        var url;
        url = prompt("URL", "http://rostlab.org/~goldberg/clustalw2-I20140818-215249-0556-53699878-pg.clustalw");
        return _this.msa.u.file.importURL(url, function() {});
      };
    })(this));
    this.addNode("From file", (function(_this) {
      return function() {
        return uploader.click();
      };
    })(this));
    this.addNode("Drag & Drop", (function(_this) {
      return function() {
        return alert("Yep. Just drag & drop your file");
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../menubuilder":111,"koala-js":68}],119:[function(require,module,exports){
var MenuBuilder, OrderingMenu, _, dom;

MenuBuilder = require("../menubuilder");

dom = require("dom-helper");

_ = require('underscore');

module.exports = OrderingMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.order = "ID";
    return this.el.style.display = "inline-block";
  },
  setOrder: function(order) {
    this.order = order;
    return this.render();
  },
  render: function() {
    var comps, el, i, len, m;
    this.setName("Ordering");
    this.removeAllNodes();
    comps = this.getComparators();
    for (i = 0, len = comps.length; i < len; i++) {
      m = comps[i];
      this._addNode(m);
    }
    el = this.buildDOM();
    dom.removeAllChilds(this.el);
    this.el.appendChild(el);
    return this;
  },
  _addNode: function(m) {
    var style, text;
    text = m.text;
    style = {};
    if (text === this.order) {
      style.backgroundColor = "#77ED80";
    }
    return this.addNode(text, (function(_this) {
      return function() {
        if (m.precode != null) {
          m.precode();
        }
        _this.model.comparator = m.comparator;
        _this.model.sort();
        return _this.setOrder(m.text);
      };
    })(this), {
      style: style
    });
  },
  getComparators: function() {
    var models, setIdent;
    models = [];
    models.push({
      text: "ID",
      comparator: "id"
    });
    models.push({
      text: "ID Desc",
      comparator: function(a, b) {
        return -("" + a.get("id")).localeCompare("" + b.get("id"), [], {
          numeric: true
        });
      }
    });
    models.push({
      text: "Label",
      comparator: "name"
    });
    models.push({
      text: "Label Desc",
      comparator: function(a, b) {
        return -a.get("name").localeCompare(b.get("name"));
      }
    });
    models.push({
      text: "Seq",
      comparator: "seq"
    });
    models.push({
      text: "Seq Desc",
      comparator: function(a, b) {
        return -a.get("seq").localeCompare(b.get("seq"));
      }
    });
    setIdent = (function(_this) {
      return function() {
        return _this.ident = _this.g.stats.identity();
      };
    })(this);
    models.push({
      text: "Identity",
      comparator: (function(_this) {
        return function(a, b) {
          var val;
          val = _this.ident[a.id] - _this.ident[b.id];
          if (val > 0) {
            return 1;
          }
          if (val < 0) {
            return -1;
          }
          return 0;
        };
      })(this),
      precode: setIdent
    });
    models.push({
      text: "Identity Desc",
      comparator: (function(_this) {
        return function(a, b) {
          var val;
          val = _this.ident[a.id] - _this.ident[b.id];
          if (val > 0) {
            return -1;
          }
          if (val < 0) {
            return 1;
          }
          return 0;
        };
      })(this),
      precode: setIdent
    });
    models.push({
      text: "Reference",
      comparator: function(seq) {
        return !seq.get("ref");
      }
    });
    models.push({
      text: "Partition codes",
      comparator: "partition",
      precode: (function(_this) {
        return function() {
          _this.g.vis.set('labelPartition', true);
          return _this.model.each(function(el) {
            return el.set('partition', _.random(1, 3));
          });
        };
      })(this)
    });
    return models;
  }
});



},{"../menubuilder":111,"dom-helper":66,"underscore":91}],120:[function(require,module,exports){
var MenuBuilder, SelectionMenu;

MenuBuilder = require("../menubuilder");

module.exports = SelectionMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function() {
    this.setName("Selection");
    this.addNode("Find Motif (supports RegEx)", (function(_this) {
      return function() {
        var search;
        search = prompt("your search", "D");
        return _this.g.user.set("searchText", search);
      };
    })(this));
    this.addNode("Invert columns", (function(_this) {
      return function() {
        var i, ref, results;
        return _this.g.selcol.invertCol((function() {
          results = [];
          for (var i = 0, ref = _this.model.getMaxLength(); 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this));
      };
    })(this));
    this.addNode("Invert rows", (function(_this) {
      return function() {
        return _this.g.selcol.invertRow(_this.model.pluck("id"));
      };
    })(this));
    this.addNode("Reset", (function(_this) {
      return function() {
        return _this.g.selcol.reset();
      };
    })(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});



},{"../menubuilder":111}],121:[function(require,module,exports){
var MenuBuilder, VisMenu, dom;

MenuBuilder = require("../menubuilder");

dom = require("dom-helper");

module.exports = VisMenu = MenuBuilder.extend({
  initialize: function(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.listenTo(this.g.vis, "change", this.render);
  },
  render: function() {
    var i, len, visEl, visElements;
    this.removeAllNodes();
    this.setName("Vis.elements");
    visElements = this.getVisElements();
    for (i = 0, len = visElements.length; i < len; i++) {
      visEl = visElements[i];
      this._addVisEl(visEl);
    }
    this.addNode("Reset", (function(_this) {
      return function() {
        _this.g.vis.set("labels", true);
        _this.g.vis.set("sequences", true);
        _this.g.vis.set("metacell", true);
        _this.g.vis.set("conserv", true);
        _this.g.vis.set("labelId", true);
        _this.g.vis.set("labelName", true);
        _this.g.vis.set("labelCheckbox", false);
        _this.g.vis.set("seqlogo", false);
        _this.g.vis.set("gapHeader", false);
        _this.g.vis.set("leftHeader", true);
        _this.g.vis.set("metaGaps", true);
        _this.g.vis.set("metaIdentity", true);
        return _this.g.vis.set("metaLinks", true);
      };
    })(this));
    dom.removeAllChilds(this.el);
    this.el.appendChild(this.buildDOM());
    return this;
  },
  _addVisEl: function(visEl) {
    var pre, style;
    style = {};
    if (this.g.vis.get(visEl.id)) {
      pre = "Hide ";
      style.color = "red";
    } else {
      pre = "Show ";
      style.color = "green";
    }
    return this.addNode(pre + visEl.name, (function(_this) {
      return function() {
        return _this.g.vis.set(visEl.id, !_this.g.vis.get(visEl.id));
      };
    })(this), {
      style: style
    });
  },
  getVisElements: function() {
    var vis;
    vis = [];
    vis.push({
      name: "Markers",
      id: "markers"
    });
    vis.push({
      name: "Labels",
      id: "labels"
    });
    vis.push({
      name: "Meta info",
      id: "metacell"
    });
    vis.push({
      name: "Overviewbox",
      id: "overviewbox"
    });
    vis.push({
      name: "Conserv",
      id: "conserv"
    });
    vis.push({
      name: "Seq. logo",
      id: "seqlogo"
    });
    vis.push({
      name: "Gap Header",
      id: "gapHeader"
    });
    vis.push({
      name: "Left header",
      id: "leftHeader"
    });
    vis.push({
      name: "Label name",
      id: "labelName"
    });
    vis.push({
      name: "Label id",
      id: "labelId"
    });
    vis.push({
      name: "Label checkbox",
      id: "labelCheckbox"
    });
    vis.push({
      name: "Meta gaps",
      id: "metaGaps"
    });
    vis.push({
      name: "Meta identity",
      id: "metaIdentity"
    });
    vis.push({
      name: "Meta links",
      id: "metaLinks"
    });
    return vis;
  }
});



},{"../menubuilder":111,"dom-helper":66}],122:[function(require,module,exports){
var Feature, Model;

Feature = require("./Feature");

Model = require("backbone-thin").Model;

module.exports = Feature = Model.extend({
  defaults: {
    xStart: -1,
    xEnd: -1,
    height: -1,
    text: "",
    fillColor: "red",
    fillOpacity: 0.5,
    type: "rectangle",
    borderSize: 1,
    borderColor: "black",
    borderOpacity: 0.5,
    validate: true,
    row: 0
  },
  initialize: function(obj) {
    if (obj.start != null) {
      this.set("xStart", obj.start);
    }
    if (obj.end != null) {
      this.set("xEnd", obj.end);
    }
    if (obj.attributes != null) {
      if (obj.attributes.Name != null) {
        this.set("text", obj.attributes.Name);
      }
      if (obj.attributes.Color != null) {
        this.set("fillColor", obj.attributes.Color);
      }
    }
    if (this.attributes.xEnd < this.attributes.xStart) {
      console.warn("invalid feature range for", this.attributes);
    }
    if (!_.isNumber(this.attributes.xStart) || !_.isNumber(this.attributes.xEnd)) {
      console.warn("please provide numeric feature ranges", obj);
      this.set("xStart", parseInt(this.attributes.xStart));
      return this.set("xEnd", parseInt(this.attributes.xEnd));
    }
  },
  validate: function() {
    if (isNaN(this.attributes.xStart || isNaN(this.attributes.xEnd))) {
      return "features need integer start and end.";
    }
  },
  contains: function(index) {
    return this.attributes.xStart <= index && index <= this.attributes.xEnd;
  }
});



},{"./Feature":122,"backbone-thin":4}],123:[function(require,module,exports){
var Collection, Feature, FeatureCol, _;

Feature = require("./Feature");

Collection = require("backbone-thin").Collection;

_ = require("underscore");

module.exports = FeatureCol = Collection.extend({
  model: Feature,
  constructor: function() {
    this.startOnCache = [];
    this.on("all", function() {
      return this.startOnCache = [];
    }, this);
    return Collection.apply(this, arguments);
  },
  startOn: function(index) {
    if (this.startOnCache[index] == null) {
      this.startOnCache[index] = this.where({
        xStart: index
      });
    }
    return this.startOnCache[index];
  },
  contains: function(index) {
    return this.reduce(function(el, memo) {
      return memo || el.contains(index);
    }, false);
  },
  getFeatureOnRow: function(row, x) {
    return this.filter(function(el) {
      return el.get("row") === row && el.get("xStart") <= x && x <= el.get("xEnd");
    });
  },
  assignRows: function() {
    var len, rows, x;
    len = (this.max(function(el) {
      return el.get("xEnd");
    })).attributes.xEnd;
    rows = (function() {
      var i, ref, results;
      results = [];
      for (x = i = 0, ref = len; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    })();
    this.each(function(el) {
      var i, max, ref, ref1;
      max = 0;
      for (x = i = ref = el.get("xStart"), ref1 = el.get("xEnd"); i <= ref1; x = i += 1) {
        if (rows[x] > max) {
          max = rows[x];
        }
        rows[x]++;
      }
      return el.set("row", max);
    });
    return _.max(rows);
  },
  getCurrentHeight: function() {
    return (this.max(function(el) {
      return el.get("row");
    })).attributes.row + 1;
  },
  getMinRows: function() {
    var len, rows, x;
    len = (this.max(function(el) {
      return el.get("xEnd");
    })).attributes.xEnd;
    rows = (function() {
      var i, ref, results;
      results = [];
      for (x = i = 0, ref = len; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    })();
    this.each(function(el) {
      var i, ref, ref1, results;
      results = [];
      for (x = i = ref = el.get("xStart"), ref1 = el.get("xEnd"); i <= ref1; x = i += 1) {
        results.push(rows[x]++);
      }
      return results;
    });
    return _.max(rows);
  }
});



},{"./Feature":122,"backbone-thin":4,"underscore":91}],124:[function(require,module,exports){
var Collection, FeatureCol, SeqManager, Sequence;

Sequence = require("./Sequence");

FeatureCol = require("./FeatureCol");

Collection = require("backbone-thin").Collection;

module.exports = SeqManager = Collection.extend({
  model: Sequence,
  constructor: function(seqs, g) {
    Collection.apply(this, arguments);
    this.g = g;
    this.on("add reset remove", (function(_this) {
      return function() {
        _this.lengthCache = null;
        return _this._bindSeqsWithFeatures();
      };
    })(this), this);
    this.on("reset", (function(_this) {
      return function() {
        return _this._autoSetRefSeq();
      };
    })(this));
    this._autoSetRefSeq();
    this.lengthCache = null;
    this.features = {};
    return this;
  },
  getMaxLength: function() {
    if (this.models.length === 0) {
      return 0;
    }
    if (this.lengthCache === null) {
      this.lengthCache = this.max(function(seq) {
        return seq.get("seq").length;
      }).get("seq").length;
    }
    return this.lengthCache;
  },
  prev: function(model, endless) {
    var index;
    index = this.indexOf(model) - 1;
    if (index < 0 && endless) {
      index = this.length - 1;
    }
    return this.at(index);
  },
  next: function(model, endless) {
    var index;
    index = this.indexOf(model) + 1;
    if (index === this.length && endless) {
      index = 0;
    }
    return this.at(index);
  },
  calcHiddenSeqs: function(n) {
    var i, j, nNew, ref;
    nNew = n;
    for (i = j = 0, ref = nNew; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this.at(i).get("hidden")) {
        nNew++;
      }
    }
    return nNew - n;
  },
  addFeatures: function(features) {
    var colors, obj;
    if (features.config != null) {
      obj = features;
      features = features.seqs;
      if (obj.config.colors != null) {
        colors = obj.config.colors;
        _.each(features, function(seq) {
          return _.each(seq, function(val) {
            if (colors[val.feature] != null) {
              return val.fillColor = colors[val.feature];
            }
          });
        });
      }
    }
    if (_.isEmpty(this.features)) {
      this.features = features;
    } else {
      _.each(features, (function(_this) {
        return function(val, key) {
          if (!_this.features.hasOwnProperty(key)) {
            return _this.features[key] = val;
          } else {
            return _this.features[key] = _.union(_this.features[key], val);
          }
        };
      })(this));
    }
    return this._bindSeqsWithFeatures();
  },
  _bindSeqWithFeatures: function(seq) {
    var features;
    features = this.features[seq.attributes.name];
    if (features) {
      seq.set("features", new FeatureCol(features));
      seq.attributes.features.assignRows();
      return seq.set("height", seq.attributes.features.getCurrentHeight() + 1);
    }
  },
  _bindSeqsWithFeatures: function() {
    return this.each((function(_this) {
      return function(seq) {
        return _this._bindSeqWithFeatures(seq);
      };
    })(this));
  },
  removeAllFeatures: function() {
    return delete this.features;
  },
  _autoSetRefSeq: function() {
    if (this.length > 0) {
      return this.at(0).set("ref", true);
    }
  },
  setRef: function(seq) {
    var obj;
    obj = this.get(seq);
    this.each(function(s) {
      if (seq.cid) {
        if (obj.cid === s.cid) {
          return s.set("ref", true);
        } else {
          return s.set("ref", false);
        }
      }
    });
    this.g.config.set("hasRef", true);
    return this.trigger("change:reference", seq);
  }
});



},{"./FeatureCol":123,"./Sequence":125,"backbone-thin":4}],125:[function(require,module,exports){
var FeatureCol, Model, Sequence;

Model = require("backbone-thin").Model;

FeatureCol = require("./FeatureCol");

module.exports = Sequence = Model.extend({
  defaults: {
    name: "",
    id: "",
    seq: "",
    height: 1,
    ref: false
  },
  initialize: function() {
    this.set("grey", []);
    if (this.get("features") == null) {
      return this.set("features", new FeatureCol());
    }
  }
});



},{"./FeatureCol":123,"backbone-thin":4}],126:[function(require,module,exports){
module.exports.seq = require("./Sequence");

module.exports.seqcol = require("./SeqCollection");

module.exports.feature = require("./Feature");

module.exports.featurecol = require("./FeatureCol");



},{"./Feature":122,"./FeatureCol":123,"./SeqCollection":124,"./Sequence":125}],127:[function(require,module,exports){
var $, Colorator, Columns, Config, Eventhandler, FileHelper, Package, ProxyHelper, SelCol, SeqCollection, Stage, Stats, TreeHelper, User, VisOrdering, Visibility, Zoomer, boneView;

SeqCollection = require("./model/SeqCollection");

Colorator = require("./g/colorscheme");

Columns = require("./g/columns");

Config = require("./g/config");

Package = require("./g/package");

SelCol = require("./g/selection/SelectionCol");

User = require("./g/user");

Visibility = require("./g/visibility");

VisOrdering = require("./g/visOrdering");

Zoomer = require("./g/zoomer");

boneView = require("backbone-childs");

Eventhandler = require("biojs-events");

Stage = require("./views/Stage");

Stats = require("stat.seqs");

$ = require("jbone");

FileHelper = require("./utils/file");

TreeHelper = require("./utils/tree");

ProxyHelper = require("./utils/proxy");

module.exports = boneView.extend({
  initialize: function(data) {
    var defMenu, events, menuDiv, pureSeq, ref, wrapperDiv;
    if (data == null) {
      data = {};
    }
    if (data.colorscheme == null) {
      data.colorscheme = {};
    }
    if (data.columns == null) {
      data.columns = {};
    }
    if (data.conf == null) {
      data.conf = {};
    }
    if (data.vis == null) {
      data.vis = {};
    }
    if (data.zoomer == null) {
      if (!((ref = data.visorder) != null ? ref : data.zoomer = {})) {
        data.visorder = {};
      }
    }
    this.g = Eventhandler.mixin({});
    this.seqs = new SeqCollection(data.seqs, this.g);
    this.g.config = new Config(data.conf);
    this.g["package"] = new Package(this.g);
    this.g.selcol = new SelCol([], {
      g: this.g
    });
    this.g.user = new User();
    this.g.vis = new Visibility(data.vis, {
      model: this.seqs
    });
    this.g.visorder = new VisOrdering(data.visorder);
    this.g.zoomer = new Zoomer(data.zoomer, {
      g: this.g,
      model: this.seqs
    });
    if (window.location.hostname === "localhost") {
      this.g.config.set("debug", true);
    }
    pureSeq = this.seqs.pluck("seq");
    this.g.stats = new Stats(this.seqs);
    this.g.stats.alphabetSize = this.g.config.get("alphabetSize");
    this.g.columns = new Columns(data.columns, this.g.stats);
    this.g.colorscheme = new Colorator(data.colorscheme, pureSeq, this.g.stats);
    this.g.zoomer.setEl(this.el, this.seqs);
    this.addView("stage", new Stage({
      model: this.seqs,
      g: this.g
    }));
    this.el.setAttribute("class", "biojs_msa_div");
    this.u = {};
    this.u.file = new FileHelper(this);
    this.u.proxy = new ProxyHelper({
      g: this.g
    });
    this.u.tree = new TreeHelper(this);
    if (this.g.config.get("eventBus") === true) {
      this.startEventBus();
    }
    if (this.g.config.get("dropImport")) {
      events = {
        "dragover": this.dragOver,
        "drop": this.dropFile
      };
      this.delegateEvents(events);
    }
    if (data.importURL) {
      this.u.file.importURL(data.importURL, (function(_this) {
        return function() {
          return _this.render();
        };
      })(this));
    }
    if (data.bootstrapMenu) {
      menuDiv = document.createElement('div');
      wrapperDiv = document.createElement('div');
      if (!this.el.parentNode) {
        wrapperDiv.appendChild(menuDiv);
        wrapperDiv.appendChild(this.el);
      } else {
        this.el.parentNode.replaceChild(wrapperDiv, this.el);
        wrapperDiv.appendChild(menuDiv);
        wrapperDiv.appendChild(this.el);
      }
      defMenu = new msa.menu.defaultmenu({
        el: menuDiv,
        msa: this
      });
      defMenu.render();
    }
    return $(window).on("resize", (function(_this) {
      return function(e) {
        var f;
        f = function() {
          return this.g.zoomer.autoResize();
        };
        return setTimeout(f.bind(_this), 5);
      };
    })(this));
  },
  dragOver: function(e) {
    e.preventDefault();
    e.target.className = 'hover';
    return false;
  },
  dropFile: function(e) {
    var files;
    e.preventDefault();
    files = e.target.files || e.dataTransfer.files;
    this.u.file.importFiles(files);
    return false;
  },
  startEventBus: function() {
    var busObjs, i, key, len, results;
    busObjs = ["config", "columns", "colorscheme", "selcol", "vis", "visorder", "zoomer"];
    results = [];
    for (i = 0, len = busObjs.length; i < len; i++) {
      key = busObjs[i];
      results.push(this._proxyToG(key));
    }
    return results;
  },
  _proxyToG: function(key) {
    return this.listenTo(this.g[key], "all", function(name, prev, now, opts) {
      if (name === "change") {
        return;
      }
      if (opts != null) {
        return this.g.trigger(key + ":" + name, now, prev, opts);
      } else {
        return this.g.trigger(key + ":" + name, now, prev);
      }
    });
  },
  render: function() {
    if (this.seqs === void 0 || this.seqs.length === 0) {
      console.log("warning. empty seqs.");
    }
    this.renderSubviews();
    this.g.vis.set("loaded", true);
    return this;
  }
});



},{"./g/colorscheme":98,"./g/columns":99,"./g/config":100,"./g/package":101,"./g/selection/SelectionCol":103,"./g/user":104,"./g/visOrdering":105,"./g/visibility":106,"./g/zoomer":107,"./model/SeqCollection":124,"./utils/file":130,"./utils/proxy":133,"./utils/tree":136,"./views/Stage":140,"backbone-childs":2,"biojs-events":13,"jbone":67,"stat.seqs":90}],128:[function(require,module,exports){
var BMath;

module.exports = BMath = (function() {
  function BMath() {}

  BMath.randomInt = function(lower, upper) {
    var ref, ref1;
    if (upper == null) {
      ref = [0, lower], lower = ref[0], upper = ref[1];
    }
    if (lower > upper) {
      ref1 = [upper, lower], lower = ref1[0], upper = ref1[1];
    }
    return Math.floor(Math.random() * (upper - lower + 1) + lower);
  };

  BMath.uniqueId = function(length) {
    var id;
    if (length == null) {
      length = 8;
    }
    id = "";
    while (id.length < length) {
      id += Math.random().toString(36).substr(2);
    }
    return id.substr(0, length);
  };

  BMath.getRandomInt = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  return BMath;

})();



},{}],129:[function(require,module,exports){
var Exporter, Fasta, GFF, _, blobURL, saveAs, xhr;

Fasta = require("biojs-io-fasta");

GFF = require("biojs-io-gff");

xhr = require("xhr");

blobURL = require("blueimp_canvastoblob");

saveAs = require("browser-saveas");

_ = require("underscore");

module.exports = Exporter = {
  openInJalview: function(url, colorscheme) {
    var host, jalviewUrl;
    if (url.charAt(0) === '.') {
      url = document.URL.substr(0, document.URL.lastIndexOf('/')) + "/" + url;
    }
    if (url.indexOf("http") < 0) {
      host = "http://" + window.location.hostname;
      url = host + url;
    }
    url = encodeURIComponent(url);
    jalviewUrl = "http://www.jalview.org/services/launchApp?open=" + url;
    jalviewUrl += "&colour=" + colorscheme;
    return window.open(jalviewUrl, '_blank');
  },
  publishWeb: function(that, cb) {
    var text, url;
    text = Fasta.write(that.seqs.toJSON());
    text = encodeURIComponent(text);
    url = that.u.proxy.corsURL("http://sprunge.biojs.net");
    return xhr({
      method: "POST",
      body: "sprunge=" + text,
      uri: url,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      }
    }, function(err, rep, body) {
      var link;
      link = body.trim();
      return cb(link);
    });
  },
  shareLink: function(that, cb) {
    var fCB, msaURL, url;
    url = that.g.config.get("importURL");
    msaURL = "http://biojs-msa.org/app/?seq=";
    fCB = function(link) {
      var fURL;
      fURL = msaURL + link;
      if (cb) {
        return cb(fURL);
      }
    };
    if (!url) {
      return Exporter.publishWeb(that, fCB);
    } else {
      return fCB(url);
    }
  },
  saveAsFile: function(that, name) {
    var blob, text;
    text = Fasta.write(that.seqs.toJSON());
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveSelection: function(that, name) {
    var blob, i, j, ref, selection, text;
    selection = that.g.selcol.pluck("seqId");
    console.log(selection);
    if (selection.length > 0) {
      selection = that.seqs.filter(function(el) {
        return _.contains(selection, el.get("id"));
      });
      for (i = j = 0, ref = selection.length - 1; j <= ref; i = j += 1) {
        selection[i] = selection[i].toJSON();
      }
    } else {
      selection = that.seqs.toJSON();
      console.warn("no selection found");
    }
    text = Fasta.write(selection);
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveAnnots: function(that, name) {
    var blob, features, text;
    features = that.seqs.map(function(el) {
      var seqname;
      features = el.get("features");
      if (features.length === 0) {
        return;
      }
      seqname = el.get("name");
      features.each(function(s) {
        return s.set("seqname", seqname);
      });
      return features.toJSON();
    });
    features = _.flatten(_.compact(features));
    console.log(features);
    text = GFF.exportLines(features);
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveAsImg: function(that, name) {
    var canvas, url;
    canvas = that.getView('stage').getView('body').getView('seqblock').el;
    if (canvas != null) {
      url = canvas.toDataURL('image/png');
      return saveAs(blobURL(url), name, "image/png");
    }
  }
};



},{"biojs-io-fasta":"biojs-io-fasta","biojs-io-gff":"biojs-io-gff","blueimp_canvastoblob":62,"browser-saveas":63,"underscore":91,"xhr":"xhr"}],130:[function(require,module,exports){
var ClustalReader, FastaReader, FileHelper, GffReader, _, funs, xhr;

FastaReader = require("biojs-io-fasta");

ClustalReader = require("biojs-io-clustal");

GffReader = require("biojs-io-gff");

_ = require("underscore");

xhr = require("xhr");

module.exports = FileHelper = function(msa) {
  this.msa = msa;
  return this;
};

funs = {
  guessFileType: function(name) {
    var fileName;
    name = name.split(".");
    fileName = name[name.length(-1)];
    switch (fileName) {
      case "aln":
      case "clustal":
        return ClustalReader;
      case "fasta":
        return FastaReader;
      default:
        return FastaReader;
    }
  },
  guessFileFromText: function(text) {
    var reader, type;
    if (text == null) {
      console.warn("invalid file format");
      return ["", "error"];
    }
    if (text.substring(0, 7) === "CLUSTAL") {
      reader = ClustalReader;
      type = "seqs";
    } else if (text.substring(0, 1) === ">") {
      reader = FastaReader;
      type = "seqs";
    } else if (text.substring(0, 1) === "(") {
      type = "newick";
    } else {
      reader = GffReader;
      type = "features";
    }
    return [reader, type];
  },
  parseText: function(text) {
    var features, reader, ref, seqs, type;
    ref = this.guessFileFromText(text), reader = ref[0], type = ref[1];
    if (type === "seqs") {
      seqs = reader.parse(text);
      return [seqs, type];
    } else if (type === "features") {
      features = reader.parseSeqs(text);
      return [features, type];
    } else {
      return [text, type];
    }
  },
  importFiles: function(files) {
    var file, i, j, reader, ref, results;
    results = [];
    for (i = j = 0, ref = files.length - 1; j <= ref; i = j += 1) {
      file = files[i];
      reader = new FileReader();
      reader.onload = (function(_this) {
        return function(evt) {
          return _this.importFile(evt.target.result);
        };
      })(this);
      results.push(reader.readAsText(file));
    }
    return results;
  },
  importFile: function(file) {
    var fileName, objs, ref, type;
    ref = this.parseText(file), objs = ref[0], type = ref[1];
    if (type === "error") {
      return "error";
    }
    if (type === "seqs") {
      this.msa.seqs.reset(objs);
      this.msa.g.config.set("url", "userimport");
      this.msa.g.trigger("url:userImport");
    } else if (type === "features") {
      this.msa.seqs.addFeatures(objs);
    } else if (type === "newick") {
      this.msa.u.tree.loadTree((function(_this) {
        return function() {
          return _this.msa.u.tree.showTree(file);
        };
      })(this));
    }
    return fileName = file.name;
  },
  importURL: function(url, cb) {
    url = this.msa.u.proxy.corsURL(url);
    this.msa.g.config.set("url", url);
    return xhr(url, (function(_this) {
      return function(err, status, body) {
        var res;
        if (!err) {
          res = _this.importFile(body);
          if (res === "error") {
            return;
          }
          _this.msa.g.trigger("import:url", url);
          if (cb) {
            return cb();
          }
        } else {
          return console.log(err);
        }
      };
    })(this));
  }
};

_.extend(FileHelper.prototype, funs);



},{"biojs-io-clustal":"biojs-io-clustal","biojs-io-fasta":"biojs-io-fasta","biojs-io-gff":"biojs-io-gff","underscore":91,"xhr":"xhr"}],131:[function(require,module,exports){
module.exports.bmath = require("./bmath");

module.exports.proxy = require("./proxy");

module.exports.seqgen = require("./seqgen");

module.exports.file = require("./file");

module.exports["export"] = require("./export");



},{"./bmath":128,"./export":129,"./file":130,"./proxy":133,"./seqgen":134}],132:[function(require,module,exports){
var k, loader,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

k = require("koala-js");

module.exports = loader = {
  loadScript: function(url, cb) {
    var s, t;
    s = k.mk("script");
    s.type = "text/javascript";
    s.src = url;
    s.async = true;
    s.onload = s.onreadystatechange = function() {
      var r;
      if (!r && (!this.readyState || this.readyState === "complete")) {
        r = true;
        return cb();
      }
    };
    t = document.getElementsByTagName("script")[0];
    return t.parentNode.appendChild(s);
  },
  joinCb: function(retCb, finalLength, finalScope) {
    var callbackWrapper, cbsFinished, counter;
    finalLength = finalLength || 1;
    cbsFinished = 0;
    callbackWrapper = function(cb, scope) {
      if (cb == null) {
        return counter();
      } else {
        return function() {
          if (indexOf.call(cb, "apply") >= 0) {
            cb.apply(scope, arguments);
          }
          return counter();
        };
      }
    };
    counter = function() {
      cbsFinished++;
      if (cbsFinished === finalLength) {
        return retCb.call(finalScope);
      }
    };
    return callbackWrapper;
  }
};



},{"koala-js":68}],133:[function(require,module,exports){
var ProxyHelper, _, proxyFun;

_ = require("underscore");

module.exports = ProxyHelper = function(opts) {
  this.g = opts.g;
  return this;
};

proxyFun = {
  corsURL: function(url) {
    if (document.URL.indexOf('localhost') >= 0 && url[0] === "/") {
      return url;
    }
    if (url.charAt(0) === "." || url.charAt(0) === "/") {
      return url;
    }
    url = url.replace("www\.", "");
    url = url.replace("http://", "");
    url = this.g.config.get('importProxy') + url;
    return url;
  }
};

_.extend(ProxyHelper.prototype, proxyFun);



},{"underscore":91}],134:[function(require,module,exports){
var BMath, Sequence, Stat, seqgen;

Sequence = require("biojs-model").seq;

BMath = require("./bmath");

Stat = require("stat.seqs");

seqgen = module.exports = {
  _generateSequence: function(len) {
    var i, k, ref, text;
    text = "";
    for (i = k = 0, ref = len - 1; k <= ref; i = k += 1) {
      text += seqgen.getRandomChar();
    }
    return text;
  },
  getDummySequences: function(len, seqLen) {
    var i, k, ref, seqs;
    seqs = [];
    if (len == null) {
      len = BMath.getRandomInt(3, 5);
    }
    if (seqLen == null) {
      seqLen = BMath.getRandomInt(50, 200);
    }
    for (i = k = 1, ref = len; k <= ref; i = k += 1) {
      seqs.push(new Sequence(seqgen._generateSequence(seqLen), "seq" + i, "r" + i));
    }
    return seqs;
  },
  getRandomChar: function(dict) {
    var possible;
    possible = dict || "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return possible.charAt(Math.floor(Math.random() * possible.length));
  },
  genConservedSequences: function(len, seqLen, dict) {
    var c, cConserv, conservAim, counter, i, j, k, l, m, n, observed, pseqs, ref, ref1, ref2, ref3, seqs, tolerance;
    seqs = [];
    if (len == null) {
      len = BMath.getRandomInt(3, 5);
    }
    if (seqLen == null) {
      seqLen = BMath.getRandomInt(50, 200);
    }
    dict = dict || "ACDEFGHIKLMNPQRSTVWY---";
    for (i = k = 1, ref = len; k <= ref; i = k += 1) {
      seqs[i - 1] = "";
    }
    tolerance = 0.2;
    conservAim = 1;
    for (i = l = 0, ref1 = seqLen - 1; l <= ref1; i = l += 1) {
      if (i % 3 === 0) {
        conservAim = (BMath.getRandomInt(50, 100)) / 100;
      }
      observed = [];
      for (j = m = 0, ref2 = len - 1; m <= ref2; j = m += 1) {
        counter = 0;
        while (counter < 100) {
          c = seqgen.getRandomChar(dict);
          cConserv = Stat(observed);
          cConserv.addSeq(c);
          counter++;
          if (Math.abs(conservAim - cConserv.scale(cConserv.conservation())[0]) < tolerance) {
            break;
          }
        }
        seqs[j] += c;
        observed.push(c);
      }
    }
    pseqs = [];
    for (i = n = 1, ref3 = len; n <= ref3; i = n += 1) {
      pseqs.push(new Sequence(seqs[i - 1], "seq" + i, "r" + i));
    }
    return pseqs;
  }
};



},{"./bmath":128,"biojs-model":45,"stat.seqs":90}],135:[function(require,module,exports){
var Base, Line, Polygon, Rect, setAttr, svgns;

svgns = "http://www.w3.org/2000/svg";

setAttr = function(obj, opts) {
  var name, value;
  for (name in opts) {
    value = opts[name];
    obj.setAttributeNS(null, name, value);
  }
  return obj;
};

Base = function(opts) {
  var svg;
  svg = document.createElementNS(svgns, 'svg');
  svg.setAttribute("width", opts.width);
  svg.setAttribute("height", opts.height);
  return svg;
};

Rect = function(opts) {
  var rect;
  rect = document.createElementNS(svgns, 'rect');
  return setAttr(rect, opts);
};

Line = function(opts) {
  var line;
  line = document.createElementNS(svgns, 'line');
  return setAttr(line, opts);
};

Polygon = function(opts) {
  var line;
  line = document.createElementNS(svgns, 'polygon');
  return setAttr(line, opts);
};

module.exports.rect = Rect;

module.exports.line = Line;

module.exports.polygon = Polygon;

module.exports.base = Base;



},{}],136:[function(require,module,exports){
var _, tf, treeHelper;

_ = require("underscore");

module.exports = treeHelper = function(msa) {
  this.msa = msa;
  return this;
};

tf = {
  loadTree: function(cb) {
    return this.msa.g["package"].loadPackages(["msa-tnt", "biojs-io-newick"], cb);
  },
  showTree: function(newickStr) {
    var mt, newick, newickObj, nodes, sel, t, treeDiv;
    newick = this.require("biojs-io-newick");
    if (typeof newickStr === "string") {
      newickObj = newick.parse_newick(newickStr);
    } else {
      newickObj = newickStr;
    }
    mt = this.require("msa-tnt");
    sel = new mt.selections();
    treeDiv = document.createElement("div");
    document.body.appendChild(treeDiv);
    console.log(this.msa.seqs.models);
    console.log(newickObj);
    nodes = mt.app({
      seqs: this.msa.seqs.models,
      tree: newickObj
    });
    console.log("nodes", nodes);
    t = new mt.adapters.tree({
      model: nodes,
      el: treeDiv,
      sel: sel
    });
    return treeDiv.style.width = "500px";
  },
  require: function(pkg) {
    return require(pkg);
  }
};

_.extend(treeHelper.prototype, tf);



},{"underscore":91}],137:[function(require,module,exports){
var LabelBlock, SeqBlock, boneView;

boneView = require("backbone-childs");

SeqBlock = require("./canvas/CanvasSeqBlock");

LabelBlock = require("./labels/LabelBlock");

module.exports = boneView.extend({
  initialize: function(data) {
    var labelblock, seqblock;
    this.g = data.g;
    if (true) {
      labelblock = new LabelBlock({
        model: this.model,
        g: this.g
      });
      labelblock.ordering = -1;
      this.addView("labelblock", labelblock);
    }
    if (this.g.vis.get("sequences")) {
      seqblock = new SeqBlock({
        model: this.model,
        g: this.g
      });
      seqblock.ordering = 0;
      this.addView("seqblock", seqblock);
    }
    this.listenTo(this.g.zoomer, "change:alignmentHeight", this.adjustHeight);
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this.adjustWidth);
    return this.listenTo(this.g.columns, "change:hidden", this.adjustHeight);
  },
  render: function() {
    this.renderSubviews();
    this.el.className = "biojs_msa_albody";
    this.el.style.whiteSpace = "nowrap";
    this.adjustHeight();
    this.adjustWidth();
    return this;
  },
  adjustHeight: function() {
    if (this.g.zoomer.get("alignmentHeight") === "auto") {
      return this.el.style.height = (this.g.zoomer.get("rowHeight") * this.model.length) + 5;
    } else {
      return this.el.style.height = this.g.zoomer.get("alignmentHeight");
    }
  },
  adjustWidth: function() {
    return this.el.style.width = this.getWidth();
  },
  getWidth: function() {
    var width;
    width = 0;
    width += this.g.zoomer.getLeftBlockWidth();
    if (this.g.vis.get("sequences")) {
      width += this.g.zoomer.get("alignmentWidth");
    }
    return width;
  }
});



},{"./canvas/CanvasSeqBlock":144,"./labels/LabelBlock":153,"backbone-childs":2}],138:[function(require,module,exports){
var OverviewBox, _, jbone, mouse, selection, view;

view = require("backbone-viewj");

mouse = require("mouse-pos");

selection = require("../g/selection/Selection");

jbone = require("jbone");

_ = require("underscore");

module.exports = OverviewBox = view.extend({
  className: "biojs_msa_overviewbox",
  tagName: "canvas",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:boxRectWidth change:boxRectHeight change:overviewboxPaddingTop", this.render);
    this.listenTo(this.g.selcol, "add reset change", this.render);
    this.listenTo(this.g.columns, "change:hidden", this.render);
    this.listenTo(this.g.colorscheme, "change:showLowerCase", this.render);
    this.listenTo(this.model, "change", _.debounce(this.render, 5));
    this.color = this.g.colorscheme.getSelectedScheme();
    this.listenTo(this.g.colorscheme, "change:scheme", function() {
      this.color = this.g.colorscheme.getSelectedScheme();
      return this.render();
    });
    return this.dragStart = [];
  },
  events: {
    click: "_onclick",
    mousedown: "_onmousedown"
  },
  render: function() {
    var c, color, hidden, i, j, k, l, rectHeight, rectWidth, ref, ref1, seq, showLowerCase, x, y;
    this._createCanvas();
    this.el.textContent = "overview";
    this.el.style.marginTop = this.g.zoomer.get("overviewboxPaddingTop");
    this.ctx.fillStyle = "#999999";
    this.ctx.fillRect(0, 0, this.el.width, this.el.height);
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    hidden = this.g.columns.get("hidden");
    showLowerCase = this.g.colorscheme.get("showLowerCase");
    y = -rectHeight;
    for (i = k = 0, ref = this.model.length - 1; k <= ref; i = k += 1) {
      seq = this.model.at(i).get("seq");
      x = 0;
      y = y + rectHeight;
      if (this.model.at(i).get("hidden")) {
        console.log(this.model.at(i).get("hidden"));
        this.ctx.fillStyle = "grey";
        this.ctx.fillRect(0, y, seq.length * rectWidth, rectHeight);
        continue;
      }
      for (j = l = 0, ref1 = seq.length - 1; l <= ref1; j = l += 1) {
        c = seq[j];
        if (showLowerCase) {
          c = c.toUpperCase();
        }
        color = this.color.getColor(c, {
          pos: j
        });
        if (hidden.indexOf(j) >= 0) {
          color = "grey";
        }
        if (color != null) {
          this.ctx.fillStyle = color;
          this.ctx.fillRect(x, y, rectWidth, rectHeight);
        }
        x = x + rectWidth;
      }
    }
    return this._drawSelection();
  },
  _drawSelection: function() {
    var i, k, maxHeight, pos, rectHeight, rectWidth, ref, sel, seq;
    if (this.dragStart.length > 0 && !this.prolongSelection) {
      return;
    }
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    maxHeight = rectHeight * this.model.length;
    this.ctx.fillStyle = "#ffff00";
    this.ctx.globalAlpha = 0.9;
    for (i = k = 0, ref = this.g.selcol.length - 1; k <= ref; i = k += 1) {
      sel = this.g.selcol.at(i);
      if (sel.get('type') === 'column') {
        this.ctx.fillRect(rectWidth * sel.get('xStart'), 0, rectWidth * (sel.get('xEnd') - sel.get('xStart') + 1), maxHeight);
      } else if (sel.get('type') === 'row') {
        seq = (this.model.filter(function(el) {
          return el.get('id') === sel.get('seqId');
        }))[0];
        pos = this.model.indexOf(seq);
        this.ctx.fillRect(0, rectHeight * pos, rectWidth * seq.get('seq').length, rectHeight);
      } else if (sel.get('type') === 'pos') {
        seq = (this.model.filter(function(el) {
          return el.get('id') === sel.get('seqId');
        }))[0];
        pos = this.model.indexOf(seq);
        this.ctx.fillRect(rectWidth * sel.get('xStart'), rectHeight * pos, rectWidth * (sel.get('xEnd') - sel.get('xStart') + 1), rectHeight);
      }
    }
    return this.ctx.globalAlpha = 1;
  },
  _onclick: function(evt) {
    return this.g.trigger("meta:click", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmousemove: function(e) {
    var rect;
    if (this.dragStart.length === 0) {
      return;
    }
    this.render();
    this.ctx.fillStyle = "#ffff00";
    this.ctx.globalAlpha = 0.9;
    rect = this._calcSelection(mouse.abs(e));
    this.ctx.fillRect(rect[0][0], rect[1][0], rect[0][1] - rect[0][0], rect[1][1] - rect[1][0]);
    e.preventDefault();
    return e.stopPropagation();
  },
  _onmousedown: function(e) {
    this.dragStart = mouse.abs(e);
    this.dragStartRel = mouse.rel(e);
    if (e.ctrlKey || e.metaKey) {
      this.prolongSelection = true;
    } else {
      this.prolongSelection = false;
    }
    jbone(document.body).on('mousemove.overmove', (function(_this) {
      return function(e) {
        return _this._onmousemove(e);
      };
    })(this));
    jbone(document.body).on('mouseup.overup', (function(_this) {
      return function(e) {
        return _this._onmouseup(e);
      };
    })(this));
    return this.dragStart;
  },
  _calcSelection: function(dragMove) {
    var dragRel, i, k, l, rect;
    dragRel = [dragMove[0] - this.dragStart[0], dragMove[1] - this.dragStart[1]];
    for (i = k = 0; k <= 1; i = k += 1) {
      dragRel[i] = this.dragStartRel[i] + dragRel[i];
    }
    rect = [[this.dragStartRel[0], dragRel[0]], [this.dragStartRel[1], dragRel[1]]];
    for (i = l = 0; l <= 1; i = l += 1) {
      if (rect[i][1] < rect[i][0]) {
        rect[i] = [rect[i][1], rect[i][0]];
      }
      rect[i][0] = Math.max(rect[i][0], 0);
    }
    return rect;
  },
  _endSelection: function(dragEnd) {
    var args, i, j, k, l, m, rect, ref, ref1, selis;
    jbone(document.body).off('.overmove');
    jbone(document.body).off('.overup');
    if (this.dragStart.length === 0) {
      return;
    }
    rect = this._calcSelection(dragEnd);
    for (i = k = 0; k <= 1; i = ++k) {
      rect[0][i] = Math.floor(rect[0][i] / this.g.zoomer.get("boxRectWidth"));
    }
    for (i = l = 0; l <= 1; i = ++l) {
      rect[1][i] = Math.floor(rect[1][i] / this.g.zoomer.get("boxRectHeight"));
    }
    rect[0][1] = Math.min(this.model.getMaxLength() - 1, rect[0][1]);
    rect[1][1] = Math.min(this.model.length - 1, rect[1][1]);
    selis = [];
    for (j = m = ref = rect[1][0], ref1 = rect[1][1]; m <= ref1; j = m += 1) {
      args = {
        seqId: this.model.at(j).get('id'),
        xStart: rect[0][0],
        xEnd: rect[0][1]
      };
      selis.push(new selection.possel(args));
    }
    this.dragStart = [];
    if (this.prolongSelection) {
      this.g.selcol.add(selis);
    } else {
      this.g.selcol.reset(selis);
    }
    this.g.zoomer.setLeftOffset(rect[0][0]);
    return this.g.zoomer.setTopOffset(rect[1][0]);
  },
  _onmouseup: function(e) {
    return this._endSelection(mouse.abs(e));
  },
  _onmouseout: function(e) {
    return this._endSelection(mouse.abs(e));
  },
  _createCanvas: function() {
    var rectHeight, rectWidth;
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    this.el.height = this.model.length * rectHeight;
    this.el.width = this.model.getMaxLength() * rectWidth;
    this.ctx = this.el.getContext("2d");
    this.el.style.overflow = "scroll";
    return this.el.style.cursor = "crosshair";
  }
});



},{"../g/selection/Selection":102,"backbone-viewj":9,"jbone":67,"mouse-pos":71,"underscore":91}],139:[function(require,module,exports){
var _, boneView, dom, k, sel;

boneView = require("backbone-childs");

_ = require('underscore');

k = require('koala-js');

dom = require('dom-helper');

sel = require("../g/selection/Selection");

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.user, "change:searchText", function(model, prop) {
      this.search(prop);
      return this.render();
    });
    this.sel = [];
    return this.selPos = 0;
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  render: function() {
    var searchText;
    this.renderSubviews();
    this.el.className = "biojs_msa_searchresult";
    searchText = this.g.user.get("searchText");
    if ((searchText != null) && searchText.length > 0) {
      if (this.sel.length === 0) {
        this.el.textContent = "no selection found";
      } else {
        this.resultBox = k.mk("div");
        this.resultBox.className = "biojs_msa_searchresult_ovbox";
        this.updateResult();
        this.el.appendChild(this.resultBox);
        this.el.appendChild(this.buildBtns());
      }
    }
    return this;
  },
  updateResult: function() {
    var seli, text;
    text = "search pattern: " + this.g.user.get("searchText");
    text += ", selection: " + (this.selPos + 1);
    seli = this.sel[this.selPos];
    text += " (";
    text += seli.get("xStart") + " - " + seli.get("xEnd");
    text += ", id: " + seli.get("seqId");
    text += ")";
    return this.resultBox.textContent = text;
  },
  buildBtns: function() {
    var allBtn, nextBtn, prevBtn, searchrow;
    prevBtn = k.mk("button");
    prevBtn.textContent = "Prev";
    prevBtn.addEventListener("click", (function(_this) {
      return function() {
        return _this.moveSel(-1);
      };
    })(this));
    nextBtn = k.mk("button");
    nextBtn.textContent = "Next";
    nextBtn.addEventListener("click", (function(_this) {
      return function() {
        return _this.moveSel(1);
      };
    })(this));
    allBtn = k.mk("button");
    allBtn.textContent = "All";
    allBtn.addEventListener("click", (function(_this) {
      return function() {
        return _this.g.selcol.reset(_this.sel);
      };
    })(this));
    searchrow = k.mk("div");
    searchrow.appendChild(prevBtn);
    searchrow.appendChild(nextBtn);
    searchrow.appendChild(allBtn);
    searchrow.className = "biojs_msa_searchresult_row";
    return searchrow;
  },
  moveSel: function(relDist) {
    var selNew;
    selNew = this.selPos + relDist;
    if (selNew < 0 || selNew >= this.sel.length) {
      return -1;
    } else {
      this.focus(selNew);
      this.selPos = selNew;
      return this.updateResult();
    }
  },
  focus: function(selPos) {
    var leftIndex, seli;
    seli = this.sel[selPos];
    leftIndex = seli.get("xStart");
    this.g.zoomer.setLeftOffset(leftIndex);
    return this.g.selcol.reset([seli]);
  },
  search: function(searchText) {
    var leftestIndex, newSeli, origIndex, search;
    search = new RegExp(searchText, "gi");
    newSeli = [];
    leftestIndex = origIndex = 100042;
    this.model.each(function(seq) {
      var args, index, match, results, strSeq;
      strSeq = seq.get("seq");
      results = [];
      while (match = search.exec(strSeq)) {
        index = match.index;
        args = {
          xStart: index,
          xEnd: index + match[0].length - 1,
          seqId: seq.get("id")
        };
        newSeli.push(new sel.possel(args));
        results.push(leftestIndex = Math.min(index, leftestIndex));
      }
      return results;
    });
    this.g.selcol.reset(newSeli);
    if (leftestIndex === origIndex) {
      leftestIndex = 0;
    }
    this.g.zoomer.setLeftOffset(leftestIndex);
    return this.sel = newSeli;
  }
});



},{"../g/selection/Selection":102,"backbone-childs":2,"dom-helper":66,"koala-js":68,"underscore":91}],140:[function(require,module,exports){
var AlignmentBody, HeaderBlock, OverviewBox, Search, _, boneView;

boneView = require("backbone-childs");

AlignmentBody = require("./AlignmentBody");

HeaderBlock = require("./header/HeaderBlock");

OverviewBox = require("./OverviewBox");

Search = require("./Search");

_ = require('underscore');

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.stats, "reset", function() {
      return this.rerender();
    });
    this.listenTo(this.model, "change:hidden", _.debounce(this.rerender, 10));
    this.listenTo(this.model, "sort", this.rerender);
    this.listenTo(this.model, "add", function() {
      return console.log("seq add");
    });
    this.listenTo(this.g.vis, "change:sequences", this.rerender);
    this.listenTo(this.g.vis, "change:overviewbox", this.rerender);
    return this.listenTo(this.g.visorder, "change", this.rerender);
  },
  draw: function() {
    var body, headerblock, overviewbox, searchblock;
    this.removeViews();
    if (this.g.vis.get("overviewbox")) {
      overviewbox = new OverviewBox({
        model: this.model,
        g: this.g
      });
      overviewbox.ordering = this.g.visorder.get('overviewBox');
      this.addView("overviewBox", overviewbox);
    }
    if (true) {
      headerblock = new HeaderBlock({
        model: this.model,
        g: this.g
      });
      headerblock.ordering = this.g.visorder.get('headerBox');
      this.addView("headerBox", headerblock);
    }
    if (true) {
      searchblock = new Search({
        model: this.model,
        g: this.g
      });
      searchblock.ordering = this.g.visorder.get('searchBox');
      this.addView("searchbox", searchblock);
    }
    body = new AlignmentBody({
      model: this.model,
      g: this.g
    });
    body.ordering = this.g.visorder.get('alignmentBody');
    return this.addView("body", body);
  },
  render: function() {
    this.renderSubviews();
    this.el.className = "biojs_msa_stage";
    return this;
  },
  rerender: function() {
    this.draw();
    return this.render();
  }
});



},{"./AlignmentBody":137,"./OverviewBox":138,"./Search":139,"./header/HeaderBlock":148,"backbone-childs":2,"underscore":91}],141:[function(require,module,exports){
var CanvasCharCache, Events;

Events = require("biojs-events");

module.exports = CanvasCharCache = (function() {
  function CanvasCharCache(g) {
    this.g = g;
    this.cache = {};
    this.cacheHeight = 0;
    this.cacheWidth = 0;
  }

  CanvasCharCache.prototype.getFontTile = function(letter, width, height) {
    if (width !== this.cacheWidth || height !== this.cacheHeight) {
      this.cacheHeight = height;
      this.cacheWidth = width;
      this.cache = {};
    }
    if (this.cache[letter] === void 0) {
      this.createTile(letter, width, height);
    }
    return this.cache[letter];
  };

  CanvasCharCache.prototype.createTile = function(letter, width, height) {
    var canvas;
    canvas = this.cache[letter] = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    this.ctx = canvas.getContext('2d');
    this.ctx.font = this.g.zoomer.get("residueFont") + "px mono";
    this.ctx.textBaseline = 'middle';
    this.ctx.textAlign = "center";
    return this.ctx.fillText(letter, width / 2, height / 2, width);
  };

  return CanvasCharCache;

})();



},{"biojs-events":13}],142:[function(require,module,exports){
var Events, _, cache, cacheConstructor;

_ = require("underscore");

Events = require("biojs-events");

cache = {
  setMaxScrollHeight: function() {
    return this.maxScrollHeight = this.g.zoomer.getMaxAlignmentHeight() - this.g.zoomer.get('alignmentHeight');
  },
  setMaxScrollWidth: function() {
    return this.maxScrollWidth = this.g.zoomer.getMaxAlignmentWidth() - this.g.zoomer.getAlignmentWidth();
  }
};

module.exports = cacheConstructor = function(g, model) {
  this.g = g;
  this.model = model;
  this.maxScrollWidth = 0;
  this.maxScrollHeight = 0;
  this.setMaxScrollHeight();
  this.setMaxScrollWidth();
  this.listenTo(this.g.zoomer, "change:rowHeight", this.setMaxScrollHeight);
  this.listenTo(this.g.zoomer, "change:columnWidth", this.setMaxScrollWidth);
  this.listenTo(this.g.zoomer, "change:alignmentWidth", this.setMaxScrollWidth);
  this.listenTo(this.g.zoomer, "change:alignmentHeight", this.setMaxScrollHeight);
  this.listenTo(this.model, "add change reset", function() {
    this.setMaxScrollHeight();
    return this.setMaxScrollWidth();
  }, this);
  return this;
};

_.extend(cacheConstructor.prototype, cache);

Events.mixin(cacheConstructor.prototype);



},{"biojs-events":13,"underscore":91}],143:[function(require,module,exports){
var SelectionClass, _;

_ = require("underscore");

module.exports = SelectionClass = function(g, ctx) {
  this.g = g;
  this.ctx = ctx;
  return this;
};

_.extend(SelectionClass.prototype, {
  _getSelection: function(model) {
    var j, l, len, m, maxLen, n, ref, ref1, ref2, rows, sel, selection, sels;
    maxLen = model.get("seq").length;
    selection = [];
    sels = this.g.selcol.getSelForRow(model.get("id"));
    rows = _.find(sels, function(el) {
      return el.get("type") === "row";
    });
    if (rows != null) {
      for (n = j = 0, ref = maxLen - 1; j <= ref; n = j += 1) {
        selection.push(n);
      }
    } else if (sels.length > 0) {
      for (l = 0, len = sels.length; l < len; l++) {
        sel = sels[l];
        for (n = m = ref1 = sel.get("xStart"), ref2 = sel.get("xEnd"); m <= ref2; n = m += 1) {
          selection.push(n);
        }
      }
    }
    return selection;
  },
  _appendSelection: function(data) {
    var boxHeight, boxWidth, hiddenOffset, j, k, mNextSel, mPrevSel, n, ref, ref1, results, selection, seq;
    seq = data.model.get("seq");
    selection = this._getSelection(data.model);
    ref = this._getPrevNextSelection(data.model), mPrevSel = ref[0], mNextSel = ref[1];
    boxWidth = this.g.zoomer.get("columnWidth");
    boxHeight = this.g.zoomer.get("rowHeight");
    if (selection.length === 0) {
      return;
    }
    hiddenOffset = 0;
    results = [];
    for (n = j = 0, ref1 = seq.length - 1; j <= ref1; n = j += 1) {
      if (data.hidden.indexOf(n) >= 0) {
        results.push(hiddenOffset++);
      } else {
        k = n - hiddenOffset;
        if (selection.indexOf(n) >= 0 && (k === 0 || selection.indexOf(n - 1) < 0)) {
          results.push(this._renderSelection({
            n: n,
            k: k,
            selection: selection,
            mPrevSel: mPrevSel,
            mNextSel: mNextSel,
            xZero: data.xZero,
            yZero: data.yZero,
            model: data.model
          }));
        } else {
          results.push(void 0);
        }
      }
    }
    return results;
  },
  _renderSelection: function(data) {
    var beforeStyle, beforeWidth, boxHeight, boxWidth, hidden, i, j, k, l, mNextSel, mPrevSel, n, ref, ref1, ref2, selection, selectionLength, totalWidth, xPart, xPos, xZero, yZero;
    xZero = data.xZero;
    yZero = data.yZero;
    n = data.n;
    k = data.k;
    selection = data.selection;
    mPrevSel = data.mPrevSel;
    mNextSel = data.mNextSel;
    selectionLength = 0;
    for (i = j = ref = n, ref1 = data.model.get("seq").length - 1; j <= ref1; i = j += 1) {
      if (selection.indexOf(i) >= 0) {
        selectionLength++;
      } else {
        break;
      }
    }
    boxWidth = this.g.zoomer.get("columnWidth");
    boxHeight = this.g.zoomer.get("rowHeight");
    totalWidth = (boxWidth * selectionLength) + 1;
    hidden = this.g.columns.get('hidden');
    this.ctx.beginPath();
    beforeWidth = this.ctx.lineWidth;
    this.ctx.lineWidth = 3;
    beforeStyle = this.ctx.strokeStyle;
    this.ctx.strokeStyle = "#FF0000";
    xZero += k * boxWidth;
    xPart = 0;
    for (i = l = 0, ref2 = selectionLength - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; i = 0 <= ref2 ? ++l : --l) {
      xPos = n + i;
      if (hidden.indexOf(xPos) >= 0) {
        continue;
      }
      if (!((mPrevSel != null) && mPrevSel.indexOf(xPos) >= 0)) {
        this.ctx.moveTo(xZero + xPart, yZero);
        this.ctx.lineTo(xPart + boxWidth + xZero, yZero);
      }
      if (!((mNextSel != null) && mNextSel.indexOf(xPos) >= 0)) {
        this.ctx.moveTo(xPart + xZero, boxHeight + yZero);
        this.ctx.lineTo(xPart + boxWidth + xZero, boxHeight + yZero);
      }
      xPart += boxWidth;
    }
    this.ctx.moveTo(xZero, yZero);
    this.ctx.lineTo(xZero, boxHeight + yZero);
    this.ctx.moveTo(xZero + totalWidth, yZero);
    this.ctx.lineTo(xZero + totalWidth, boxHeight + yZero);
    this.ctx.stroke();
    this.ctx.strokeStyle = beforeStyle;
    return this.ctx.lineWidth = beforeWidth;
  },
  _getPrevNextSelection: function(model) {
    var mNextSel, mPrevSel, modelNext, modelPrev;
    modelPrev = model.collection.prev(model);
    modelNext = model.collection.next(model);
    if (modelPrev != null) {
      mPrevSel = this._getSelection(modelPrev);
    }
    if (modelNext != null) {
      mNextSel = this._getSelection(modelNext);
    }
    return [mPrevSel, mNextSel];
  }
});



},{"underscore":91}],144:[function(require,module,exports){
var CanvasCoordsCache, CanvasSeqDrawer, CharCache, SelectionClass, _, boneView, jbone, mouse;

boneView = require("backbone-childs");

mouse = require("mouse-pos");

_ = require("underscore");

jbone = require("jbone");

CharCache = require("./CanvasCharCache");

SelectionClass = require("./CanvasSelection");

CanvasSeqDrawer = require("./CanvasSeqDrawer");

CanvasCoordsCache = require("./CanvasCoordsCache");

module.exports = boneView.extend({
  tagName: "canvas",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:_alignmentScrollLeft change:_alignmentScrollTop", function(model, value, options) {
      if (((options != null ? options.origin : void 0) == null) || options.origin !== "canvasseq") {
        return this.render();
      }
    });
    this.listenTo(this.g.columns, "change:hidden", this.render);
    this.listenTo(this.g.zoomer, "change:alignmentWidth change:alignmentHeight", this.render);
    this.listenTo(this.g.colorscheme, "change", this.render);
    this.listenTo(this.g.selcol, "reset add", this.render);
    this.el.style.display = "inline-block";
    this.el.style.overflowX = "hidden";
    this.el.style.overflowY = "hidden";
    this.el.className = "biojs_msa_seqblock";
    this.ctx = this.el.getContext('2d');
    this.cache = new CharCache(this.g);
    this.coordsCache = new CanvasCoordsCache(this.g, this.model);
    this.listenTo(this.g.zoomer, "change:residueFont", function() {
      this.cache = new CharCache(this.g);
      return this.render();
    });
    this.sel = new SelectionClass(this.g, this.ctx);
    this._setColor();
    this.throttleTime = 0;
    this.throttleCounts = 0;
    if (document.documentElement.style.webkitAppearance != null) {
      this.throttledDraw = function() {
        var start, tTime;
        start = +new Date();
        this.draw();
        this.throttleTime += +new Date() - start;
        this.throttleCounts++;
        if (this.throttleCounts > 15) {
          tTime = Math.ceil(this.throttleTime / this.throttleCounts);
          console.log("avgDrawTime/WebKit", tTime);
          return this.throttledDraw = this.draw;
        }
      };
    } else {
      this.throttledDraw = _.throttle(this.throttledDraw, 30);
    }
    return this.manageEvents();
  },
  throttledDraw: function() {
    var start, tTime;
    start = +new Date();
    this.draw();
    this.throttleTime += +new Date() - start;
    this.throttleCounts++;
    if (this.throttleCounts > 15) {
      tTime = Math.ceil(this.throttleTime / this.throttleCounts);
      console.log("avgDrawTime", tTime);
      tTime *= 1.2;
      tTime = Math.max(20, tTime);
      return this.throttledDraw = _.throttle(this.draw, tTime);
    }
  },
  manageEvents: function() {
    var events;
    events = {};
    events.mousedown = "_onmousedown";
    events.touchstart = "_ontouchstart";
    if (this.g.config.get("registerMouseClicks")) {
      events.dblclick = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    events.mousewheel = "_onmousewheel";
    events.DOMMouseScroll = "_onmousewheel";
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
    return this.dragStart = [];
  },
  _setColor: function() {
    return this.color = this.g.colorscheme.getSelectedScheme();
  },
  draw: function() {
    this.el.width = this.el.width;
    if ((this.seqDrawer != null) && this.model.length > 0) {
      this.seqDrawer.drawLetters();
      this.seqDrawer.drawRows(this.sel._appendSelection, this.sel);
      return this.seqDrawer.drawRows(this.drawFeatures, this);
    }
  },
  drawFeatures: function(data) {
    var ctx, rectHeight, rectWidth;
    rectWidth = this.g.zoomer.get("columnWidth");
    rectHeight = this.g.zoomer.get("rowHeight");
    if (data.model.attributes.height > 1) {
      ctx = this.ctx;
      data.model.attributes.features.each(function(feature) {
        var len, y;
        ctx.fillStyle = feature.attributes.fillColor || "red";
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillRect(feature.attributes.xStart * rectWidth + data.xZero, y + data.yZero, rectWidth * len, rectHeight);
      });
      ctx.fillStyle = "black";
      ctx.font = this.g.zoomer.get("residueFont") + "px mono";
      ctx.textBaseline = 'middle';
      ctx.textAlign = "center";
      return data.model.attributes.features.each(function(feature) {
        var len, y;
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillText(feature.attributes.text, data.xZero + feature.attributes.xStart * rectWidth + (len / 2) * rectWidth, data.yZero + rectHeight * 0.5 + y);
      });
    }
  },
  render: function() {
    this.el.setAttribute('height', this.g.zoomer.get("alignmentHeight") + "px");
    this.el.setAttribute('width', this.g.zoomer.getAlignmentWidth() + "px");
    this.g.zoomer._checkScrolling(this._checkScrolling([this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')]), {
      header: "canvasseq"
    });
    this._setColor();
    this.seqDrawer = new CanvasSeqDrawer(this.g, this.ctx, this.model, {
      width: this.el.width,
      height: this.el.height,
      color: this.color,
      cache: this.cache
    });
    this.throttledDraw();
    return this;
  },
  _onmousemove: function(e, reversed) {
    var dragEnd, i, j, k, l, relDist, relEnd, scaleFactor, scrollCorrected;
    if (this.dragStart.length === 0) {
      return;
    }
    dragEnd = mouse.abs(e);
    relEnd = [dragEnd[0] - this.dragStart[0], dragEnd[1] - this.dragStart[1]];
    scaleFactor = this.g.zoomer.get("canvasEventScale");
    if (reversed) {
      scaleFactor = 3;
    }
    for (i = j = 0; j <= 1; i = j += 1) {
      relEnd[i] = relEnd[i] * scaleFactor;
    }
    relDist = [this.dragStartScroll[0] - relEnd[0], this.dragStartScroll[1] - relEnd[1]];
    for (i = k = 0; k <= 1; i = k += 1) {
      relDist[i] = Math.round(relDist[i]);
    }
    scrollCorrected = this._checkScrolling(relDist);
    this.g.zoomer._checkScrolling(scrollCorrected, {
      origin: "canvasseq"
    });
    for (i = l = 0; l <= 1; i = l += 1) {
      if (scrollCorrected[i] !== relDist[i]) {
        if (scrollCorrected[i] === 0) {
          this.dragStart[i] = dragEnd[i];
          this.dragStartScroll[i] = 0;
        } else {
          this.dragStart[i] = dragEnd[i] - scrollCorrected[i];
        }
      }
    }
    this.throttledDraw();
    if (e.preventDefault != null) {
      e.preventDefault();
      return e.stopPropagation();
    }
  },
  _ontouchmove: function(e) {
    this._onmousemove(e.changedTouches[0], true);
    e.preventDefault();
    return e.stopPropagation();
  },
  _onmousedown: function(e) {
    this.dragStart = mouse.abs(e);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('mousemove.overmove', (function(_this) {
      return function(e) {
        return _this._onmousemove(e);
      };
    })(this));
    jbone(document.body).on('mouseup.overup', (function(_this) {
      return function() {
        return _this._cleanup();
      };
    })(this));
    return e.preventDefault();
  },
  _ontouchstart: function(e) {
    this.dragStart = mouse.abs(e.changedTouches[0]);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('touchmove.overtmove', (function(_this) {
      return function(e) {
        return _this._ontouchmove(e);
      };
    })(this));
    return jbone(document.body).on('touchend.overtend touchleave.overtleave touchcancel.overtcanel', (function(_this) {
      return function(e) {
        return _this._touchCleanup(e);
      };
    })(this));
  },
  _onmousewinout: function(e) {
    if (e.toElement === document.body.parentNode) {
      return this._cleanup();
    }
  },
  _cleanup: function() {
    this.dragStart = [];
    jbone(document.body).off('.overmove');
    jbone(document.body).off('.overup');
    return jbone(document.body).off('.overout');
  },
  _touchCleanup: function(e) {
    if (e.changedTouches.length > 0) {
      this._onmousemove(e.changedTouches[0], true);
    }
    this.dragStart = [];
    jbone(document.body).off('.overtmove');
    jbone(document.body).off('.overtend');
    jbone(document.body).off('.overtleave');
    return jbone(document.body).off('.overtcancel');
  },
  _onmousewheel: function(e) {
    var delta;
    delta = mouse.wheelDelta(e);
    this.g.zoomer.set('_alignmentScrollLeft', this.g.zoomer.get('_alignmentScrollLeft') + delta[0]);
    this.g.zoomer.set('_alignmentScrollTop', this.g.zoomer.get('_alignmentScrollTop') + delta[1]);
    return e.preventDefault();
  },
  _onclick: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:click", res);
      } else {
        this.g.trigger("residue:click", res);
      }
    }
    return this.throttledDraw();
  },
  _onmousein: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mousein", res);
      } else {
        this.g.trigger("residue:mousein", res);
      }
    }
    return this.throttledDraw();
  },
  _onmouseout: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mouseout", res);
      } else {
        this.g.trigger("residue:mouseout", res);
      }
    }
    return this.throttledDraw();
  },
  _getClickPos: function(e) {
    var coords, feature, features, ref, rowNumber, seqId, x, y;
    coords = mouse.rel(e);
    coords[0] += this.g.zoomer.get("_alignmentScrollLeft");
    x = Math.floor(coords[0] / this.g.zoomer.get("columnWidth"));
    ref = this.seqDrawer._getSeqForYClick(coords[1]), y = ref[0], rowNumber = ref[1];
    x += this.g.columns.calcHiddenColumns(x);
    y += this.model.calcHiddenSeqs(y);
    x = Math.max(0, x);
    y = Math.max(0, y);
    seqId = this.model.at(y).get("id");
    if (rowNumber > 0) {
      features = this.model.at(y).get("features").getFeatureOnRow(rowNumber - 1, x);
      if (features.length !== 0) {
        feature = features[0];
        console.log(features[0].attributes);
        return {
          seqId: seqId,
          feature: feature,
          rowPos: x,
          evt: e
        };
      }
    } else {
      return {
        seqId: seqId,
        rowPos: x,
        evt: e
      };
    }
  },
  _checkScrolling: function(scrollObj) {
    var i, j, max;
    max = [this.coordsCache.maxScrollWidth, this.coordsCache.maxScrollHeight];
    for (i = j = 0; j <= 1; i = j += 1) {
      if (scrollObj[i] > max[i]) {
        scrollObj[i] = max[i];
      }
      if (scrollObj[i] < 0) {
        scrollObj[i] = 0;
      }
    }
    return scrollObj;
  }
});



},{"./CanvasCharCache":141,"./CanvasCoordsCache":142,"./CanvasSelection":143,"./CanvasSeqDrawer":145,"backbone-childs":2,"jbone":67,"mouse-pos":71,"underscore":91}],145:[function(require,module,exports){
var _, construc, drawer;

_ = require("underscore");

drawer = {
  drawLetters: function() {
    var rectHeight;
    rectHeight = this.rectHeight;
    this.ctx.globalAlpha = this.g.colorscheme.get("opacity");
    this.drawSeqs(function(data) {
      return this.drawSeq(data, this._drawRect);
    });
    this.ctx.globalAlpha = 1;
    return this.drawSeqs(function(data) {
      return this.drawSeq(data, this._drawLetter);
    });
  },
  drawSeqs: function(callback, target) {
    var hidden, i, k, ref, ref1, ref2, results, seq, seqHeight, start, y;
    hidden = this.g.columns.get("hidden");
    target = target || this;
    ref = this.getStartSeq(), start = ref[0], y = ref[1];
    results = [];
    for (i = k = ref1 = start, ref2 = this.model.length - 1; k <= ref2; i = k += 1) {
      seq = this.model.at(i);
      if (seq.get('hidden')) {
        continue;
      }
      callback.call(target, {
        model: seq,
        yPos: y,
        y: i,
        hidden: hidden
      });
      seqHeight = (seq.attributes.height || 1) * this.rectHeight;
      y = y + seqHeight;
      if (y > this.height) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  drawRows: function(callback, target) {
    return this.drawSeqs(function(data) {
      return this.drawRow(data, callback, target);
    });
  },
  drawRow: function(data, callback, target) {
    var rectWidth, start, x, xZero, yZero;
    rectWidth = this.g.zoomer.get("columnWidth");
    start = Math.max(0, Math.abs(Math.ceil(-this.g.zoomer.get('_alignmentScrollLeft') / rectWidth)));
    x = -Math.abs(-this.g.zoomer.get('_alignmentScrollLeft') % rectWidth);
    xZero = x - start * rectWidth;
    yZero = data.yPos;
    return callback.call(target, {
      model: data.model,
      xZero: xZero,
      yZero: yZero,
      hidden: data.hidden
    });
  },
  getStartSeq: function() {
    var counter, i, start, y;
    start = (Math.max(0, Math.floor(this.g.zoomer.get('_alignmentScrollTop') / this.rectHeight))) + 1;
    counter = 0;
    i = 0;
    while (counter < start && i < this.model.length) {
      counter += this.model.at(i).attributes.height || 1;
      i++;
    }
    y = Math.max(0, this.g.zoomer.get('_alignmentScrollTop') - counter * this.rectHeight + (this.model.at(i - 1).attributes.height || 1) * this.rectHeight);
    return [i - 1, -y];
  },
  _getSeqForYClick: function(click) {
    var clickedRows, counter, i, ref, rowNumber, start, yDiff, yRel;
    ref = this.getStartSeq(), start = ref[0], yDiff = ref[1];
    yRel = yDiff % this.rectHeight;
    clickedRows = (Math.max(0, Math.floor((click - yRel) / this.rectHeight))) + 1;
    counter = 0;
    i = start;
    while (counter < clickedRows && i < this.model.length) {
      counter += this.model.at(i).attributes.height || 1;
      i++;
    }
    rowNumber = Math.max(0, Math.floor(click / this.rectHeight) - counter + (this.model.at(i - 1).get("height") || 1));
    return [i - 1, rowNumber];
  },
  drawSeq: function(data, callback) {
    var c, elWidth, j, k, rectHeight, rectWidth, ref, ref1, res, results, seq, start, x, y;
    seq = data.model.get("seq");
    y = data.yPos;
    rectWidth = this.rectWidth;
    rectHeight = this.rectHeight;
    start = Math.max(0, Math.abs(Math.ceil(-this.g.zoomer.get('_alignmentScrollLeft') / rectWidth)));
    x = -Math.abs(-this.g.zoomer.get('_alignmentScrollLeft') % rectWidth);
    res = {
      rectWidth: rectWidth,
      rectHeight: rectHeight,
      yPos: y,
      y: data.y
    };
    elWidth = this.width;
    results = [];
    for (j = k = ref = start, ref1 = seq.length - 1; k <= ref1; j = k += 1) {
      c = seq[j];
      c = c.toUpperCase();
      res.x = j;
      res.c = c;
      res.xPos = x;
      if (data.hidden.indexOf(j) < 0) {
        callback(this, res);
      } else {
        continue;
      }
      x = x + rectWidth;
      if (x > elWidth) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  _drawRect: function(that, data) {
    var color;
    color = that.color.getColor(data.c, {
      pos: data.x,
      y: data.y
    });
    if (color != null) {
      that.ctx.fillStyle = color;
      return that.ctx.fillRect(data.xPos, data.yPos, data.rectWidth, data.rectHeight);
    }
  },
  _drawLetter: function(that, data) {
    return that.ctx.drawImage(that.cache.getFontTile(data.c, data.rectWidth, data.rectHeight), data.xPos, data.yPos, data.rectWidth, data.rectHeight);
  }
};

module.exports = construc = function(g, ctx, model, opts) {
  this.g = g;
  this.ctx = ctx;
  this.model = model;
  this.width = opts.width;
  this.height = opts.height;
  this.color = opts.color;
  this.cache = opts.cache;
  this.rectHeight = this.g.zoomer.get("rowHeight");
  this.rectWidth = this.g.zoomer.get("columnWidth");
  return this;
};

_.extend(construc.prototype, drawer);



},{"underscore":91}],146:[function(require,module,exports){
var ConservationView, dom, svg, view;

view = require("backbone-viewj");

dom = require("dom-helper");

svg = require("../../utils/svg");

ConservationView = view.extend({
  className: "biojs_msa_conserv",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    this.listenTo(this.g.columns, "change:scaling", this.render);
    this.listenTo(this.g.stats, "reset", this.render);
    return this.manageEvents();
  },
  render: function() {
    var avgHeight, cellWidth, conserv, height, hidden, i, j, maxHeight, n, nMax, rect, ref, s, stepSize, width, x;
    conserv = this.g.stats.scale(this.g.stats.conservation());
    dom.removeAllChilds(this.el);
    nMax = this.model.getMaxLength();
    cellWidth = this.g.zoomer.get("columnWidth");
    maxHeight = 20;
    width = cellWidth * (nMax - this.g.columns.get('hidden').length);
    s = svg.base({
      height: maxHeight,
      width: width
    });
    s.style.display = "inline-block";
    s.style.cursor = "pointer";
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    x = 0;
    n = 0;
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        n += stepSize;
        continue;
      }
      width = cellWidth * stepSize;
      avgHeight = 0;
      for (i = j = 0, ref = stepSize - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        avgHeight += conserv[n];
      }
      height = maxHeight * (avgHeight / stepSize);
      rect = svg.rect({
        x: x,
        y: maxHeight - height,
        width: width - cellWidth / 4,
        height: height,
        style: "stroke:red;stroke-width:1;"
      });
      rect.rowPos = n;
      s.appendChild(rect);
      x += width;
      n += stepSize;
    }
    this.el.appendChild(s);
    return this;
  },
  _onclick: function(evt) {
    var i, j, ref, results, rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    results = [];
    for (i = j = 0, ref = stepSize - 1; j <= ref; i = j += 1) {
      results.push(this.g.trigger("bar:click", {
        rowPos: rowPos + i,
        evt: evt
      }));
    }
    return results;
  },
  manageEvents: function() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onmousein: function(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("bar:mousein", {
      rowPos: rowPos,
      evt: evt
    });
  },
  _onmouseout: function(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("bar:mouseout", {
      rowPos: rowPos,
      evt: evt
    });
  }
});

module.exports = ConservationView;



},{"../../utils/svg":135,"backbone-viewj":9,"dom-helper":66}],147:[function(require,module,exports){
var ConservationView, dom, svg, view;

view = require("backbone-viewj");

dom = require("dom-helper");

svg = require("../../utils/svg");

ConservationView = view.extend({
  className: "biojs_msa_gapview",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    this.listenTo(this.g.columns, "change:scaling", this.render);
    this.listenTo(this.model, "reset", this.render);
    return this.manageEvents();
  },
  render: function() {
    var avgHeight, cellWidth, gaps, height, hidden, i, j, maxHeight, n, nMax, rect, ref, s, stepSize, width, x;
    gaps = this.g.stats.gaps();
    dom.removeAllChilds(this.el);
    nMax = this.model.getMaxLength();
    cellWidth = this.g.zoomer.get("columnWidth");
    maxHeight = 20;
    width = cellWidth * (nMax - this.g.columns.get('hidden').length);
    s = svg.base({
      height: maxHeight,
      width: width
    });
    s.style.display = "inline-block";
    s.style.cursor = "pointer";
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    x = 0;
    n = 0;
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        n += stepSize;
        continue;
      }
      width = cellWidth * stepSize;
      avgHeight = 0;
      for (i = j = 0, ref = stepSize - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        avgHeight += gaps[n];
      }
      height = maxHeight * (avgHeight / stepSize);
      rect = svg.rect({
        x: x,
        y: maxHeight - height,
        width: width - cellWidth / 4,
        height: height,
        style: "stroke:red;stroke-width:1;"
      });
      rect.rowPos = n;
      s.appendChild(rect);
      x += width;
      n += stepSize;
    }
    this.el.appendChild(s);
    return this;
  },
  _onclick: function(evt) {
    var i, j, ref, results, rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    results = [];
    for (i = j = 0, ref = stepSize - 1; j <= ref; i = j += 1) {
      results.push(this.g.trigger("gap:click", {
        rowPos: rowPos + i,
        evt: evt
      }));
    }
    return results;
  },
  manageEvents: function() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onmousein: function(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("gap:mousein", {
      rowPos: rowPos,
      evt: evt
    });
  },
  _onmouseout: function(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("gap:mouseout", {
      rowPos: rowPos,
      evt: evt
    });
  }
});

module.exports = ConservationView;



},{"../../utils/svg":135,"backbone-viewj":9,"dom-helper":66}],148:[function(require,module,exports){
var LabelHeader, RightLabelHeader, boneView;

boneView = require("backbone-childs");

LabelHeader = require("./LabelHeader");

RightLabelHeader = require("./RightHeaderBlock");

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.draw();
    return this.listenTo(this.g.vis, "change:labels change:metacell change:leftHeader", (function(_this) {
      return function() {
        _this.draw();
        return _this.render();
      };
    })(this));
  },
  draw: function() {
    var lHeader, rHeader;
    this.removeViews();
    if (this.g.vis.get("leftHeader") && (this.g.vis.get("labels") || this.g.vis.get("metacell"))) {
      lHeader = new LabelHeader({
        model: this.model,
        g: this.g
      });
      lHeader.ordering = -50;
      this.addView("lHeader", lHeader);
    }
    rHeader = new RightLabelHeader({
      model: this.model,
      g: this.g
    });
    rHeader.ordering = 0;
    return this.addView("rHeader", rHeader);
  },
  render: function() {
    this.renderSubviews();
    return this.el.className = "biojs_msa_header";
  }
});



},{"./LabelHeader":149,"./RightHeaderBlock":151,"backbone-childs":2}],149:[function(require,module,exports){
var LabelHeader, dom, k, view;

k = require("koala-js");

view = require("backbone-viewj");

dom = require("dom-helper");

module.exports = LabelHeader = view.extend({
  className: "biojs_msa_headers",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.vis, "change:metacell change:labels", this.render);
    return this.listenTo(this.g.zoomer, "change:labelWidth change:metaWidth", this.render);
  },
  render: function() {
    var width;
    dom.removeAllChilds(this.el);
    width = 0;
    width += this.g.zoomer.getLeftBlockWidth();
    this.el.style.width = width + "px";
    if (this.g.vis.get("labels")) {
      this.el.appendChild(this.labelDOM());
    }
    if (this.g.vis.get("metacell")) {
      this.el.appendChild(this.metaDOM());
    }
    this.el.style.display = "inline-block";
    this.el.style.fontSize = this.g.zoomer.get("markerFontsize");
    return this;
  },
  labelDOM: function() {
    var labelHeader, name;
    labelHeader = k.mk("div");
    labelHeader.style.width = this.g.zoomer.getLabelWidth();
    labelHeader.style.display = "inline-block";
    if (this.g.vis.get("labelCheckbox")) {
      labelHeader.appendChild(this.addEl(".", 10));
    }
    if (this.g.vis.get("labelId")) {
      labelHeader.appendChild(this.addEl("id", this.g.zoomer.get("labelIdLength")));
    }
    if (this.g.vis.get("labelPartition")) {
      labelHeader.appendChild(this.addEl("part", 15));
    }
    if (this.g.vis.get("labelName")) {
      name = this.addEl("name");
      labelHeader.appendChild(name);
    }
    return labelHeader;
  },
  addEl: function(content, width) {
    var id;
    id = document.createElement("span");
    id.textContent = content;
    if (width != null) {
      id.style.width = width + "px";
    }
    id.style.display = "inline-block";
    return id;
  },
  metaDOM: function() {
    var metaHeader;
    metaHeader = k.mk("div");
    metaHeader.style.width = this.g.zoomer.getMetaWidth();
    metaHeader.style.display = "inline-block";
    if (this.g.vis.get("metaGaps")) {
      metaHeader.appendChild(this.addEl("gaps", this.g.zoomer.get('metaGapWidth')));
    }
    if (this.g.vis.get("metaIdentity")) {
      metaHeader.appendChild(this.addEl("ident", this.g.zoomer.get('metaIdentWidth')));
    }
    if (this.g.vis.get("metaLinks")) {
      metaHeader.appendChild(this.addEl("links"));
    }
    return metaHeader;
  }
});



},{"backbone-viewj":9,"dom-helper":66,"koala-js":68}],150:[function(require,module,exports){
var HeaderView, dom, jbone, svg, view;

view = require("backbone-viewj");

dom = require("dom-helper");

svg = require("../../utils/svg");

jbone = require("jbone");

HeaderView = view.extend({
  className: "biojs_msa_marker",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth change:markerStepSize change:markerFontsize", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    return this.manageEvents();
  },
  render: function() {
    var cellWidth, container, hidden, n, nMax, span, stepSize;
    dom.removeAllChilds(this.el);
    this.el.style.fontSize = this.g.zoomer.get("markerFontsize");
    container = document.createElement("span");
    n = 0;
    cellWidth = this.g.zoomer.get("columnWidth");
    nMax = this.model.getMaxLength();
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        this.markerHidden(span, n, stepSize);
        n += stepSize;
        continue;
      }
      span = document.createElement("span");
      span.style.width = (cellWidth * stepSize) + "px";
      span.style.display = "inline-block";
      if ((n + 1) % this.g.zoomer.get('markerStepSize') === 0) {
        span.textContent = n + 1;
      } else {
        span.textContent = ".";
      }
      span.rowPos = n;
      n += stepSize;
      container.appendChild(span);
    }
    this.el.appendChild(container);
    return this;
  },
  markerHidden: function(span, n, stepSize) {
    var hidden, i, index, j, k, length, min, nMax, prevHidden, ref, ref1, ref2, ref3, s, triangle;
    hidden = this.g.columns.get("hidden").slice(0);
    min = Math.max(0, n - stepSize);
    prevHidden = true;
    for (j = i = ref = min, ref1 = n; i <= ref1; j = i += 1) {
      prevHidden &= hidden.indexOf(j) >= 0;
    }
    if (prevHidden) {
      return;
    }
    nMax = this.model.getMaxLength();
    length = 0;
    index = -1;
    for (n = k = ref2 = n, ref3 = nMax; k <= ref3; n = k += 1) {
      if (!(index >= 0)) {
        index = hidden.indexOf(n);
      }
      if (hidden.indexOf(n) >= 0) {
        length++;
      } else {
        break;
      }
    }
    s = svg.base({
      height: 10,
      width: 10
    });
    s.style.position = "relative";
    triangle = svg.polygon({
      points: "0,0 5,5 10,0",
      style: "fill:lime;stroke:purple;stroke-width:1"
    });
    jbone(triangle).on("click", (function(_this) {
      return function(evt) {
        hidden.splice(index, length);
        return _this.g.columns.set("hidden", hidden);
      };
    })(this));
    s.appendChild(triangle);
    span.appendChild(s);
    return s;
  },
  manageEvents: function() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onclick: function(evt) {
    var rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:click", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  },
  _onmousein: function(evt) {
    var rowPos, stepSize;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:mousein", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  },
  _onmouseout: function(evt) {
    var rowPos, stepSize;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:mouseout", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  }
});

module.exports = HeaderView;



},{"../../utils/svg":135,"backbone-viewj":9,"dom-helper":66,"jbone":67}],151:[function(require,module,exports){
var ConservationView, GapView, MarkerView, SeqLogoWrapper, _, boneView;

MarkerView = require("./MarkerView");

ConservationView = require("./ConservationView");

boneView = require("backbone-childs");

_ = require('underscore');

SeqLogoWrapper = require("./SeqLogoWrapper");

GapView = require("./GapView");

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.blockEvents = false;
    this.listenTo(this.g.vis, "change:header", function() {
      this.draw();
      return this.render();
    });
    this.listenTo(this.g.vis, "change", this._setSpacer);
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this._setWidth);
    this.listenTo(this.g.zoomer, "change:_alignmentScrollLeft", this._adjustScrollingLeft);
    this.listenTo(this.g.columns, "change:hidden", function() {
      this.draw();
      return this.render();
    });
    this.draw();
    return this.g.vis.once('change:loaded', this._adjustScrollingLeft, this);
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  draw: function() {
    var conserv, gapview, marker, seqlogo;
    this.removeViews();
    if (this.g.vis.get("conserv")) {
      conserv = new ConservationView({
        model: this.model,
        g: this.g
      });
      conserv.ordering = -20;
      this.addView("conserv", conserv);
    }
    if (this.g.vis.get("markers")) {
      marker = new MarkerView({
        model: this.model,
        g: this.g
      });
      marker.ordering = -10;
      this.addView("marker", marker);
    }
    if (this.g.vis.get("seqlogo")) {
      seqlogo = new SeqLogoWrapper({
        model: this.model,
        g: this.g
      });
      seqlogo.ordering = -30;
      this.addView("seqlogo", seqlogo);
    }
    if (this.g.vis.get("gapHeader")) {
      gapview = new GapView({
        model: this.model,
        g: this.g
      });
      gapview.ordering = -25;
      return this.addView("gapview", gapview);
    }
  },
  render: function() {
    this.renderSubviews();
    this._setSpacer();
    this.el.className = "biojs_msa_rheader";
    this.el.style.overflowX = "auto";
    this.el.style.display = "inline-block";
    this._setWidth();
    this._adjustScrollingLeft();
    return this;
  },
  _sendScrollEvent: function() {
    if (!this.blockEvents) {
      this.g.zoomer.set("_alignmentScrollLeft", this.el.scrollLeft, {
        origin: "header"
      });
    }
    return this.blockEvents = false;
  },
  _adjustScrollingLeft: function(model, value, options) {
    var scrollLeft;
    if (((options != null ? options.origin : void 0) == null) || options.origin !== "header") {
      scrollLeft = this.g.zoomer.get("_alignmentScrollLeft");
      this.blockEvents = true;
      return this.el.scrollLeft = scrollLeft;
    }
  },
  _setSpacer: function() {
    return this.el.style.marginLeft = this._getLabelWidth() + "px";
  },
  _getLabelWidth: function() {
    var paddingLeft;
    paddingLeft = 0;
    if (!this.g.vis.get("leftHeader")) {
      paddingLeft += this.g.zoomer.getLeftBlockWidth();
    }
    return paddingLeft;
  },
  _setWidth: function() {
    return this.el.style.width = this.g.zoomer.getAlignmentWidth() + "px";
  }
});



},{"./ConservationView":146,"./GapView":147,"./MarkerView":150,"./SeqLogoWrapper":152,"backbone-childs":2,"underscore":91}],152:[function(require,module,exports){
var SeqLogoView, view;

SeqLogoView = require("biojs-vis-seqlogo/light");

view = require("backbone-viewj");

module.exports = view.extend({
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this.render);
    this.listenTo(this.g.colorscheme, "change", function() {
      var colors;
      colors = this.g.colorscheme.getSelectedScheme();
      this.seqlogo.changeColors(colors);
      return this.render();
    });
    this.listenTo(this.g.zoomer, "change:columnWidth", function() {
      return this.seqlogo.column_width = this.g.zoomer.get('columnWidth');
    });
    this.render;
    return this.draw();
  },
  draw: function() {
    var arr, colors, data;
    console.log("redraw");
    arr = this.g.stats.conservResidue({
      scaled: true
    });
    arr = _.map(arr, function(el) {
      return _.pick(el, function(e, k) {
        return k !== "-";
      });
    });
    data = {
      alphabet: "aa",
      heightArr: arr
    };
    colors = this.g.colorscheme.getSelectedScheme();
    return this.seqlogo = new SeqLogoView({
      model: this.model,
      g: this.g,
      data: data,
      yaxis: false,
      scroller: false,
      xaxis: false,
      height: 100,
      column_width: this.g.zoomer.get('columnWidth'),
      positionMarker: false,
      zoom: 1,
      el: this.el,
      colors: colors
    });
  },
  render: function() {
    return this.seqlogo.render();
  }
});



},{"backbone-viewj":9,"biojs-vis-seqlogo/light":47}],153:[function(require,module,exports){
var LabelRowView, boneView;

LabelRowView = require("./LabelRowView");

boneView = require("backbone-childs");

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.zoomer, "change:_alignmentScrollTop", this._adjustScrollingTop);
    this.g.vis.once('change:loaded', this._adjustScrollingTop, this);
    this.listenTo(this.g.zoomer, "change:alignmentHeight", this._setHeight);
    return this.listenTo(this.model, "change:reference", this.draw);
  },
  draw: function() {
    var i, j, ref, results, view;
    this.removeViews();
    results = [];
    for (i = j = 0, ref = this.model.length - 1; j <= ref; i = j += 1) {
      if (this.model.at(i).get('hidden')) {
        continue;
      }
      view = new LabelRowView({
        model: this.model.at(i),
        g: this.g
      });
      view.ordering = i;
      results.push(this.addView("row_" + i, view));
    }
    return results;
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  _sendScrollEvent: function() {
    return this.g.zoomer.set("_alignmentScrollTop", this.el.scrollTop, {
      origin: "label"
    });
  },
  _adjustScrollingTop: function() {
    return this.el.scrollTop = this.g.zoomer.get("_alignmentScrollTop");
  },
  render: function() {
    this.renderSubviews();
    this.el.className = "biojs_msa_labelblock";
    this.el.style.display = "inline-block";
    this.el.style.verticalAlign = "top";
    this.el.style.overflowY = "auto";
    this.el.style.overflowX = "hidden";
    this.el.style.fontSize = (this.g.zoomer.get('labelFontsize')) + "px";
    this.el.style.lineHeight = "" + (this.g.zoomer.get("labelLineHeight"));
    this._setHeight();
    return this;
  },
  _setHeight: function() {
    return this.el.style.height = this.g.zoomer.get("alignmentHeight") + "px";
  }
});



},{"./LabelRowView":154,"backbone-childs":2}],154:[function(require,module,exports){
var LabelView, MetaView, boneView;

boneView = require("backbone-childs");

LabelView = require("./LabelView");

MetaView = require("./MetaView");

module.exports = boneView.extend({
  initialize: function(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.vis, "change:labels", this.drawR);
    this.listenTo(this.g.vis, "change:metacell", this.drawR);
    this.listenTo(this.g.zoomer, "change:rowHeight", function() {
      return this.el.style.height = this.g.zoomer.get("rowHeight") + "px";
    });
    return this.listenTo(this.g.selcol, "change reset add", this.setSelection);
  },
  draw: function() {
    var meta;
    this.removeViews();
    if (this.g.vis.get("labels")) {
      this.addView("labels", new LabelView({
        model: this.model,
        g: this.g
      }));
    }
    if (this.g.vis.get("metacell")) {
      meta = new MetaView({
        model: this.model,
        g: this.g
      });
      return this.addView("metacell", meta);
    }
  },
  drawR: function() {
    this.draw();
    return this.render();
  },
  render: function() {
    this.renderSubviews();
    this.el.setAttribute("class", "biojs_msa_labelrow");
    this.el.style.height = this.g.zoomer.get("rowHeight") * (this.model.attributes.height || 1) + "px";
    this.setSelection();
    return this;
  },
  setSelection: function() {
    var sel;
    sel = this.g.selcol.getSelForRow(this.model.id);
    if (sel.length > 0) {
      return this.el.style.fontWeight = "bold";
    } else {
      return this.el.style.fontWeight = "normal";
    }
  }
});



},{"./LabelView":155,"./MetaView":156,"backbone-childs":2}],155:[function(require,module,exports){
var LabelView, dom, view;

view = require("backbone-viewj");

dom = require("dom-helper");

LabelView = view.extend({
  initialize: function(data) {
    this.seq = data.seq;
    this.g = data.g;
    return this.manageEvents();
  },
  manageEvents: function() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
    this.listenTo(this.g.vis, "change:labelName change:labelId change:labelPartition change:labelCheckbox", this.render);
    this.listenTo(this.g.zoomer, "change:labelIdLength change:labelNameLength change:labelPartLength change:labelCheckLength", this.render);
    return this.listenTo(this.g.zoomer, "change:labelFontSize change:labelLineHeight change:labelWidth change:rowHeight", this.render);
  },
  render: function() {
    var checkBox, id, name, part, val;
    dom.removeAllChilds(this.el);
    this.el.style.width = (this.g.zoomer.getLabelWidth()) + "px";
    this.el.setAttribute("class", "biojs_msa_labels");
    if (this.g.vis.get("labelCheckbox")) {
      checkBox = document.createElement("input");
      checkBox.setAttribute("type", "checkbox");
      checkBox.value = this.model.get('id');
      checkBox.name = "seq";
      checkBox.style.width = this.g.zoomer.get("labelCheckLength") + "px";
      this.el.appendChild(checkBox);
    }
    if (this.g.vis.get("labelId")) {
      id = document.createElement("span");
      val = this.model.get("id");
      if (!isNaN(val)) {
        val++;
      }
      id.textContent = val;
      id.style.width = this.g.zoomer.get("labelIdLength") + "px";
      id.style.display = "inline-block";
      this.el.appendChild(id);
    }
    if (this.g.vis.get("labelPartition")) {
      part = document.createElement("span");
      part.style.width = this.g.zoomer.get("labelPartLength") + "px";
      part.textContent = this.model.get("partition");
      part.style.display = "inline-block";
      this.el.appendChild(id);
      this.el.appendChild(part);
    }
    if (this.g.vis.get("labelName")) {
      name = document.createElement("span");
      name.textContent = this.model.get("name");
      if (this.model.get("ref") && this.g.config.get("hasRef")) {
        name.style.fontWeight = "bold";
      }
      name.style.width = this.g.zoomer.get("labelNameLength") + "px";
      this.el.appendChild(name);
    }
    this.el.style.overflow = scroll;
    this.el.style.fontSize = (this.g.zoomer.get('labelFontsize')) + "px";
    return this;
  },
  _onclick: function(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:click", {
      seqId: seqId,
      evt: evt
    });
  },
  _onmousein: function(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:mouseout", {
      seqId: seqId,
      evt: evt
    });
  },
  _onmouseout: function(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:mouseout", {
      seqId: seqId,
      evt: evt
    });
  }
});

module.exports = LabelView;



},{"backbone-viewj":9,"dom-helper":66}],156:[function(require,module,exports){
var MenuBuilder, MetaView, _, dom, st, view;

view = require("backbone-viewj");

MenuBuilder = require("../../menu/menubuilder");

_ = require('underscore');

dom = require("dom-helper");

st = require("msa-seqtools");

module.exports = MetaView = view.extend({
  className: "biojs_msa_metaview",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.vis, "change:metacell", this.render);
    return this.listenTo(this.g.zoomer, "change:metaWidth", this.render);
  },
  events: {
    click: "_onclick",
    mousein: "_onmousein",
    mouseout: "_onmouseout"
  },
  render: function() {
    var gapSpan, gaps, ident, identSpan, linkEl, links, menu, seq, width;
    dom.removeAllChilds(this.el);
    this.el.style.display = "inline-block";
    width = this.g.zoomer.getMetaWidth();
    this.el.style.width = width - 10;
    this.el.style.paddingRight = 5;
    this.el.style.paddingLeft = 5;
    this.el.style.fontSize = (this.g.zoomer.get('labelFontsize') - 2) + "px";
    if (this.g.vis.get("metaGaps")) {
      seq = this.model.get('seq');
      gaps = _.reduce(seq, (function(memo, c) {
        if (c === '-') {
          memo++;
        }
        return memo;
      }), 0);
      gaps = (gaps / seq.length).toFixed(1);
      gapSpan = document.createElement('span');
      gapSpan.textContent = gaps;
      gapSpan.style.display = "inline-block";
      gapSpan.style.width = 35;
      this.el.appendChild(gapSpan);
    }
    if (this.g.vis.get("metaIdentity")) {
      ident = this.g.stats.identity()[this.model.id];
      identSpan = document.createElement('span');
      if (this.model.get("ref") && this.g.config.get("hasRef")) {
        identSpan.textContent = "ref.";
      } else if (ident != null) {
        identSpan.textContent = ident.toFixed(2);
      }
      identSpan.style.display = "inline-block";
      identSpan.style.width = 40;
      this.el.appendChild(identSpan);
    }
    if (this.g.vis.get("metaLinks")) {
      if (this.model.attributes.ids) {
        links = st.buildLinks(this.model.attributes.ids);
        if (_.keys(links).length > 0) {
          menu = new MenuBuilder({
            name: "â†—"
          });
          console.log(_.keys(links));
          _.each(links, function(val, key) {
            return menu.addNode(key, function(e) {
              return window.open(val);
            });
          });
          linkEl = menu.buildDOM();
          linkEl.style.cursor = "pointer";
          return this.el.appendChild(linkEl);
        }
      }
    }
  },
  _onclick: function(evt) {
    return this.g.trigger("meta:click", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmousein: function(evt) {
    return this.g.trigger("meta:mousein", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmouseout: function(evt) {
    return this.g.trigger("meta:mouseout", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  }
});



},{"../../menu/menubuilder":111,"backbone-viewj":9,"dom-helper":66,"msa-seqtools":89,"underscore":91}],"biojs-io-clustal":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var Clustal, GenericReader, st;

GenericReader = require("biojs-io-parser");

st = require("msa-seqtools");

module.exports = Clustal = {
  parse: function(text) {
    var blockstate, cSeq, k, keys, label, line, lines, match, obj, regex, seqCounter, seqs, sequence;
    seqs = [];
    if (Object.prototype.toString.call(text) === '[object Array]') {
      lines = text;
    } else {
      lines = text.split("\n");
    }
    if (lines[0].slice(0, 6) === !"CLUSTAL") {
      throw new Error("Invalid CLUSTAL Header");
    }
    k = 0;
    blockstate = 1;
    seqCounter = 0;
    while (k < lines.length) {
      k++;
      line = lines[k];
      if ((line == null) || line.length === 0) {
        blockstate = 1;
        continue;
      }
      if (line.trim().length === 0) {
        blockstate = 1;
        continue;
      } else {
        if (st.contains(line, "*")) {
          continue;
        }
        if (blockstate === 1) {
          seqCounter = 0;
          blockstate = 0;
        }
        regex = /^(?:\s*)(\S+)(?:\s+)(\S+)(?:\s*)(\d*)(?:\s*|$)/g;
        match = regex.exec(line);
        if (match != null) {
          label = match[1];
          sequence = match[2];
          if (seqCounter >= seqs.length) {
            obj = st.getMeta(label);
            label = obj.name;
            cSeq = new st.model(sequence, label, seqCounter);
            cSeq.ids = obj.ids || {};
            cSeq.details = obj.details || {};
            keys = Object.keys(cSeq.ids);
            if (keys.length > 0) {
              cSeq.id = cSeq.ids[keys[0]];
            }
            seqs.push(cSeq);
          } else {
            seqs[seqCounter].seq += sequence;
          }
          seqCounter++;
        } else {
          console.log("parse error", line);
        }
      }
    }
    return seqs;
  }
};

GenericReader.mixin(Clustal);

},{"biojs-io-parser":16,"msa-seqtools":89}],"biojs-io-fasta":[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
var Fasta, GenericReader, st;

GenericReader = require("biojs-io-parser");

st = require("msa-seqtools");

module.exports = Fasta = {
  parse: function(text) {
    var currentSeq, keys, label, line, obj, seqs, _i, _len;
    seqs = [];
    if (!text || text.length === 0) {
      return [];
    }
    if (Object.prototype.toString.call(text) !== '[object Array]') {
      text = text.split("\n");
    }
    for (_i = 0, _len = text.length; _i < _len; _i++) {
      line = text[_i];
      if (line[0] === ">" || line[0] === ";") {
        label = line.slice(1);
        obj = st.getMeta(label);
        label = obj.name;
        currentSeq = new st.model("", label, seqs.length);
        currentSeq.ids = obj.ids || {};
        keys = Object.keys(currentSeq.ids);
        if (keys.length > 0) {
          currentSeq.id = currentSeq.ids[keys[0]];
        }
        currentSeq.details = obj.details || {};
        seqs.push(currentSeq);
      } else {
        currentSeq.seq += line;
      }
    }
    return seqs;
  },
  write: function(seqs, access) {
    var seq, text, _i, _len;
    text = "";
    for (_i = 0, _len = seqs.length; _i < _len; _i++) {
      seq = seqs[_i];
      if (access != null) {
        seq = access(seq);
      }
      text += ">" + seq.name + "\n";
      text += (st.splitNChars(seq.seq, 80)).join("\n");
      text += "\n";
    }
    return text;
  }
};

GenericReader.mixin(Fasta);

},{"biojs-io-parser":25,"msa-seqtools":89}],"biojs-io-gff":[function(require,module,exports){
/*
 * biojs-io-gff
 * https://github.com/greenify/biojs-io-gff
 *
 * Copyright (c) 2014 greenify
 * Licensed under the Apache 2 license.
 */

var parser = require("biojs-io-parser");

var gff = function() {};
parser.mixin(gff);

module.exports = gff;

var utils = require("./utils");
var jalview = require("./jalview");

/**
 * Method responsible to parse GFF
 * @see https://www.sanger.ac.uk/resources/software/gff/spec.html#t_2
 *
 * @example
 *
 *     biojsiogff.parse('SEQ1  EMBL  atg  103  105  .  +  0');
 *
 * @method parse
 * @param {String} file GFF file
 * @return {String} Returns JSON representation
 */

gff.parseLines = function(file) {
  var lines = file.split("\n");
  var config = {};
  var arr = [];
  config.type = gff._guessType(lines);
  var offset = 0;
  if (config.type === "jalview") {
    var ret = jalview.readHeader(lines);
    //console.log(ret);
    offset = ret.offset;
    config.colors = ret.colors;
    arr = ret.features;
  }
  for (var i = offset; i < lines.length; i++) {
    // ignore comments for now
    var line = lines[i];
    if (line.length === 0 || line[0] === "#")
      continue;

    line = gff.parseLine(line);
    if (line !== undefined)
      arr.push(line);
  }
  return {
    features: arr,
    config: config
  };
};

gff._guessType = function(line) {
  if (line[0].substring(0, 15) === "##gff-version 3") {
    return "gff3";
  } else if (line[0].indexOf("#") < 0 && line[0].split("\t").length === 2) {
    // no comments and two columns. let's hope this is from jalview
    return "jalview";
  }
  // unable to read file header. lets hope this is gff3
  return "gff3";
};

/**
 * parses GFF and returns a dictionary of all seqs with their features
 * @method parseSeqs
 * @param {String} file GFF file
 * @return {String} Returns dictionary of sequences with an array of their features
 */
gff.parseSeqs = gff.parse = function(file) {
  var obj = gff.parseLines (file);
  var seqs = {};
  obj.features.forEach(function(entry) {
    var key = entry.seqname;
    if (seqs[key] === undefined) seqs[key] = [];
    delete entry.seqname;
    seqs[key].push(entry);
  });
  delete obj.features;
  obj.seqs = seqs;
  return obj;
};

/*
 * parses one GFF line and returns it
 */
gff.parseLine = function(line) {
  var tLine = {};

  var columns = line.split(/\s+/);
  // ignore empty lines
  if (columns.length === 1)
    return;

  tLine.seqname = columns[0];
  tLine.source = columns[1];
  tLine.feature = columns[2];
  tLine.start = parseInt(columns[3]);
  tLine.end = parseInt(columns[4]);
  tLine.score = columns[5]; // only DNA,RNA
  tLine.strand = columns[6]; // only DNA,RNA
  tLine.frame = columns[7]; // only DNA,RNA
  var attr = columns.slice(8).join(" "); // plain text comments

  // remove undefined (dot)
  Object.keys(tLine).forEach(function(key) {
    if (tLine[key] === ".") {
      tLine[key] = undefined;
    }
  });

  // parse optional parameters
  if (tLine.score) {
    tLine.score = parseFloat(tLine.score);
  }
  if (tLine.frame) {
    tLine.frame = parseInt(tLine.frame);
  }

  tLine.attributes = utils.extractKeys(attr);
  return tLine;
};

gff.exportLine = function(line) {
  var attrs = Object.keys(line.attributes).map(function(key) {
    return key + "=" + line.attributes[key];
  }).join(";");
  var cells = [line.seqname, line.source, line.feature, line.start, line.end, line.score,
    line.strand, line.frame, attrs
  ];
  cells = cells.map(function(e) {
    if (e === undefined) {
      return ".";
    }
    return e;
  });
  return cells.join("\t");
};

gff.exportLines = function(lines) {
  return "##gff-version 3\n" + lines.map(gff.exportLine).join("\n");
};

gff.exportSeqs = gff.export = function(seqs) {
  var lines = [];
  var pLine = function(e) {
    e.seqname = key;
    lines.push(e);
  };

  for (var key in seqs) {
    seqs[key].forEach(pLine);
  }
  return gff.exportLines(lines);
};

},{"./jalview":34,"./utils":35,"biojs-io-parser":36}],"msa":[function(require,module,exports){
// browser globals
if (typeof biojs === 'undefined') {
  biojs = {};
}
if (typeof biojs.vis === 'undefined') {
  biojs.vis = {};
}
// use two namespaces
window.msa = biojs.vis.msa = module.exports = require('./src/index');

// TODO: how should this be bundled

if (typeof biojs.io === 'undefined') {
  biojs.io = {};
}

// just bundle the two parsers
window.biojs.io.fasta = require("biojs-io-fasta");
window.biojs.io.clustal = require("biojs-io-clustal");
window.biojs.xhr = require("xhr");

module.exports = require("./src/index");

require('./css/msa.css');

},{"./css/msa.css":1,"./src/index":108,"biojs-io-clustal":"biojs-io-clustal","biojs-io-fasta":"biojs-io-fasta","xhr":"xhr"}],"xhr":[function(require,module,exports){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status, body) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        }

        return error
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode()
        var body = getBody()
        var error = errorFromStatusCode(status, body)
        var response = {
            body: body,
            statusCode: status,
            statusText: xhr.statusText,
            raw: xhr
        }
        if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
            response.headers = parseHeaders(xhr.getAllResponseHeaders())
        } else {
            response.headers = {}
        }

        callback(error, response, response.body)
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status
        xhr.body = getBody()
        xhr.headers = parseHeaders(xhr.getAllResponseHeaders())

        callback(error, xhr, xhr.body)
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

},{"global/window":92,"once":93,"parse-headers":97}]},{},["msa"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjc3MvbXNhLmNzcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS1jaGlsZHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUtdGhpbi9jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhY2tib25lLXRoaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUtdGhpbi9tb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS10aGluL25vZGVfbW9kdWxlcy9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZS9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS10aGluL25vZGVfbW9kdWxlcy9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS10aGluL25vZGVfbW9kdWxlcy9iYWNrYm9uZS1leHRlbmQtc3RhbmRhbG9uZS9iYWNrYm9uZS1leHRlbmQtc3RhbmRhbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS12aWV3ai9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy1ldmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tY2x1c3RhbC9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy1pby1jbHVzdGFsL25vZGVfbW9kdWxlcy9iaW9qcy1pby1wYXJzZXIvbm9kZV9tb2R1bGVzL3Zvdy9saWIvdm93LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWNsdXN0YWwvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLXBhcnNlci9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWNsdXN0YWwvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLXBhcnNlci9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWNsdXN0YWwvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLXBhcnNlci9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tY2x1c3RhbC9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWNsdXN0YWwvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLXBhcnNlci9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tY2x1c3RhbC9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tY2x1c3RhbC9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy1pby1mYXN0YS9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy92b3cvbGliL3Zvdy5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy1pby1mYXN0YS9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tZ2ZmL2xpYi9qYWx2aWV3LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWdmZi9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tZ2ZmL25vZGVfbW9kdWxlcy9iaW9qcy1pby1wYXJzZXIvbm9kZV9tb2R1bGVzL3Zvdy9saWIvdm93LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWdmZi9ub2RlX21vZHVsZXMvYmlvanMtaW8tcGFyc2VyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvYmlvanMtbW9kZWwvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLW1vZGVsL3NyYy9zZXEuanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vbGlnaHQuanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vc3JjL2F4aXMuanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vc3JjL2NhbnZhc1N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vc3JjL2NvbG9ycy9hYS5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvY29sb3JzL2RuYS5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvZXZlbnRMaXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vc3JjL2luZm8vc2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvYmlvanMtdmlzLXNlcWxvZ28vc3JjL21vZGVsL2xldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvcmVuZGVyL2RyYXcvYm9yZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLXZpcy1zZXFsb2dvL3NyYy9yZW5kZXIvZHJhdy9jb2x1bW5fbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLXZpcy1zZXFsb2dvL3NyYy9yZW5kZXIvZHJhdy90aWNrcy5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvcmVuZGVyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9iaW9qcy12aXMtc2VxbG9nby9zcmMvcmVuZGVyL3JlbmRlcl93aXRoX3JlY3RzLmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLXZpcy1zZXFsb2dvL3NyYy9yZW5kZXIvcmVuZGVyX3dpdGhfdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlaW1wX2NhbnZhc3RvYmxvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXNhdmVhcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY3NzaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZG9tLWhlbHBlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qYm9uZS9kaXN0L2pib25lLmpzIiwibm9kZV9tb2R1bGVzL2tvYWxhLWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lbnUtYnVpbGRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZW51LWJ1aWxkZXIvbGliL21lbnVidWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXNlLXBvcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tc2EtY29sb3JzY2hlbWVzL3NyYy9idXJpZWQuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvY2luZW1hLmpzIiwibm9kZV9tb2R1bGVzL21zYS1jb2xvcnNjaGVtZXMvc3JjL2NsdXN0YWwuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvY2x1c3RhbDIuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvaGVsaXguanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvaHlkcm9waG9iaWNpdHkuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvbGVzay5qcyIsIm5vZGVfbW9kdWxlcy9tc2EtY29sb3JzY2hlbWVzL3NyYy9tYWUuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvbnVjbGVvdGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9tc2EtY29sb3JzY2hlbWVzL3NyYy9waWRfY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL21zYS1jb2xvcnNjaGVtZXMvc3JjL3B1cmluZS5qcyIsIm5vZGVfbW9kdWxlcy9tc2EtY29sb3JzY2hlbWVzL3NyYy9zY2hlbWVjbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9tc2EtY29sb3JzY2hlbWVzL3NyYy9zdHJhbmQuanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvdGF5bG9yLmpzIiwibm9kZV9tb2R1bGVzL21zYS1jb2xvcnNjaGVtZXMvc3JjL3R1cm4uanMiLCJub2RlX21vZHVsZXMvbXNhLWNvbG9yc2NoZW1lcy9zcmMvemFwcG8uanMiLCJub2RlX21vZHVsZXMvbXNhLXNlcXRvb2xzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdGF0LnNlcXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9nL2NvbG9yc2NoZW1lLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL2cvY29sdW1ucy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9nL2NvbmZpZy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9nL3BhY2thZ2UuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvZy9zZWxlY3Rpb24vU2VsZWN0aW9uLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL2cvc2VsZWN0aW9uL1NlbGVjdGlvbkNvbC5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9nL3VzZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvZy92aXNPcmRlcmluZy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9nL3Zpc2liaWxpdHkuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvZy96b29tZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvaW5kZXguY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbWVudS9kZWZhdWx0bWVudS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9tZW51L2luZGV4LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21lbnUvbWVudWJ1aWxkZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbWVudS92aWV3cy9Db2xvck1lbnUuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbWVudS92aWV3cy9EZWJ1Z01lbnUuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbWVudS92aWV3cy9FeHBvcnRNZW51LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21lbnUvdmlld3MvRXh0cmFNZW51LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21lbnUvdmlld3MvRmlsdGVyTWVudS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9tZW51L3ZpZXdzL0hlbHBNZW51LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21lbnUvdmlld3MvSW1wb3J0TWVudS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9tZW51L3ZpZXdzL09yZGVyaW5nTWVudS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9tZW51L3ZpZXdzL1NlbGVjdGlvbk1lbnUuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbWVudS92aWV3cy9WaXNNZW51LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21vZGVsL0ZlYXR1cmUuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvbW9kZWwvRmVhdHVyZUNvbC5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy9tb2RlbC9TZXFDb2xsZWN0aW9uLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21vZGVsL1NlcXVlbmNlLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21vZGVsL2luZGV4LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL21zYS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy91dGlscy9ibWF0aC5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy91dGlscy9leHBvcnQuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdXRpbHMvZmlsZS5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy91dGlscy9pbmRleC5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy91dGlscy9sb2FkZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdXRpbHMvcHJveHkuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdXRpbHMvc2VxZ2VuLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3V0aWxzL3N2Zy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy91dGlscy90cmVlLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL0FsaWdubWVudEJvZHkuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvT3ZlcnZpZXdCb3guY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvU2VhcmNoLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL1N0YWdlLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL2NhbnZhcy9DYW52YXNDaGFyQ2FjaGUuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvY2FudmFzL0NhbnZhc0Nvb3Jkc0NhY2hlLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL2NhbnZhcy9DYW52YXNTZWxlY3Rpb24uY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvY2FudmFzL0NhbnZhc1NlcUJsb2NrLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL2NhbnZhcy9DYW52YXNTZXFEcmF3ZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvaGVhZGVyL0NvbnNlcnZhdGlvblZpZXcuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvaGVhZGVyL0dhcFZpZXcuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvaGVhZGVyL0hlYWRlckJsb2NrLmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL2hlYWRlci9MYWJlbEhlYWRlci5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy92aWV3cy9oZWFkZXIvTWFya2VyVmlldy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy92aWV3cy9oZWFkZXIvUmlnaHRIZWFkZXJCbG9jay5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy92aWV3cy9oZWFkZXIvU2VxTG9nb1dyYXBwZXIuY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvbGFiZWxzL0xhYmVsQmxvY2suY29mZmVlIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2dyZWVuaWZ5L21zYS9zcmMvdmlld3MvbGFiZWxzL0xhYmVsUm93Vmlldy5jb2ZmZWUiLCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL3NyYy92aWV3cy9sYWJlbHMvTGFiZWxWaWV3LmNvZmZlZSIsIi9ob21lL3RyYXZpcy9idWlsZC9ncmVlbmlmeS9tc2Evc3JjL3ZpZXdzL2xhYmVscy9NZXRhVmlldy5jb2ZmZWUiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tY2x1c3RhbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlvanMtaW8tZmFzdGEvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jpb2pzLWlvLWdmZi9saWIvaW5kZXguanMiLCJicm93c2VyIiwibm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNweUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNweUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNweUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGNzcyA9IFwiLyogQkFTSUMgKi9cXG5cXG4uYmlvanNfbXNhX3N0YWdlIHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgICBsaW5lLWhlaWdodDogbm9ybWFsOyBcXG59XFxuXFxuLmJpb2pzX21zYV9zZXFibG9jayB7XFxuICAgIGN1cnNvcjogbW92ZTtcXG59XFxuXFxuLmJpb2pzX21zYV9sYXllcntcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi5iaW9qc19tc2FfbGFiZWxzIHtcXG4gICAgY29sb3I6YmxhY2s7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGNsaXA7XFxuICAgIC8qbWFyZ2luOmF1dG87ICovXFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcblxcbi5iaW9qc19tc2FfaGVhZGVyIHtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXFxuLmJpb2pzX21zYV9sYWJlbHJvdzpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4uYmlvanNfbXNhX2xhYmVscm93e1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5iaW9qc19tc2FfbGFiZWxibG9jazo6LXdlYmtpdC1zY3JvbGxiYXIsIC5iaW9qc19tc2FfcmhlYWRlcjo6LXdlYmtpdC1zY3JvbGxiYXJ7XFxuICAgIC8vIEZJWCBzY3JvbGxiYXJzIG9uIE1hY1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgIHdpZHRoOiA3cHg7XFxuICAgIGhlaWdodDogN3B4O1xcbn1cXG4uYmlvanNfbXNhX2xhYmVsYmxvY2s6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iLCAuYmlvanNfbXNhX3JoZWFkZXI6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsLjUpO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMXB4IHJnYmEoMjU1LDI1NSwyNTUsLjUpO1xcbn1cXG5cXG4vKiBFTkQgQkFTSUMgKi9cXG4vKiBNYXJrZXIgKi9cXG5cXG4uYmlvanNfbXNhX21hcmtlcntcXG4gICAgY29sb3I6Z3JleTtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uYmlvanNfbXNhX21hcmtlciBzcGFue1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi8qIEVORCBNYXJrZXIgKi9cXG4vKiBNZW51YmFyICovXFxuXFxuLnNtZW51YmFyIC5zbWVudWJhcl9hbGluayB7XFxuICAgIGJhY2tncm91bmQ6ICMzNDk4ZGI7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgIzM0OThkYiwgIzI5ODBiOSk7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgIzM0OThkYiwgIzI5ODBiOSk7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjMzQ5OGRiLCAjMjk4MGI5KTtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgIzM0OThkYiwgIzI5ODBiOSk7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMzNDk4ZGIsICMyOTgwYjkpO1xcbiAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDI4O1xcbiAgICAtbW96LWJvcmRlci1yYWRpdXM6IDI4O1xcbiAgICBib3JkZXItcmFkaXVzOiAyOHB4O1xcbiAgICBmb250LWZhbWlseTogQXJpYWw7XFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcbiAgICBwYWRkaW5nOiAzcHggMTBweCAzcHggMTBweDtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLnNtZW51YmFyIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4uc21lbnViYXIgLnNtZW51YmFyX2FsaW5rOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5cXG4vKiBqcXVlcnkgZHJvcGRvd24gQ1NTICovXFxuXFxuLnNtZW51LWRyb3Bkb3duIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA5OTk5OTk5O1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uc21lbnUtZHJvcGRvd24gLnNtZW51LWRyb3Bkb3duLW1lbnUsXFxuLnNtZW51LWRyb3Bkb3duIC5zbWVudS1kcm9wZG93bi1wYW5lbCB7XFxuICAgIG1pbi13aWR0aDogMTYwcHg7XFxuICAgIG1heC13aWR0aDogMzYwcHg7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6ICNGRkY7XFxuICAgIGJvcmRlcjogc29saWQgMXB4ICNEREQ7XFxuICAgIGJvcmRlcjogc29saWQgMXB4IHJnYmEoMCwgMCwgMCwgLjIpO1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgIGJveC1zaGFkb3c6IDAgNXB4IDEwcHggcmdiYSgwLCAwLCAwLCAuMik7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICBwYWRkaW5nOiA0cHggMDtcXG4gICAgbWFyZ2luOiAwO1xcbn1cXG5cXG4uc21lbnUtZHJvcGRvd24gLnNtZW51LWRyb3Bkb3duLXBhbmVsIHtcXG4gICAgcGFkZGluZzogMTBweDtcXG59XFxuXFxuXFxuLnNtZW51LWRyb3Bkb3duLnNtZW51LWRyb3Bkb3duLXNjcm9sbCAuc21lbnUtZHJvcGRvd24tbWVudSxcXG4uc21lbnUtZHJvcGRvd24uc21lbnUtZHJvcGRvd24tc2Nyb2xsIC5zbWVudS1kcm9wZG93bi1wYW5lbCB7XFxuICAgIG1heC1oZWlnaHQ6IDM1OHB4O1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLnNtZW51LWRyb3Bkb3duIC5zbWVudS1kcm9wZG93bi1tZW51IExJIHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgcGFkZGluZzogMCAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbn1cXG5cXG4uc21lbnUtZHJvcGRvd24gLnNtZW51LWRyb3Bkb3duLW1lbnUgTEksXFxuLnNtZW51LWRyb3Bkb3duIC5zbWVudS1kcm9wZG93bi1tZW51IExBQkVMIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGNvbG9yOiAjNTU1O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgICBwYWRkaW5nOiAzcHggMTVweDtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuLnNtZW51LWRyb3Bkb3duIC5zbWVudS1kcm9wZG93bi1tZW51IExJOmhvdmVyLFxcbi5zbWVudS1kcm9wZG93biAuc21lbnUtZHJvcGRvd24tbWVudSBMQUJFTDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwOEM7XFxuICAgIGNvbG9yOiAjRkZGO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5zbWVudS1kcm9wZG93biAuc21lbnUtZHJvcGRvd24tbWVudSAuc21lbnUtZHJvcGRvd24tZGl2aWRlciB7XFxuICAgIGZvbnQtc2l6ZTogMXB4O1xcbiAgICBib3JkZXItdG9wOiBzb2xpZCAxcHggI0U1RTVFNTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgbWFyZ2luOiA1cHggMDtcXG59XFxuXFxuLyogRU5EIE1lbnViYXIgKi9cXG5cIjsgKHJlcXVpcmUoXCIvaG9tZS90cmF2aXMvYnVpbGQvZ3JlZW5pZnkvbXNhL25vZGVfbW9kdWxlcy9jc3NpZnlcIikpKGNzcyk7IG1vZHVsZS5leHBvcnRzID0gY3NzOyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIHZpZXdUeXBlID0gcmVxdWlyZShcImJhY2tib25lLXZpZXdqXCIpO1xudmFyIHBsdWdpbmF0b3I7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVsZW1lbnQgYW5kIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGluc2VydHMgaXQgaW50byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAqIEBwYXJhbSBlbGVtZW50IHtFbGVtZW50fSBUaGUgZWxlbWVudCB0byBiZSB0ZW1wb3JhcmlseSByZW1vdmVkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGluc2VydHMgdGhlIGVsZW1lbnQgaW50byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAqKi9cbmZ1bmN0aW9uIHJlbW92ZVRvSW5zZXJ0TGF0ZXIoZWxlbWVudCkge1xuICB2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHJlbW92ZUNoaWxkcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGxhc3Q7XG4gICAgd2hpbGUgKGxhc3QgPSBub2RlLmxhc3RDaGlsZCkgbm9kZS5yZW1vdmVDaGlsZChsYXN0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1Z2luYXRvciA9IHZpZXdUeXBlLmV4dGVuZCh7XG4gIHJlbmRlclN1YnZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAvLyBpdCBpcyBmYXN0ZXIgdG8gcmVtb3ZlIHRoZSBlbnRpcmUgZWxlbWVudCBhbmQgcmVwbGFjZSBpdFxuICAgIC8vIC0+IGhvd2V2ZXIgdGhpcyB3aWxsIGxlYWQgdG8gbG9zdCBpZCxjbGFzcyBhbmQgc3R5bGUgcHJvcHNcbiAgICB2YXIgb2xkRWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gaXQgbWlnaHQgYmUgdGhhdCB0aGUgZWxlbWVudCBpcyBub3Qgb24gdGhlIERPTSB5ZXRcbiAgICB2YXIgZWxPbkRvbSA9IG9sZEVsLnBhcmVudE5vZGUgIT0gdW5kZWZpbmVkO1xuICAgIGlmKGVsT25Eb20pe1xuICAgICAgdmFyIGluc2VydCA9IHJlbW92ZVRvSW5zZXJ0TGF0ZXIob2xkRWwpXG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcyhvbGRFbCk7XG5cbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgdmlld3MgPSB0aGlzLl92aWV3cygpO1xuICAgIHZhciB2aWV3c1NvcnRlZCA9IF8uc29ydEJ5KHZpZXdzLCBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLm9yZGVyaW5nO1xuICAgIH0pO1xuICAgIHZhciB2aWV3LCBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgIHZpZXdzU29ydGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2aWV3ID0gdmlld3NTb3J0ZWRbaV07XG4gICAgICB2aWV3LnJlbmRlcigpO1xuICAgICAgbm9kZSA9IHZpZXcuZWw7XG4gICAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2xkRWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgaWYoZWxPbkRvbSl7XG4gICAgICBpbnNlcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9sZEVsO1xuICB9LFxuICBhZGRWaWV3OiBmdW5jdGlvbihrZXksIHZpZXcpIHtcbiAgICB2YXIgdmlld3MgPSB0aGlzLl92aWV3cygpO1xuICAgIGlmICh2aWV3ID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwbHVnaW4uIFwiO1xuICAgIH1cbiAgICBpZiAodmlldy5vcmRlcmluZyA9PSBudWxsKSB7XG4gICAgICB2aWV3Lm9yZGVyaW5nID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gdmlld3Nba2V5XSA9IHZpZXc7XG4gIH0sXG4gIHJlbW92ZVZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwsIGtleTtcbiAgICB2YXIgdmlld3MgPSB0aGlzLl92aWV3cygpO1xuICAgIGZvciAoa2V5IGluIHZpZXdzKSB7XG4gICAgICBlbCA9IHZpZXdzW2tleV07XG4gICAgICBlbC51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBlbC51bmJpbmQoKTtcbiAgICAgIGlmIChlbC5yZW1vdmVWaWV3cyAhPSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZVZpZXdzKCk7XG4gICAgICB9XG4gICAgICBlbC5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlld3MgPSB7fTtcbiAgfSxcbiAgcmVtb3ZlVmlldzogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHZpZXdzID0gdGhpcy5fdmlld3MoKTtcbiAgICB2aWV3c1trZXldLnJlbW92ZSgpO1xuICAgIHJldHVybiBkZWxldGUgdmlld3Nba2V5XTtcbiAgfSxcbiAgZ2V0VmlldzogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHZpZXdzID0gdGhpcy5fdmlld3MoKTtcbiAgICByZXR1cm4gdmlld3Nba2V5XTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZVZpZXdzKCk7XG4gICAgcmV0dXJuIHZpZXdUeXBlLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcyk7XG4gIH0sXG4gIF92aWV3czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmlld3MgPT0gbnVsbCkge1xuICAgICAgdGhpcy52aWV3cyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aWV3cztcbiAgfVxufSk7XG4iLCIvLyAgICAgQmFja2JvbmUuanMgMS4xLjJcblxuLy8gICAgIChjKSAyMDEwLTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBCYWNrYm9uZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2JhY2tib25lanMub3JnXG5cbnZhciBFdmVudHMgPSByZXF1aXJlKFwiYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmVcIik7XG52YXIgZXh0ZW5kID0gcmVxdWlyZShcImJhY2tib25lLWV4dGVuZC1zdGFuZGFsb25lXCIpO1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuXG4vLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxudmFyIGFycmF5ID0gW107XG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxuLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuLy8gbW9yZSBhbmFsb2dvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4vLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbi8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbi8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4vLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4vLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbi8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbn07XG5cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbnZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG52YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4vLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuXy5leHRlbmQoQ29sbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICBtb2RlbDogTW9kZWwsXG5cbiAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIENvbGxlY3Rpb24gaXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgLy8gbW9kZWxzJyBhdHRyaWJ1dGVzLlxuICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0LlxuICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuXG4gIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2RlbHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtpZF07XG4gICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgbW9kZWxzID0gdGhpcy5wYXJzZShtb2RlbHMsIG9wdGlvbnMpO1xuICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IG1vZGVscy5zbGljZSgpO1xuICAgIHZhciBpZCwgbW9kZWwsIGF0dHJzLCBleGlzdGluZywgc29ydDtcbiAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xuICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICB2YXIgc29ydEF0dHIgPSBfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xuICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZCwgbWVyZ2UgPSBvcHRpb25zLm1lcmdlLCByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcbiAgICB2YXIgb3JkZXIgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZSA/IFtdIDogZmFsc2U7XG5cbiAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kZWxzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhdHRycyA9IG1vZGVsc1tpXTtcblxuICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICBpZiAoZXhpc3RpbmcgPSB0aGlzLmdldChhdHRycykpIHtcbiAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgIGlmIChtZXJnZSAmJiBhdHRycyAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICBhdHRycyA9IHRoaXMuX2lzTW9kZWwoYXR0cnMpID8gYXR0cnMuYXR0cmlidXRlcyA6IGF0dHJzO1xuICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCAmJiBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKSkgc29ydCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxzW2ldID0gZXhpc3Rpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cbiAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgYWRkIG11bHRpcGxlIG1vZGVscyB3aXRoIHRoZSBzYW1lIGBpZGAuXG4gICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChvcmRlciAmJiAobW9kZWwuaXNOZXcoKSB8fCAhbW9kZWxNYXBbaWRdKSkgb3JkZXIucHVzaChtb2RlbCk7XG4gICAgICBtb2RlbE1hcFtpZF0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHJlbW92ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFtb2RlbE1hcFsobW9kZWwgPSB0aGlzLm1vZGVsc1tpXSkuY2lkXSkgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICB9XG4gICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gU2VlIGlmIHNvcnRpbmcgaXMgbmVlZGVkLCB1cGRhdGUgYGxlbmd0aGAgYW5kIHNwbGljZSBpbiBuZXcgbW9kZWxzLlxuICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICB0aGlzLmxlbmd0aCArPSB0b0FkZC5sZW5ndGg7XG4gICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdG9BZGQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoYXQgKyBpLCAwLCB0b0FkZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmRlcikgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG9yZGVyZWRNb2RlbHMgPSBvcmRlciB8fCB0b0FkZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc29ydCkgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcblxuICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0IGV2ZW50cy5cbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB2YXIgYWRkT3B0cyA9IGF0ICE9IG51bGwgPyBfLmNsb25lKG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0b0FkZC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkgYWRkT3B0cy5pbmRleCA9IGF0ICsgaTtcbiAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBhZGRPcHRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0IHx8IChvcmRlciAmJiBvcmRlci5sZW5ndGgpKSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgfSxcblxuICAgIC8vIFdoZW4geW91IGhhdmUgbW9yZSBpdGVtcyB0aGFuIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgaW5kaXZpZHVhbGx5LFxuICAgIC8vIHlvdSBjYW4gcmVzZXQgdGhlIGVudGlyZSBzZXQgd2l0aCBhIG5ldyBsaXN0IG9mIG1vZGVscywgd2l0aG91dCBmaXJpbmdcbiAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXG4gICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgbW9kZWxzID0gdGhpcy5hZGQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbW9kZWxzO1xuICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gIGdldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaik7XG4gICAgcmV0dXJuIHRoaXMuX2J5SWRbb2JqXSB8fCB0aGlzLl9ieUlkW2lkXSB8fCB0aGlzLl9ieUlkW29iai5jaWRdO1xuICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyB2b2lkIDAgOiBbXTtcbiAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShmdW5jdGlvbihtb2RlbCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSBtb2RlbC5nZXQoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAvLyBvZiBgZmluZGAuXG4gIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgaWYgKF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSB8fCB0aGlzLmNvbXBhcmF0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW9kZWxzLnNvcnQoXy5iaW5kKHRoaXMuY29tcGFyYXRvciwgdGhpcykpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICByZXR1cm4gXy5pbnZva2UodGhpcy5tb2RlbHMsICdnZXQnLCBhdHRyKTtcbiAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKSBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcbiAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICBpZiAoIShtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucykpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFvcHRpb25zLndhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obW9kZWwsIHJlc3ApIHtcbiAgICAgIGlmIChvcHRpb25zLndhaXQpIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyBpdCB0aHJvdWdoLlxuICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgIHJldHVybiByZXNwO1xuICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMsIHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgfSk7XG4gIH0sXG5cbiAgICAvLyBEZWZpbmUgaG93IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgbW9kZWxJZDogZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgcmV0dXJuIGF0dHJzW3RoaXMubW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgIHRoaXMuX2J5SWQgID0ge307XG4gIH0sXG5cbiAgICAvLyBQcmVwYXJlIGEgaGFzaCBvZiBhdHRyaWJ1dGVzIChvciBvdGhlciBtb2RlbCkgdG8gYmUgYWRkZWQgdG8gdGhpc1xuICAgIC8vIGNvbGxlY3Rpb24uXG4gIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2lzTW9kZWwoYXR0cnMpKSB7XG4gICAgICBpZiAoIWF0dHJzLmNvbGxlY3Rpb24pIGF0dHJzLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICBpZiAoIW1vZGVsLnZhbGlkYXRpb25FcnJvcikgcmV0dXJuIG1vZGVsO1xuICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gICAgLy8gTWV0aG9kIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1vZGVsIGZvclxuICAgIC8vIHRoZSBwdXJwb3NlcyBvZiBhZGRpbmcgdG8gdGhlIGNvbGxlY3Rpb24uXG4gIF9pc01vZGVsOiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICByZXR1cm4gbW9kZWwgaW5zdGFuY2VvZiBNb2RlbDtcbiAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKSByZXR1cm47XG4gICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICB2YXIgcHJldklkID0gdGhpcy5tb2RlbElkKG1vZGVsLnByZXZpb3VzQXR0cmlidXRlcygpKTtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgIGlmIChwcmV2SWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbcHJldklkXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbn0pO1xuXG4vLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbi8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4vLyByaWdodCBoZXJlOlxudmFyIG1ldGhvZHMgPSBbJ2ZvckVhY2gnLCAnZWFjaCcsICdtYXAnLCAnY29sbGVjdCcsICdyZWR1Y2UnLCAnZm9sZGwnLFxuICAgICdpbmplY3QnLCAncmVkdWNlUmlnaHQnLCAnZm9sZHInLCAnZmluZCcsICdkZXRlY3QnLCAnZmlsdGVyJywgJ3NlbGVjdCcsXG4gICAgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsICdjb250YWlucycsICdpbnZva2UnLFxuICAgICdtYXgnLCAnbWluJywgJ3RvQXJyYXknLCAnc2l6ZScsICdmaXJzdCcsICdoZWFkJywgJ3Rha2UnLCAnaW5pdGlhbCcsICdyZXN0JyxcbiAgICAndGFpbCcsICdkcm9wJywgJ2xhc3QnLCAnd2l0aG91dCcsICdkaWZmZXJlbmNlJywgJ2luZGV4T2YnLCAnc2h1ZmZsZScsXG4gICAgJ2xhc3RJbmRleE9mJywgJ2lzRW1wdHknLCAnY2hhaW4nLCAnc2FtcGxlJywgJ3BhcnRpdGlvbiddO1xuXG4vLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG5fLmVhY2gobWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghX1ttZXRob2RdKSByZXR1cm47XG4gIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcy5tb2RlbHMpO1xuICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gIH07XG59KTtcblxuLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgdGFrZSBhIHByb3BlcnR5IG5hbWUgYXMgYW4gYXJndW1lbnQuXG52YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbi8vIFVzZSBhdHRyaWJ1dGVzIGluc3RlYWQgb2YgcHJvcGVydGllcy5cbl8uZWFjaChhdHRyaWJ1dGVNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFfW21ldGhvZF0pIHJldHVybjtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzLm1vZGVscywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICB9O1xufSk7XG5cbi8vIHNldHVwIGluaGVyaXRhbmNlXG5Db2xsZWN0aW9uLmV4dGVuZCA9IGV4dGVuZDtcbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcbiIsIm1vZHVsZS5leHBvcnRzLk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5tb2R1bGUuZXhwb3J0cy5Db2xsZWN0aW9uID0gcmVxdWlyZShcIi4vY29sbGVjdGlvblwiKTtcbm1vZHVsZS5leHBvcnRzLkV2ZW50cyA9IHJlcXVpcmUoXCJiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiKTtcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IHJlcXVpcmUoXCJiYWNrYm9uZS1leHRlbmQtc3RhbmRhbG9uZVwiKTtcbiIsIi8vICAgICBCYWNrYm9uZS5qcyAxLjEuMlxuXG4vLyAgICAgKGMpIDIwMTAtMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCJiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKFwiYmFja2JvbmUtZXh0ZW5kLXN0YW5kYWxvbmVcIik7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4vLyBCYWNrYm9uZS5Nb2RlbFxuLy8gLS0tLS0tLS0tLS0tLS1cblxuLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbi8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbi8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3Jcbi8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4vLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbi8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxudmFyIE1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ2MnKTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XG4gIGF0dHJzID0gXy5kZWZhdWx0cyh7fSwgYXR0cnMsIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcbiAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBBdHRhY2ggYWxsIGluaGVyaXRhYmxlIG1ldGhvZHMgdG8gdGhlIE1vZGVsIHByb3RvdHlwZS5cbl8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICBjaGFuZ2VkOiBudWxsLFxuXG4gIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICBpZEF0dHJpYnV0ZTogJ2lkJyxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIF8uZXNjYXBlKHRoaXMuZ2V0KGF0dHIpKTtcbiAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0ciwgYXR0cnMsIHVuc2V0LCBjaGFuZ2VzLCBzaWxlbnQsIGNoYW5naW5nLCBwcmV2LCBjdXJyZW50O1xuICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICBvcHRpb25zID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICB1bnNldCAgICAgICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgIGNoYW5nZXMgICAgICAgICA9IFtdO1xuICAgIGNoYW5naW5nICAgICAgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XG5cbiAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICB9XG4gICAgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcywgcHJldiA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgaWYgKHRoaXMuaWRBdHRyaWJ1dGUgaW4gYXR0cnMpIHRoaXMuaWQgPSBhdHRyc1t0aGlzLmlkQXR0cmlidXRlXTtcblxuICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICB0aGlzLmNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgfVxuICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBhbGwgcmVsZXZhbnQgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cbiAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAgIC8vIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuIGB1bnNldGAgaXMgYSBub29wXG4gICAgLy8gaWYgdGhlIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0LlxuICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gIH0sXG5cbiAgICAvLyBDbGVhciBhbGwgYXR0cmlidXRlcyBvbiB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuXG4gIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykgYXR0cnNba2V5XSA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICBoYXNDaGFuZ2VkOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgfSxcblxuICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGNoYW5nZWQsIG9yXG4gICAgLy8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZWQgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0XG4gICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcbiAgICAvLyBwZXJzaXN0ZWQgdG8gdGhlIHNlcnZlci4gVW5zZXQgYXR0cmlidXRlcyB3aWxsIGJlIHNldCB0byB1bmRlZmluZWQuXG4gICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gYXR0cmlidXRlcyBvYmplY3QgdG8gZGlmZiBhZ2FpbnN0IHRoZSBtb2RlbCxcbiAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxuICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgdmFyIHZhbCwgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCAodmFsID0gZGlmZlthdHRyXSkpKSBjb250aW51ZTtcbiAgICAgIChjaGFuZ2VkIHx8IChjaGFuZ2VkID0ge30pKVthdHRyXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAvLyB0cmlnZ2VyaW5nIGEgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgaWYgKCFtb2RlbC5zZXQobW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyksIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGFuIGF0dHJpYnV0ZXMgaGFzaCB0aGF0IGRpZmZlcnMsIHRoZSBtb2RlbCdzXG4gICAgLy8gc3RhdGUgd2lsbCBiZSBgc2V0YCBhZ2Fpbi5cbiAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgIC8vIGBzZXQoYXR0cikuc2F2ZShudWxsLCBvcHRzKWAgd2l0aCB2YWxpZGF0aW9uLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XG4gICAgICBpZiAoIXRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YC5cbiAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xuICAgIH1cblxuICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgbW9kZWwuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHNlcnZlckF0dHJzKSAmJiAhbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiAob3B0aW9ucy5wYXRjaCA/ICdwYXRjaCcgOiAndXBkYXRlJyk7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gUmVzdG9yZSBhdHRyaWJ1dGVzLlxuICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICByZXR1cm4geGhyO1xuICB9LFxuXG4gICAgLy8gRGVzdHJveSB0aGlzIG1vZGVsIG9uIHRoZSBzZXJ2ZXIgaWYgaXQgd2FzIGFscmVhZHkgcGVyc2lzdGVkLlxuICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXG4gICAgLy8gSWYgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgd2FpdHMgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZCBiZWZvcmUgcmVtb3ZhbC5cbiAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuc3RvcExpc3RlbmluZygpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgaWYgKG9wdGlvbnMud2FpdCB8fCBtb2RlbC5pc05ldygpKSBkZXN0cm95KCk7XG4gICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsLmlzTmV3KCkpIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgIG9wdGlvbnMuc3VjY2VzcygpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICB2YXIgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgIHJldHVybiB4aHI7XG4gIH0sXG5cbiAgICAvLyBEZWZhdWx0IFVSTCBmb3IgdGhlIG1vZGVsJ3MgcmVwcmVzZW50YXRpb24gb24gdGhlIHNlcnZlciAtLSBpZiB5b3UncmVcbiAgICAvLyB1c2luZyBCYWNrYm9uZSdzIHJlc3RmdWwgbWV0aG9kcywgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVuZHBvaW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFzZSA9XG4gICAgICBfLnJlc3VsdCh0aGlzLCAndXJsUm9vdCcpIHx8XG4gICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgdXJsRXJyb3IoKTtcbiAgICBpZiAodGhpcy5pc05ldygpKSByZXR1cm4gYmFzZTtcbiAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cbiAgICAvLyB0aGUgbW9kZWwuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyB0aGUgcmVzcG9uc2UgYWxvbmcuXG4gIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlc3A7XG4gIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICB9LFxuXG4gICAgLy8gQSBtb2RlbCBpcyBuZXcgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2F2ZWQgdG8gdGhlIHNlcnZlciwgYW5kIGxhY2tzIGFuIGlkLlxuICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgfSxcblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XG4gICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59KTtcblxuLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLlxudmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCcsICdjaGFpbicsICdpc0VtcHR5J107XG5cbi8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuXy5lYWNoKG1vZGVsTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghX1ttZXRob2RdKSByZXR1cm47XG4gIE1vZGVsLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMuYXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgfTtcbn0pO1xuXG4vLyBzZXR1cCBpbmhlcml0YW5jZVxuTW9kZWwuZXh0ZW5kID0gZXh0ZW5kO1xubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcbiIsIi8qKlxuICogU3RhbmRhbG9uZSBleHRyYWN0aW9uIG9mIEJhY2tib25lLkV2ZW50cywgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSByZXF1aXJlZC5cbiAqIERlZ3JhZGVzIG5pY2VseSB3aGVuIEJhY2tvbmUvdW5kZXJzY29yZSBhcmUgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCBkb2NzIHN1Z2dlc3QgdG8gdXNlIHVuZGVyc2NvcmUncyBgXy5leHRlbmQoKWAgbWV0aG9kIHRvIGFkZCBFdmVudHNcbiAqIHN1cHBvcnQgdG8gc29tZSBnaXZlbiBvYmplY3QuIEEgYG1peGluKClgIG1ldGhvZCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRXZlbnRzXG4gKiBwcm90b3R5cGUgdG8gYXZvaWQgdXNpbmcgdW5kZXJzY29yZSBmb3IgdGhhdCBzb2xlIHB1cnBvc2U6XG4gKlxuICogICAgIHZhciBteUV2ZW50RW1pdHRlciA9IEJhY2tib25lRXZlbnRzLm1peGluKHt9KTtcbiAqXG4gKiBPciBmb3IgYSBmdW5jdGlvbiBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDb25zdHJ1Y3Rvcigpe31cbiAqICAgICBNeUNvbnN0cnVjdG9yLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbigpe31cbiAqICAgICBCYWNrYm9uZUV2ZW50cy5taXhpbihNeUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gKlxuICogKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogKGMpIDIwMTMgTmljb2xhcyBQZXJyaWF1bHRcbiAqL1xuLyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICBpZENvdW50ZXIgPSAwO1xuXG4gIC8vIFJldHVybnMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIG1hdGNoaW5nIHRoZSBtaW5pbWFsIEFQSSBzdWJzZXQgcmVxdWlyZWRcbiAgLy8gYnkgQmFja2JvbmUuRXZlbnRzXG4gIGZ1bmN0aW9uIG1pbmlzY29yZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMoKSBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LFxuXG4gICAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICAgICAgfSxcblxuICAgICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgICB9LFxuXG4gICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfID0gbWluaXNjb3JlKCksIEV2ZW50cztcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBNaXhpbiB1dGlsaXR5XG4gIEV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ3RyaWdnZXInLCAnc3RvcExpc3RlbmluZycsICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgJ2xpc3RlblRvT25jZScsICdiaW5kJywgJ3VuYmluZCddO1xuICAgIF8uZWFjaChleHBvcnRzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIC8vIEV4cG9ydCBFdmVudHMgYXMgQmFja2JvbmVFdmVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY29udGV4dFxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG4gICAgfVxuICAgIGV4cG9ydHMuQmFja2JvbmVFdmVudHMgPSBFdmVudHM7XG4gIH1lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXZlbnRzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmVFdmVudHMgPSBFdmVudHM7XG4gIH1cbn0pKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lJyk7XG4iLCIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIHdpbmRvdy5CYWNrYm9uZUV4dGVuZCA9IGRlZmluaXRpb24oKTtcbiAgfVxufSkoZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgXG4gIC8vIG1pbmktdW5kZXJzY29yZVxuICB2YXIgXyA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgfSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGZvciAodmFyIGk9MTsgaTxhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcblxuICAvLy8gRm9sbG93aW5nIGNvZGUgaXMgcGFzdGVkIGZyb20gQmFja2JvbmUuanMgLy8vXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xuXG4gICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBFeHBvc2UgdGhlIGV4dGVuZCBmdW5jdGlvblxuICByZXR1cm4gZXh0ZW5kO1xufSk7XG4iLCIvLyB0aGlzIGlzIHRoZSBleHRyYWN0ZWQgdmlldyBtb2RlbCBmcm9tIGJhY2tib25lXG4vLyBub3RlIHRoYXQgd2UgaW5qZWN0IGpib25lIGFzIGpxdWVyeSByZXBsYWNtZW50XG4vLyAoYW5kIHVuZGVyc2NvcmUgZGlyZWN0bHkpXG4vL1xuLy8gVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS5cbi8vICBNVkMgcGF0dGVyblxuLy8gQmFja2JvbmUuVmlld1xuLy8gLS0tLS0tLS0tLS0tLVxuXG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCJiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKFwiYmFja2JvbmUtZXh0ZW5kLXN0YW5kYWxvbmVcIik7XG52YXIgJCA9IHJlcXVpcmUoJ2pib25lJyk7XG5cbi8vIEJhY2tib25lIFZpZXdzIGFyZSBhbG1vc3QgbW9yZSBjb252ZW50aW9uIHRoYW4gdGhleSBhcmUgYWN0dWFsIGNvZGUuIEEgVmlld1xuLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbi8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuLy8gZXZlbiB0aGUgc3Vycm91bmRpbmcgZnJhbWUgd2hpY2ggd3JhcHMgeW91ciB3aG9sZSBhcHAuIERlZmluaW5nIGEgY2h1bmsgb2Zcbi8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbi8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuLy8gcmVhY3QgdG8gc3BlY2lmaWMgY2hhbmdlcyBpbiB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbHMuXG5cbi8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbnZhciBWaWV3ID0gIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIF8uZXh0ZW5kKHRoaXMsIF8ucGljayhvcHRpb25zLCB2aWV3T3B0aW9ucykpO1xuICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gQ2FjaGVkIHJlZ2V4IHRvIHNwbGl0IGtleXMgZm9yIGBkZWxlZ2F0ZWAuXG52YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4vLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cbnZhciB2aWV3T3B0aW9ucyA9IFsnbW9kZWwnLCAnY29sbGVjdGlvbicsICdlbCcsICdpZCcsICdhdHRyaWJ1dGVzJywgJ2NsYXNzTmFtZScsICd0YWdOYW1lJywgJ2V2ZW50cyddO1xuXG4vLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG5fLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgLy8gVGhlIGRlZmF1bHQgYHRhZ05hbWVgIG9mIGEgVmlldydzIGVsZW1lbnQgaXMgYFwiZGl2XCJgLlxuICB0YWdOYW1lOiAnZGl2JyxcblxuICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgLy8gY3VycmVudCB2aWV3LiBUaGlzIHNob3VsZCBiZSBwcmVmZXJyZWQgdG8gZ2xvYmFsIGxvb2t1cHMgd2hlcmUgcG9zc2libGUuXG4gICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudCgpO1xuICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldydzIGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQgYW5kIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAvLyBhdHRhY2hlZCB0byBpdC4gRXhwb3NlZCBmb3Igc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET01cbiAgICAvLyBtYW5pcHVsYXRpb24gQVBJLlxuICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gIH0sXG5cbiAgICAvLyBDaGFuZ2UgdGhlIHZpZXcncyBlbGVtZW50IChgdGhpcy5lbGAgcHJvcGVydHkpIGFuZCByZS1kZWxlZ2F0ZSB0aGVcbiAgICAvLyB2aWV3J3MgZXZlbnRzIG9uIHRoZSBuZXcgZWxlbWVudC5cbiAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIHRoaXMuX3NldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gICAgLy8gQ3JlYXRlcyB0aGUgYHRoaXMuZWxgIGFuZCBgdGhpcy4kZWxgIHJlZmVyZW5jZXMgZm9yIHRoaXMgdmlldyB1c2luZyB0aGVcbiAgICAvLyBnaXZlbiBgZWxgLiBgZWxgIGNhbiBiZSBhIENTUyBzZWxlY3RvciBvciBhbiBIVE1MIHN0cmluZywgYSBqUXVlcnlcbiAgICAvLyBjb250ZXh0IG9yIGFuIGVsZW1lbnQuIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gdXRpbGl6ZSBhblxuICAgIC8vIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJIGFuZCBhcmUgb25seSByZXF1aXJlZCB0byBzZXQgdGhlXG4gICAgLy8gYHRoaXMuZWxgIHByb3BlcnR5LlxuICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICB0aGlzLiRlbCA9IGVsIGluc3RhbmNlb2YgJCA/IGVsIDogJChlbCk7XG4gICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgaWYgKCEoZXZlbnRzIHx8IChldmVudHMgPSBfLnJlc3VsdCh0aGlzLCAnZXZlbnRzJykpKSkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICBpZiAoIW1ldGhvZCkgY29udGludWU7XG4gICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgIHRoaXMuZGVsZWdhdGUobWF0Y2hbMV0sIG1hdGNoWzJdLCBfLmJpbmQobWV0aG9kLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gICAgLy8gQWRkIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB2aWV3J3MgZWxlbWVudCAob3IgYSBjaGlsZCBlbGVtZW50XG4gICAgLy8gdXNpbmcgYHNlbGVjdG9yYCkuIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLFxuICAgIC8vIGBibHVyYCwgYW5kIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICBkZWxlZ2F0ZTogZnVuY3Rpb24oZXZlbnROYW1lLCBzZWxlY3RvciwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICB9LFxuXG4gICAgLy8gQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyBieSBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy4kZWwpIHRoaXMuJGVsLm9mZignLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICB1bmRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuJGVsLm9mZihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICB9LFxuXG4gICAgLy8gUHJvZHVjZXMgYSBET00gZWxlbWVudCB0byBiZSBhc3NpZ25lZCB0byB5b3VyIHZpZXcuIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgX2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgaWYgKHRoaXMuaWQpIGF0dHJzLmlkID0gXy5yZXN1bHQodGhpcywgJ2lkJyk7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQoXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSkpO1xuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlcyhhdHRycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSk7XG4gICAgfVxuICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgX3NldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLiRlbC5hdHRyKGF0dHJpYnV0ZXMpO1xuICB9XG5cbn0pO1xuXG4vLyBzZXR1cCBpbmhlcml0YW5jZVxuVmlldy5leHRlbmQgPSBleHRlbmQ7XG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZShcImJhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lXCIpO1xuXG5ldmVudHMub25BbGwgPSBmdW5jdGlvbihjYWxsYmFjayxjb250ZXh0KXtcbiAgdGhpcy5vbihcImFsbFwiLCBjYWxsYmFjayxjb250ZXh0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBNaXhpbiB1dGlsaXR5XG5ldmVudHMub2xkTWl4aW4gPSBldmVudHMubWl4aW47XG5ldmVudHMubWl4aW4gPSBmdW5jdGlvbihwcm90bykge1xuICBldmVudHMub2xkTWl4aW4ocHJvdG8pO1xuICAvLyBhZGQgY3VzdG9tIG9uQWxsXG4gIHZhciBleHBvcnRzID0gWydvbkFsbCddO1xuICBmb3IodmFyIGk9MDsgaSA8IGV4cG9ydHMubGVuZ3RoO2krKyl7XG4gICAgdmFyIG5hbWUgPSBleHBvcnRzW2ldO1xuICAgIHByb3RvW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gcHJvdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50cztcbiIsInZhciBHZW5lcmljUmVhZGVyO1xuXG52YXIgeGhyID0gcmVxdWlyZSgncmVxdWVzdCcpO1xudmFyIHZvdyA9IHJlcXVpcmUoJ3ZvdycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNSZWFkZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEdlbmVyaWNSZWFkZXIoKSB7fVxuXG4gIC8vIHJldHVybnMgYSBwcm9taXNlIGlmIGNhbGxiYWNrIGlzIHVuZGVmaW5lZFxuICBHZW5lcmljUmVhZGVyLnJlYWQgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9ucmV0O1xuICAgIG9ucmV0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCByZXNwb25zZSwgdGV4dCkge1xuICAgICAgICByZXR1cm4gR2VuZXJpY1JlYWRlci5fb25SZXRyaWV2YWwoZXJyLCB0ZXh0LCBjYWxsYmFjaywgX3RoaXMpO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKTtcblxuICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICB2YXIgcHJvbSA9IHZvdy5kZWZlcigpO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgICAgIGlmKGVycil7XG4gICAgICAgICAgcHJvbS5yZWplY3QoZXJyKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcHJvbS5yZXNvbHZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIodXJsLCBvbnJldCk7XG4gICAgICByZXR1cm4gcHJvbS5wcm9taXNlKCk7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4geGhyKHVybCwgb25yZXQpO1xuICAgIH1cbiAgfTtcblxuICBHZW5lcmljUmVhZGVyLl9vblJldHJpZXZhbCA9IGZ1bmN0aW9uKGVyciwgdGV4dCwgY2FsbGJhY2ssIF90aGlzKSB7XG4gICAgdmFyIHJUZXh0O1xuICAgIGlmKHR5cGVvZiBlcnIgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgclRleHQgPSBfdGhpcy5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMsIGVyciwgclRleHQpO1xuICB9O1xuXG4gIC8vIHByb3ZpZGUgYSBjb252ZW5pZW50IHNob3J0Y3V0IHRvIGluaGVyaXRcbiAgR2VuZXJpY1JlYWRlci5leHRlbmQgPSBmdW5jdGlvbihvYmosIHN0YXRpY3Mpe1xuICAgIHJldHVybiBleHRlbmQoR2VuZXJpY1JlYWRlciwgb2JqLCBzdGF0aWNzKTsgXG4gIH07XG4gIC8vIE1peGluIHV0aWxpdHlcbiAgR2VuZXJpY1JlYWRlci5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ3JlYWQnXTtcbiAgICBpZih0eXBlb2YgcHJvdG8gIT09IFwib2JqZWN0XCIpe1xuICAgICAgcHJvdG8gPSBwcm90by5wcm90b3R5cGU7XG4gICAgfVxuICAgIGV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IEdlbmVyaWNSZWFkZXJbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIHJldHVybiBHZW5lcmljUmVhZGVyO1xuXG59KSgpO1xuIiwiLyoqXG4gKiBAbW9kdWxlIHZvd1xuICogQGF1dGhvciBGaWxhdG92IERtaXRyeSA8ZGZpbGF0b3ZAeWFuZGV4LXRlYW0ucnU+XG4gKiBAdmVyc2lvbiAwLjQuOVxuICogQGxpY2Vuc2VcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICogICAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiAgICogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG52YXIgdW5kZWYsXG4gICAgbmV4dFRpY2sgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmbnMgPSBbXSxcbiAgICAgICAgICAgIGVucXVldWVGbiA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZucy5wdXNoKGZuKSA9PT0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsRm5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuc1RvQ2FsbCA9IGZucywgaSA9IDAsIGxlbiA9IGZucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm5zID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBmbnNUb0NhbGxbaSsrXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBpZTEwLCBub2RlanMgPj0gMC4xMFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBzZXRJbW1lZGlhdGUoY2FsbEZucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MubmV4dFRpY2spIHsgLy8gbm9kZWpzIDwgMC4xMFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBwcm9jZXNzLm5leHRUaWNrKGNhbGxGbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGdsb2JhbC5wb3N0TWVzc2FnZSkgeyAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgIHZhciBpc1Bvc3RNZXNzYWdlQXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgaWYoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrQXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUG9zdE1lc3NhZ2VBc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25tZXNzYWdlJywgY2hlY2tBc3luYyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKCdfX2NoZWNrQXN5bmMnLCAnKicpO1xuICAgICAgICAgICAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb25tZXNzYWdlJywgY2hlY2tBc3luYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUG9zdE1lc3NhZ2VBc3luYykge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnX19wcm9taXNlJyArICtuZXcgRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxGbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSwgdHJ1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ubWVzc2FnZScsIG9uTWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBnbG9iYWwucG9zdE1lc3NhZ2UobXNnLCAnKicpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgICAgICBpZignb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHsgLy8gaWU2LWllOFxuICAgICAgICAgICAgdmFyIGNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsRm5zKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAoZG9jLmRvY3VtZW50RWxlbWVudCB8fCBkb2MuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIGVucXVldWVGbihmbikgJiYgY3JlYXRlU2NyaXB0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7IC8vIG9sZCBicm93c2Vyc1xuICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBzZXRUaW1lb3V0KGNhbGxGbnMsIDApO1xuICAgICAgICB9O1xuICAgIH0pKCksXG4gICAgdGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcbiAgICB9LFxuICAgIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuICAgIGdldEFycmF5S2V5cyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgcmVzLnB1c2goaSsrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZ2V0T2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiByZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVmaW5lQ3VzdG9tRXJyb3JUeXBlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgcmVzID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICB3cmFwT25GdWxmaWxsZWQgPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgaWR4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIG9uRnVsZmlsbGVkLmNhbGwodGhpcywgdmFsLCBpZHgpO1xuICAgICAgICB9O1xuICAgIH07XG5cbi8qKlxuICogQGNsYXNzIERlZmVycmVkXG4gKiBAZXhwb3J0cyB2b3c6RGVmZXJyZWRcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBEZWZlcnJlZGAgY2xhc3MgaXMgdXNlZCB0byBlbmNhcHN1bGF0ZSBuZXdseS1jcmVhdGVkIHByb21pc2Ugb2JqZWN0IGFsb25nIHdpdGggZnVuY3Rpb25zIHRoYXQgcmVzb2x2ZSwgcmVqZWN0IG9yIG5vdGlmeSBpdC5cbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2NyaXB0aW9uXG4gKiBZb3UgY2FuIHVzZSBgdm93LmRlZmVyKClgIGluc3RlYWQgb2YgdXNpbmcgdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBgbmV3IHZvdy5EZWZlcnJlZCgpYCBnaXZlcyB0aGUgc2FtZSByZXN1bHQgYXMgYHZvdy5kZWZlcigpYC5cbiAqL1xudmFyIERlZmVycmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG59O1xuXG5EZWZlcnJlZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIERlZmVycmVkLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBwcm9taXNlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBjb3JyZXNwb25kaW5nIHByb21pc2Ugd2l0aCBnaXZlbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBwcm9taXNlID0gZGVmZXIucHJvbWlzZSgpO1xuICAgICAqXG4gICAgICogcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIC8vIHZhbHVlIGlzIFwiJ3N1Y2Nlc3MnXCIgaGVyZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIucmVzb2x2ZSgnc3VjY2VzcycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlc29sdmUgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcm9taXNlLmlzUmVzb2x2ZWQoKSB8fCB0aGlzLl9wcm9taXNlLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBjb3JyZXNwb25kaW5nIHByb21pc2Ugd2l0aCBnaXZlbiBgcmVhc29uYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIHByb21pc2UgPSBkZWZlci5wcm9taXNlKCk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlLmZhaWwoZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICogICAgIC8vIHJlYXNvbiBpcyBcIidzb21ldGhpbmcgaXMgd3JvbmcnXCIgaGVyZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIucmVqZWN0KCdzb21ldGhpbmcgaXMgd3JvbmcnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZWplY3QgOiBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYodGhpcy5fcHJvbWlzZS5pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHZvdy5pc1Byb21pc2UocmVhc29uKSkge1xuICAgICAgICAgICAgcmVhc29uID0gcmVhc29uLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVyID0gdm93LmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KHZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVzb2x2ZShyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgY29ycmVzcG9uZGluZyBwcm9taXNlIHdpdGggZ2l2ZW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgcHJvbWlzZSA9IGRlZmVyLnByb21pc2UoKTtcbiAgICAgKlxuICAgICAqIHByb21pc2UucHJvZ3Jlc3MoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgLy8gdmFsdWUgaXMgXCInMjAlJ1wiLCBcIic0MCUnXCIgaGVyZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIubm90aWZ5KCcyMCUnKTtcbiAgICAgKiBkZWZlci5ub3RpZnkoJzQwJScpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG5vdGlmeSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuaXNSZXNvbHZlZCgpIHx8IHRoaXMuX3Byb21pc2UuX25vdGlmeSh2YWx1ZSk7XG4gICAgfVxufTtcblxudmFyIFBST01JU0VfU1RBVFVTID0ge1xuICAgIFBFTkRJTkcgICA6IDAsXG4gICAgUkVTT0xWRUQgIDogMSxcbiAgICBGVUxGSUxMRUQgOiAyLFxuICAgIFJFSkVDVEVEICA6IDNcbn07XG5cbi8qKlxuICogQGNsYXNzIFByb21pc2VcbiAqIEBleHBvcnRzIHZvdzpQcm9taXNlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgUHJvbWlzZWAgY2xhc3MgaXMgdXNlZCB3aGVuIHlvdSB3YW50IHRvIGdpdmUgdG8gdGhlIGNhbGxlciBzb21ldGhpbmcgdG8gc3Vic2NyaWJlIHRvLFxuICogYnV0IG5vdCB0aGUgYWJpbGl0eSB0byByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWQuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZG9tZW5pYy9wcm9taXNlcy11bndyYXBwaW5nL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCN0aGUtcHJvbWlzZS1jb25zdHJ1Y3RvciBmb3IgZGV0YWlscy5cbiAqIEBkZXNjcmlwdGlvblxuICogWW91IHNob3VsZCB1c2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseSBvbmx5IGlmIHlvdSBhcmUgZ29pbmcgdG8gdXNlIGB2b3dgIGFzIERPTSBQcm9taXNlcyBpbXBsZW1lbnRhdGlvbi5cbiAqIEluIG90aGVyIGNhc2UgeW91IHNob3VsZCB1c2UgYHZvdy5kZWZlcigpYCBhbmQgYGRlZmVyLnByb21pc2UoKWAgbWV0aG9kcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gZmV0Y2hKU09OKHVybCkge1xuICogICAgIHJldHVybiBuZXcgdm93LlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcbiAqICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAqICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAqICAgICAgICAgeGhyLnNlbmQoKTtcbiAqICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgaWYoeGhyLnJlc3BvbnNlKSB7XG4gKiAgICAgICAgICAgICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2UpO1xuICogICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgZWxzZSB7XG4gKiAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoKSk7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgIH07XG4gKiAgICAgfSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIFByb21pc2UgPSBmdW5jdGlvbihyZXNvbHZlcikge1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWY7XG4gICAgdGhpcy5fc3RhdHVzID0gUFJPTUlTRV9TVEFUVVMuUEVORElORztcblxuICAgIHRoaXMuX2Z1bGZpbGxlZENhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MgPSBbXTtcblxuICAgIGlmKHJlc29sdmVyKSB7IC8vIE5PVEU6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vZG9tZW5pYy9wcm9taXNlcy11bndyYXBwaW5nL2Jsb2IvbWFzdGVyL1JFQURNRS5tZFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgcmVzb2x2ZXJGbkxlbiA9IHJlc29sdmVyLmxlbmd0aDtcblxuICAgICAgICByZXNvbHZlcihcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzUmVzb2x2ZWQoKSB8fCBfdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc29sdmVyRm5MZW4gPiAxP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc1Jlc29sdmVkKCkgfHwgX3RoaXMuX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHVuZGVmLFxuICAgICAgICAgICAgcmVzb2x2ZXJGbkxlbiA+IDI/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzUmVzb2x2ZWQoKSB8fCBfdGhpcy5fbm90aWZ5KHZhbCk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgdW5kZWYpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlID0gLyoqIEBsZW5kcyBQcm9taXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZSBvZiBmdWxmaWxsZWQgcHJvbWlzZSBvciByZWFzb24gaW4gY2FzZSBvZiByZWplY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZU9mIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgcHJvbWlzZSBpcyByZXNvbHZlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVzb2x2ZWQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cyAhPT0gUFJPTUlTRV9TVEFUVVMuUEVORElORztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Z1bGZpbGxlZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSBQUk9NSVNFX1NUQVRVUy5GVUxGSUxMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlamVjdGVkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFBST01JU0VfU1RBVFVTLlJFSkVDVEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHJlYWN0aW9ucyB0byBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRnVsZmlsbGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIGZ1bGZpbGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblJlamVjdGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIG5vdGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2tzIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX0gQSBuZXcgcHJvbWlzZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjIGZvciBkZXRhaWxzXG4gICAgICovXG4gICAgdGhlbiA6IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2FkZENhbGxiYWNrcyhkZWZlciwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVqZWN0aW9uIHJlYWN0aW9uIG9ubHkuIEl0IGlzIHNob3J0Y3V0IGZvciBgcHJvbWlzZS50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZCBDYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICAnY2F0Y2gnIDogZnVuY3Rpb24ob25SZWplY3RlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWYsIG9uUmVqZWN0ZWQsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVqZWN0aW9uIHJlYWN0aW9uIG9ubHkuIEl0IGlzIHNob3J0Y3V0IGZvciBgcHJvbWlzZS50aGVuKG51bGwsIG9uUmVqZWN0ZWQpYC4gSXQncyBhbGlhcyBmb3IgYGNhdGNoYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWQgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgZmFpbCA6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmLCBvblJlamVjdGVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHJlc29sdmluZyByZWFjdGlvbiAodG8gZnVsZmlsbG1lbnQgYW5kIHJlamVjdGlvbiBib3RoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVzb2x2ZWQgQ2FsbGJhY2sgdGhhdCB0byBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhbHdheXMgOiBmdW5jdGlvbihvblJlc29sdmVkLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZWQuY2FsbCh0aGlzLCBfdGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4oY2IsIGNiLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHByb2dyZXNzIHJlYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Qcm9ncmVzcyBDYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgd2hlbiBwcm9taXNlIGhhcyBiZWVuIG5vdGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHByb2dyZXNzIDogZnVuY3Rpb24ob25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWYsIHVuZGVmLCBvblByb2dyZXNzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaWtlIGBwcm9taXNlLnRoZW5gLCBidXQgXCJzcHJlYWRzXCIgdGhlIGFycmF5IGludG8gYSB2YXJpYWRpYyB2YWx1ZSBoYW5kbGVyLlxuICAgICAqIEl0IGlzIHVzZWZ1bCB3aXRoIGB2b3cuYWxsYCBhbmQgYHZvdy5hbGxSZXNvbHZlZGAgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZ1bGZpbGxlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBmdWxmaWxsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25SZWplY3RlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlcjEgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgZGVmZXIyID0gdm93LmRlZmVyKCk7XG4gICAgICpcbiAgICAgKiB2b3cuYWxsKFtkZWZlcjEucHJvbWlzZSgpLCBkZWZlcjIucHJvbWlzZSgpXSkuc3ByZWFkKGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICAgKiAgICAgLy8gYXJnMSBpcyBcIjFcIiwgYXJnMiBpcyBcIid0d28nXCIgaGVyZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIxLnJlc29sdmUoMSk7XG4gICAgICogZGVmZXIyLnJlc29sdmUoJ3R3bycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNwcmVhZCA6IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkZ1bGZpbGxlZC5hcHBseSh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0ZWQsXG4gICAgICAgICAgICBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaWtlIGB0aGVuYCwgYnV0IHRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcy5cbiAgICAgKiBJZiB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZCwgdGhyb3dzIGl0IGFzIGFuIGV4Y2VwdGlvbiBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRnVsZmlsbGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIGZ1bGZpbGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblJlamVjdGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIG5vdGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2tzIGV4ZWN1dGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpO1xuICAgICAqIGRlZmVyLnJlamVjdChFcnJvcignSW50ZXJuYWwgZXJyb3InKSk7XG4gICAgICogZGVmZXIucHJvbWlzZSgpLmRvbmUoKTsgLy8gZXhjZXB0aW9uIHRvIGJlIHRocm93blxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRvbmUgOiBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpXG4gICAgICAgICAgICAuZmFpbCh0aHJvd0V4Y2VwdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIGluIGBkZWxheWAgbWlsbGlzZWNvbmRzIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCxcbiAgICAgKiBvciBpbW1lZGlhdGVseSByZWplY3RlZCBpZiBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGRlbGF5IDogZnVuY3Rpb24oZGVsYXkpIHtcbiAgICAgICAgdmFyIHRpbWVyLFxuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMudGhlbihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxheSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBiZSByZWplY3RlZCBpbiBgdGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgICogaWYgdGhlIHByb21pc2UgaXMgbm90IHJlc29sdmVkIGJlZm9yZWhhbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgcHJvbWlzZVdpdGhUaW1lb3V0MSA9IGRlZmVyLnByb21pc2UoKS50aW1lb3V0KDUwKSxcbiAgICAgKiAgICAgcHJvbWlzZVdpdGhUaW1lb3V0MiA9IGRlZmVyLnByb21pc2UoKS50aW1lb3V0KDIwMCk7XG4gICAgICpcbiAgICAgKiBzZXRUaW1lb3V0KFxuICAgICAqICAgICBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgIGRlZmVyLnJlc29sdmUoJ29rJyk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIDEwMCk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlV2l0aFRpbWVvdXQxLmZhaWwoZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICogICAgIC8vIHByb21pc2VXaXRoVGltZW91dCB0byBiZSByZWplY3RlZCBpbiA1MG1zXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlV2l0aFRpbWVvdXQyLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgLy8gcHJvbWlzZVdpdGhUaW1lb3V0IHRvIGJlIGZ1bGZpbGxlZCB3aXRoIFwiJ29rJ1wiIHZhbHVlXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGltZW91dCA6IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChuZXcgdm93LlRpbWVkT3V0RXJyb3IoJ3RpbWVkIG91dCcpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQpO1xuXG4gICAgICAgIHRoaXMudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUodmFsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmVyLnByb21pc2UoKS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICBfdm93IDogdHJ1ZSxcblxuICAgIF9yZXNvbHZlIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA+IFBST01JU0VfU1RBVFVTLlJFU09MVkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZih2YWwgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChUeXBlRXJyb3IoJ0NhblxcJ3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdHVzID0gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQ7XG5cbiAgICAgICAgaWYodmFsICYmICEhdmFsLl92b3cpIHsgLy8gc2hvcnRwYXRoIGZvciB2b3cuUHJvbWlzZVxuICAgICAgICAgICAgdmFsLmlzRnVsZmlsbGVkKCk/XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsZmlsbCh2YWwudmFsdWVPZigpKSA6XG4gICAgICAgICAgICAgICAgdmFsLmlzUmVqZWN0ZWQoKT9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHZhbC52YWx1ZU9mKCkpIDpcbiAgICAgICAgICAgICAgICAgICAgdmFsLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFyIHRoZW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25vdGlmeSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZXNvbHZlZCB8fCB0aGlzLl9yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnVsZmlsbCh2YWwpO1xuICAgIH0sXG5cbiAgICBfZnVsZmlsbCA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZih0aGlzLl9zdGF0dXMgPiBQUk9NSVNFX1NUQVRVUy5SRVNPTFZFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdHVzID0gUFJPTUlTRV9TVEFUVVMuRlVMRklMTEVEO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcblxuICAgICAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKHRoaXMuX2Z1bGZpbGxlZENhbGxiYWNrcywgdmFsKTtcbiAgICAgICAgdGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzID0gdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MgPSB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcyA9IHVuZGVmO1xuICAgIH0sXG5cbiAgICBfcmVqZWN0IDogZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA+IFBST01JU0VfU1RBVFVTLlJFU09MVkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5SRUpFQ1RFRDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSByZWFzb247XG5cbiAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyh0aGlzLl9yZWplY3RlZENhbGxiYWNrcywgcmVhc29uKTtcbiAgICAgICAgdGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzID0gdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MgPSB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcyA9IHVuZGVmO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5IDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3ModGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MsIHZhbCk7XG4gICAgfSxcblxuICAgIF9hZGRDYWxsYmFja3MgOiBmdW5jdGlvbihkZWZlciwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICBpZihvblJlamVjdGVkICYmICFpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICBjdHggPSBvblJlamVjdGVkO1xuICAgICAgICAgICAgb25SZWplY3RlZCA9IHVuZGVmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYob25Qcm9ncmVzcyAmJiAhaXNGdW5jdGlvbihvblByb2dyZXNzKSkge1xuICAgICAgICAgICAgY3R4ID0gb25Qcm9ncmVzcztcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MgPSB1bmRlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYjtcblxuICAgICAgICBpZighdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNiID0geyBkZWZlciA6IGRlZmVyLCBmbiA6IGlzRnVuY3Rpb24ob25GdWxmaWxsZWQpPyBvbkZ1bGZpbGxlZCA6IHVuZGVmLCBjdHggOiBjdHggfTtcbiAgICAgICAgICAgIHRoaXMuaXNGdWxmaWxsZWQoKT9cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKFtjYl0sIHRoaXMuX3ZhbHVlKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgY2IgPSB7IGRlZmVyIDogZGVmZXIsIGZuIDogb25SZWplY3RlZCwgY3R4IDogY3R4IH07XG4gICAgICAgICAgICB0aGlzLmlzUmVqZWN0ZWQoKT9cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKFtjYl0sIHRoaXMuX3ZhbHVlKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9zdGF0dXMgPD0gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzLnB1c2goeyBkZWZlciA6IGRlZmVyLCBmbiA6IG9uUHJvZ3Jlc3MsIGN0eCA6IGN0eCB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2FsbENhbGxiYWNrcyA6IGZ1bmN0aW9uKGNhbGxiYWNrcywgYXJnKSB7XG4gICAgICAgIHZhciBsZW4gPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSZXNvbHZlZCA9IHRoaXMuaXNSZXNvbHZlZCgpLFxuICAgICAgICAgICAgaXNGdWxmaWxsZWQgPSB0aGlzLmlzRnVsZmlsbGVkKCk7XG5cbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGNiLCBkZWZlciwgZm47XG4gICAgICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgY2IgPSBjYWxsYmFja3NbaSsrXTtcbiAgICAgICAgICAgICAgICBkZWZlciA9IGNiLmRlZmVyO1xuICAgICAgICAgICAgICAgIGZuID0gY2IuZm47XG5cbiAgICAgICAgICAgICAgICBpZihmbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2IuY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gY3R4PyBmbi5jYWxsKGN0eCwgYXJnKSA6IGZuKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLm5vdGlmeShyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZXNvbHZlZD9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsZmlsbGVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoYXJnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGFyZykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIubm90aWZ5KGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiogQGxlbmRzIFByb21pc2UgKi9cbnZhciBzdGF0aWNNZXRob2RzID0ge1xuICAgIC8qKlxuICAgICAqIENvZXJjZXMgZ2l2ZW4gYHZhbHVlYCB0byBhIHByb21pc2UsIG9yIHJldHVybnMgdGhlIGB2YWx1ZWAgaWYgaXQncyBhbHJlYWR5IGEgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgY2FzdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2b3cuY2FzdCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IGFmdGVyIGFsbCB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgZnVsZmlsbGVkLFxuICAgICAqIG9yIHRvIGJlIHJlamVjdGVkIHdoZW4gYW55IG9mIHRoZSBgaXRlcmFibGVgIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZXJhYmxlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGFsbCA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiB2b3cuYWxsKGl0ZXJhYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9ubHkgd2hlbiBhbnkgb2YgdGhlIGl0ZW1zIGluIGBpdGVyYWJsZWAgYXJlIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIHRoZSBmaXJzdCBpdGVtIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcmFjZSA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiB2b3cuYW55UmVzb2x2ZWQoaXRlcmFibGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gYHZhbHVlYC5cbiAgICAgKiBJZiBgdmFsdWVgIGlzIGEgcHJvbWlzZSwgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGFkb3B0ZWQgd2l0aCB0aGUgc3RhdGUgb2YgZ2l2ZW4gcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcmVzb2x2ZSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2b3cucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHJlamVjdCA6IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gdm93LnJlamVjdChyZWFzb24pO1xuICAgIH1cbn07XG5cbmZvcih2YXIgcHJvcCBpbiBzdGF0aWNNZXRob2RzKSB7XG4gICAgc3RhdGljTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJlxuICAgICAgICAoUHJvbWlzZVtwcm9wXSA9IHN0YXRpY01ldGhvZHNbcHJvcF0pO1xufVxuXG52YXIgdm93ID0gLyoqIEBleHBvcnRzIHZvdyAqLyB7XG4gICAgRGVmZXJyZWQgOiBEZWZlcnJlZCxcblxuICAgIFByb21pc2UgOiBQcm9taXNlLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkZWZlcnJlZC4gVGhpcyBtZXRob2QgaXMgYSBmYWN0b3J5IG1ldGhvZCBmb3IgYHZvdzpEZWZlcnJlZGAgY2xhc3MuXG4gICAgICogSXQncyBlcXVpdmFsZW50IHRvIGBuZXcgdm93LkRlZmVycmVkKClgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvdzpEZWZlcnJlZH1cbiAgICAgKi9cbiAgICBkZWZlciA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVycmVkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLnRoZW5gLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRnVsZmlsbGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIGZ1bGZpbGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblJlamVjdGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIG5vdGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2tzIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICB3aGVuIDogZnVuY3Rpb24odmFsdWUsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5jYXN0KHZhbHVlKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5mYWlsYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWQgQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgZmFpbCA6IGZ1bmN0aW9uKHZhbHVlLCBvblJlamVjdGVkLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHZvdy53aGVuKHZhbHVlLCB1bmRlZiwgb25SZWplY3RlZCwgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UuYWx3YXlzYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVzb2x2ZWQgQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYWx3YXlzIDogZnVuY3Rpb24odmFsdWUsIG9uUmVzb2x2ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LndoZW4odmFsdWUpLmFsd2F5cyhvblJlc29sdmVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5wcm9ncmVzc2AuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblByb2dyZXNzIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIG5vdGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHByb2dyZXNzIDogZnVuY3Rpb24odmFsdWUsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LndoZW4odmFsdWUpLnByb2dyZXNzKG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLnNwcmVhZGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2tzIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzcHJlYWQgOiBmdW5jdGlvbih2YWx1ZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LndoZW4odmFsdWUpLnNwcmVhZChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UuZG9uZWAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICovXG4gICAgZG9uZSA6IGZ1bmN0aW9uKHZhbHVlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIHZvdy53aGVuKHZhbHVlKS5kb25lKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gYHZhbHVlYCBpcyBhIHByb21pc2UtbGlrZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2b3cuaXNQcm9taXNlKCdzb21ldGhpbmcnKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqIHZvdy5pc1Byb21pc2Uodm93LmRlZmVyKCkucHJvbWlzZSgpKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogdm93LmlzUHJvbWlzZSh7IHRoZW4gOiBmdW5jdGlvbigpIHsgfSk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGlzUHJvbWlzZSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS50aGVuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBnaXZlbiBgdmFsdWVgIHRvIGEgcHJvbWlzZSwgb3IgcmV0dXJucyB0aGUgYHZhbHVlYCBpZiBpdCdzIGFscmVhZHkgYSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBjYXN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmICEhdmFsdWUuX3Zvdz9cbiAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgIHZvdy5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UudmFsdWVPZmAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYHZvdy5Qcm9taXNlYCwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdmFsdWVPZiA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnZhbHVlT2YpPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UuaXNGdWxmaWxsZWRgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGB2b3cuUHJvbWlzZWAsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsZmlsbGVkIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuaXNGdWxmaWxsZWQpPyB2YWx1ZS5pc0Z1bGZpbGxlZCgpIDogdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UuaXNSZWplY3RlZGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYHZvdy5Qcm9taXNlYCwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWplY3RlZCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmlzUmVqZWN0ZWQpPyB2YWx1ZS5pc1JlamVjdGVkKCkgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UuaXNSZXNvbHZlZGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Jlc29sdmVkIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuaXNSZXNvbHZlZCk/IHZhbHVlLmlzUmVzb2x2ZWQoKSA6IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiBgdmFsdWVgLlxuICAgICAqIElmIGB2YWx1ZWAgaXMgYSBwcm9taXNlLCByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgYWRvcHRlZCB3aXRoIHRoZSBzdGF0ZSBvZiBnaXZlbiBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByZXNvbHZlIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHZvdy5kZWZlcigpO1xuICAgICAgICByZXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXMucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuIGB2YWx1ZWAuXG4gICAgICogSWYgYHZhbHVlYCBpcyBhIHByb21pc2UsIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCBmdWxmaWxsL3JlamVjdGlvbiB2YWx1ZSBvZiBnaXZlbiBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdWxmaWxsIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gdm93LmRlZmVyKCksXG4gICAgICAgICAgICBwcm9taXNlID0gZGVmZXIucHJvbWlzZSgpO1xuXG4gICAgICAgIGRlZmVyLnJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlLmlzRnVsZmlsbGVkKCk/XG4gICAgICAgICAgICBwcm9taXNlIDpcbiAgICAgICAgICAgIHByb21pc2UudGhlbihudWxsLCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiAgICAgKiBJZiBgcmVhc29uYCBpcyBhIHByb21pc2UsIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIGZ1bGZpbGwvcmVqZWN0aW9uIHZhbHVlIG9mIGdpdmVuIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHJlYXNvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByZWplY3QgOiBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgdmFyIGRlZmVyID0gdm93LmRlZmVyKCk7XG4gICAgICAgIGRlZmVyLnJlamVjdChyZWFzb24pO1xuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGEgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aXRoIGFyZ3VtZW50cyBgYXJnc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc11cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHByb21pc2UxID0gdm93Lmludm9rZShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAqICAgICB9LCAnb2snKSxcbiAgICAgKiAgICAgcHJvbWlzZTIgPSB2b3cuaW52b2tlKGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlMS5pc0Z1bGZpbGxlZCgpOyAvLyB0cnVlXG4gICAgICogcHJvbWlzZTEudmFsdWVPZigpOyAvLyAnb2snXG4gICAgICogcHJvbWlzZTIuaXNSZWplY3RlZCgpOyAvLyB0cnVlXG4gICAgICogcHJvbWlzZTIudmFsdWVPZigpOyAvLyBpbnN0YW5jZSBvZiBFcnJvclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGludm9rZSA6IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gMSwgMCksXG4gICAgICAgICAgICBjYWxsQXJncztcbiAgICAgICAgaWYobGVuKSB7IC8vIG9wdGltaXphdGlvbiBmb3IgVjhcbiAgICAgICAgICAgIGNhbGxBcmdzID0gQXJyYXkobGVuKTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjYWxsQXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2b3cucmVzb2x2ZShjYWxsQXJncz9cbiAgICAgICAgICAgICAgICBmbi5hcHBseShnbG9iYWwsIGNhbGxBcmdzKSA6XG4gICAgICAgICAgICAgICAgZm4uY2FsbChnbG9iYWwpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdm93LnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb25seSBhZnRlciBhbGwgdGhlIGl0ZW1zIGluIGBpdGVyYWJsZWAgYXJlIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIGFueSBvZiB0aGUgYGl0ZXJhYmxlYCBpcyByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVyYWJsZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogd2l0aCBhcnJheTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlcjEgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgZGVmZXIyID0gdm93LmRlZmVyKCk7XG4gICAgICpcbiAgICAgKiB2b3cuYWxsKFtkZWZlcjEucHJvbWlzZSgpLCBkZWZlcjIucHJvbWlzZSgpLCAzXSlcbiAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgICAgICAvLyB2YWx1ZSBpcyBcIlsxLCAyLCAzXVwiIGhlcmVcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiBkZWZlcjEucmVzb2x2ZSgxKTtcbiAgICAgKiBkZWZlcjIucmVzb2x2ZSgyKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogd2l0aCBvYmplY3Q6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIxID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIGRlZmVyMiA9IHZvdy5kZWZlcigpO1xuICAgICAqXG4gICAgICogdm93LmFsbCh7IHAxIDogZGVmZXIxLnByb21pc2UoKSwgcDIgOiBkZWZlcjIucHJvbWlzZSgpLCBwMyA6IDMgfSlcbiAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgICAgICAvLyB2YWx1ZSBpcyBcInsgcDEgOiAxLCBwMiA6IDIsIHAzIDogMyB9XCIgaGVyZVxuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqIGRlZmVyMS5yZXNvbHZlKDEpO1xuICAgICAqIGRlZmVyMi5yZXNvbHZlKDIpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFsbCA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpLFxuICAgICAgICAgICAgaXNQcm9taXNlc0FycmF5ID0gaXNBcnJheShpdGVyYWJsZSksXG4gICAgICAgICAgICBrZXlzID0gaXNQcm9taXNlc0FycmF5P1xuICAgICAgICAgICAgICAgIGdldEFycmF5S2V5cyhpdGVyYWJsZSkgOlxuICAgICAgICAgICAgICAgIGdldE9iamVjdEtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgICByZXMgPSBpc1Byb21pc2VzQXJyYXk/IFtdIDoge307XG5cbiAgICAgICAgaWYoIWxlbikge1xuICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbGVuO1xuICAgICAgICB2b3cuX2ZvckVhY2goXG4gICAgICAgICAgICBpdGVyYWJsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXNba2V5c1tpZHhdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmKCEtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZlci5yZWplY3QsXG4gICAgICAgICAgICBkZWZlci5ub3RpZnksXG4gICAgICAgICAgICBkZWZlcixcbiAgICAgICAgICAgIGtleXMpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IGFmdGVyIGFsbCB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgcmVzb2x2ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyMSA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBkZWZlcjIgPSB2b3cuZGVmZXIoKTtcbiAgICAgKlxuICAgICAqIHZvdy5hbGxSZXNvbHZlZChbZGVmZXIxLnByb21pc2UoKSwgZGVmZXIyLnByb21pc2UoKV0pLnNwcmVhZChmdW5jdGlvbihwcm9taXNlMSwgcHJvbWlzZTIpIHtcbiAgICAgKiAgICAgcHJvbWlzZTEuaXNSZWplY3RlZCgpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAgICAgcHJvbWlzZTEudmFsdWVPZigpOyAvLyByZXR1cm5zIFwiJ2Vycm9yJ1wiXG4gICAgICogICAgIHByb21pc2UyLmlzRnVsZmlsbGVkKCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICAgICBwcm9taXNlMi52YWx1ZU9mKCk7IC8vIHJldHVybnMgXCInb2snXCJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGRlZmVyMS5yZWplY3QoJ2Vycm9yJyk7XG4gICAgICogZGVmZXIyLnJlc29sdmUoJ29rJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYWxsUmVzb2x2ZWQgOiBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIGlzUHJvbWlzZXNBcnJheSA9IGlzQXJyYXkoaXRlcmFibGUpLFxuICAgICAgICAgICAga2V5cyA9IGlzUHJvbWlzZXNBcnJheT9cbiAgICAgICAgICAgICAgICBnZXRBcnJheUtleXMoaXRlcmFibGUpIDpcbiAgICAgICAgICAgICAgICBnZXRPYmplY3RLZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGkgPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlcyA9IGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fTtcblxuICAgICAgICBpZighaSkge1xuICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvblJlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLS1pIHx8IGRlZmVyLnJlc29sdmUoaXRlcmFibGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB2b3cuX2ZvckVhY2goXG4gICAgICAgICAgICBpdGVyYWJsZSxcbiAgICAgICAgICAgIG9uUmVzb2x2ZWQsXG4gICAgICAgICAgICBvblJlc29sdmVkLFxuICAgICAgICAgICAgZGVmZXIubm90aWZ5LFxuICAgICAgICAgICAgZGVmZXIsXG4gICAgICAgICAgICBrZXlzKTtcblxuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICBhbGxQYXRpZW50bHkgOiBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gdm93LmFsbFJlc29sdmVkKGl0ZXJhYmxlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlzUHJvbWlzZXNBcnJheSA9IGlzQXJyYXkoaXRlcmFibGUpLFxuICAgICAgICAgICAgICAgIGtleXMgPSBpc1Byb21pc2VzQXJyYXk/XG4gICAgICAgICAgICAgICAgICAgIGdldEFycmF5S2V5cyhpdGVyYWJsZSkgOlxuICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3RLZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzLCBmdWxmaWxsZWRQcm9taXNlcyxcbiAgICAgICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aCwgaSA9IDAsIGtleSwgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2VzQXJyYXk/IFtdIDoge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2krK107XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGl0ZXJhYmxlW2tleV07XG4gICAgICAgICAgICAgICAgaWYodm93LmlzUmVqZWN0ZWQocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRQcm9taXNlcyB8fCAocmVqZWN0ZWRQcm9taXNlcyA9IGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJvbWlzZXNBcnJheT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkUHJvbWlzZXMucHVzaChwcm9taXNlLnZhbHVlT2YoKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRQcm9taXNlc1trZXldID0gcHJvbWlzZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoIXJlamVjdGVkUHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bGZpbGxlZFByb21pc2VzIHx8IChmdWxmaWxsZWRQcm9taXNlcyA9IGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fSkpW2tleV0gPSB2b3cudmFsdWVPZihwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHJlamVjdGVkUHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWplY3RlZFByb21pc2VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkUHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb25seSB3aGVuIGFueSBvZiB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBpcyBmdWxmaWxsZWQsXG4gICAgICogb3IgdG8gYmUgcmVqZWN0ZWQgd2hlbiBhbGwgdGhlIGl0ZW1zIGFyZSByZWplY3RlZCAod2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCByZWplY3RlZCBpdGVtKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZXJhYmxlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGFueSA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpLFxuICAgICAgICAgICAgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuXG4gICAgICAgIGlmKCFsZW4pIHtcbiAgICAgICAgICAgIGRlZmVyLnJlamVjdChFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDAsIHJlYXNvbjtcbiAgICAgICAgdm93Ll9mb3JFYWNoKFxuICAgICAgICAgICAgaXRlcmFibGUsXG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGkgfHwgKHJlYXNvbiA9IGUpO1xuICAgICAgICAgICAgICAgICsraSA9PT0gbGVuICYmIGRlZmVyLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmVyLm5vdGlmeSxcbiAgICAgICAgICAgIGRlZmVyKTtcblxuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb25seSB3aGVuIGFueSBvZiB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBpcyBmdWxmaWxsZWQsXG4gICAgICogb3IgdG8gYmUgcmVqZWN0ZWQgd2hlbiB0aGUgZmlyc3QgaXRlbSBpcyByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZXJhYmxlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGFueVJlc29sdmVkIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG5cbiAgICAgICAgaWYoIWxlbikge1xuICAgICAgICAgICAgZGVmZXIucmVqZWN0KEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZvdy5fZm9yRWFjaChcbiAgICAgICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSxcbiAgICAgICAgICAgIGRlZmVyLnJlamVjdCxcbiAgICAgICAgICAgIGRlZmVyLm5vdGlmeSxcbiAgICAgICAgICAgIGRlZmVyKTtcblxuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5kZWxheWAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgZGVsYXkgOiBmdW5jdGlvbih2YWx1ZSwgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKHZhbHVlKS5kZWxheShkZWxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLnRpbWVvdXRgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgdGltZW91dCA6IGZ1bmN0aW9uKHZhbHVlLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB2b3cucmVzb2x2ZSh2YWx1ZSkudGltZW91dCh0aW1lb3V0KTtcbiAgICB9LFxuXG4gICAgX2ZvckVhY2ggOiBmdW5jdGlvbihwcm9taXNlcywgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCwga2V5cykge1xuICAgICAgICB2YXIgbGVuID0ga2V5cz8ga2V5cy5sZW5ndGggOiBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICB2b3cud2hlbihcbiAgICAgICAgICAgICAgICBwcm9taXNlc1trZXlzPyBrZXlzW2ldIDogaV0sXG4gICAgICAgICAgICAgICAgd3JhcE9uRnVsZmlsbGVkKG9uRnVsZmlsbGVkLCBpKSxcbiAgICAgICAgICAgICAgICBvblJlamVjdGVkLFxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgY3R4KTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBUaW1lZE91dEVycm9yIDogZGVmaW5lQ3VzdG9tRXJyb3JUeXBlKCdUaW1lZE91dCcpXG59O1xuXG52YXIgZGVmaW5lQXNHbG9iYWwgPSB0cnVlO1xuaWYodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdm93O1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbmlmKHR5cGVvZiBtb2R1bGVzID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKG1vZHVsZXMuZGVmaW5lKSkge1xuICAgIG1vZHVsZXMuZGVmaW5lKCd2b3cnLCBmdW5jdGlvbihwcm92aWRlKSB7XG4gICAgICAgIHByb3ZpZGUodm93KTtcbiAgICB9KTtcbiAgICBkZWZpbmVBc0dsb2JhbCA9IGZhbHNlO1xufVxuXG5pZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHZvdztcbiAgICB9KTtcbiAgICBkZWZpbmVBc0dsb2JhbCA9IGZhbHNlO1xufVxuXG5kZWZpbmVBc0dsb2JhbCAmJiAoZ2xvYmFsLnZvdyA9IHZvdyk7XG5cbn0pKHRoaXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBvbmNlID0gcmVxdWlyZShcIm9uY2VcIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxuXG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkRnVuYygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiIHx8ICF4aHIucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cbiAgICBcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwidW5rbm93blwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWERSKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWEhSKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICBcbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCsyICk7XG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuICAgIFxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmIFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iLCIvKipcbiAqIEBtb2R1bGUgdm93XG4gKiBAYXV0aG9yIEZpbGF0b3YgRG1pdHJ5IDxkZmlsYXRvdkB5YW5kZXgtdGVhbS5ydT5cbiAqIEB2ZXJzaW9uIDAuNC45XG4gKiBAbGljZW5zZVxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiAgICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqICAgKiBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbnZhciB1bmRlZixcbiAgICBuZXh0VGljayA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZucyA9IFtdLFxuICAgICAgICAgICAgZW5xdWV1ZUZuID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm5zLnB1c2goZm4pID09PSAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxGbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm5zVG9DYWxsID0gZm5zLCBpID0gMCwgbGVuID0gZm5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuc1RvQ2FsbFtpKytdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7IC8vIGllMTAsIG5vZGVqcyA+PSAwLjEwXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHNldEltbWVkaWF0ZShjYWxsRm5zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5uZXh0VGljaykgeyAvLyBub2RlanMgPCAwLjEwXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHByb2Nlc3MubmV4dFRpY2soY2FsbEZucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZ2xvYmFsLnBvc3RNZXNzYWdlKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgdmFyIGlzUG9zdE1lc3NhZ2VBc3luYyA9IHRydWU7XG4gICAgICAgICAgICBpZihnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQb3N0TWVzc2FnZUFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbm1lc3NhZ2UnLCBjaGVja0FzeW5jKTtcbiAgICAgICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoJ19fY2hlY2tBc3luYycsICcqJyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbm1lc3NhZ2UnLCBjaGVja0FzeW5jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaXNQb3N0TWVzc2FnZUFzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdfX3Byb21pc2UnICsgK25ldyBEYXRlLFxuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlLmRhdGEgPT09IG1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEZucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlLCB0cnVlKSA6XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25tZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIGdsb2JhbC5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgICAgIGlmKCdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkgeyAvLyBpZTYtaWU4XG4gICAgICAgICAgICB2YXIgY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxGbnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIChkb2MuZG9jdW1lbnRFbGVtZW50IHx8IGRvYy5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBjcmVhdGVTY3JpcHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHsgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHNldFRpbWVvdXQoY2FsbEZucywgMCk7XG4gICAgICAgIH07XG4gICAgfSkoKSxcbiAgICB0aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBpc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuICAgIH0sXG4gICAgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHIuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH0sXG4gICAgZ2V0QXJyYXlLZXlzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXMucHVzaChpKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBnZXRPYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIHJlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWZpbmVDdXN0b21FcnJvclR5cGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciByZXMgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXMucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHdyYXBPbkZ1bGZpbGxlZCA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgb25GdWxmaWxsZWQuY2FsbCh0aGlzLCB2YWwsIGlkeCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuLyoqXG4gKiBAY2xhc3MgRGVmZXJyZWRcbiAqIEBleHBvcnRzIHZvdzpEZWZlcnJlZFxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYERlZmVycmVkYCBjbGFzcyBpcyB1c2VkIHRvIGVuY2Fwc3VsYXRlIG5ld2x5LWNyZWF0ZWQgcHJvbWlzZSBvYmplY3QgYWxvbmcgd2l0aCBmdW5jdGlvbnMgdGhhdCByZXNvbHZlLCByZWplY3Qgb3Igbm90aWZ5IGl0LlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzY3JpcHRpb25cbiAqIFlvdSBjYW4gdXNlIGB2b3cuZGVmZXIoKWAgaW5zdGVhZCBvZiB1c2luZyB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBuZXcgdm93LkRlZmVycmVkKClgIGdpdmVzIHRoZSBzYW1lIHJlc3VsdCBhcyBgdm93LmRlZmVyKClgLlxuICovXG52YXIgRGVmZXJyZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKTtcbn07XG5cbkRlZmVycmVkLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgRGVmZXJyZWQucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29ycmVzcG9uZGluZyBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHByb21pc2UgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIHByb21pc2UgPSBkZWZlci5wcm9taXNlKCk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgLy8gdmFsdWUgaXMgXCInc3VjY2VzcydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5yZXNvbHZlKCdzdWNjZXNzJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzb2x2ZSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuaXNSZXNvbHZlZCgpIHx8IHRoaXMuX3Byb21pc2UuX3Jlc29sdmUodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIGByZWFzb25gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWFzb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgcHJvbWlzZSA9IGRlZmVyLnByb21pc2UoKTtcbiAgICAgKlxuICAgICAqIHByb21pc2UuZmFpbChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgKiAgICAgLy8gcmVhc29uIGlzIFwiJ3NvbWV0aGluZyBpcyB3cm9uZydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5yZWplY3QoJ3NvbWV0aGluZyBpcyB3cm9uZycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlamVjdCA6IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZih0aGlzLl9wcm9taXNlLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodm93LmlzUHJvbWlzZShyZWFzb24pKSB7XG4gICAgICAgICAgICByZWFzb24gPSByZWFzb24udGhlbihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBjb3JyZXNwb25kaW5nIHByb21pc2Ugd2l0aCBnaXZlbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBwcm9taXNlID0gZGVmZXIucHJvbWlzZSgpO1xuICAgICAqXG4gICAgICogcHJvbWlzZS5wcm9ncmVzcyhmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAvLyB2YWx1ZSBpcyBcIicyMCUnXCIsIFwiJzQwJSdcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5ub3RpZnkoJzIwJScpO1xuICAgICAqIGRlZmVyLm5vdGlmeSgnNDAlJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbm90aWZ5IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5pc1Jlc29sdmVkKCkgfHwgdGhpcy5fcHJvbWlzZS5fbm90aWZ5KHZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgUFJPTUlTRV9TVEFUVVMgPSB7XG4gICAgUEVORElORyAgIDogMCxcbiAgICBSRVNPTFZFRCAgOiAxLFxuICAgIEZVTEZJTExFRCA6IDIsXG4gICAgUkVKRUNURUQgIDogM1xufTtcblxuLyoqXG4gKiBAY2xhc3MgUHJvbWlzZVxuICogQGV4cG9ydHMgdm93OlByb21pc2VcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBQcm9taXNlYCBjbGFzcyBpcyB1c2VkIHdoZW4geW91IHdhbnQgdG8gZ2l2ZSB0byB0aGUgY2FsbGVyIHNvbWV0aGluZyB0byBzdWJzY3JpYmUgdG8sXG4gKiBidXQgbm90IHRoZSBhYmlsaXR5IHRvIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZC5cbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXIgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL3Byb21pc2VzLXVud3JhcHBpbmcvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RoZS1wcm9taXNlLWNvbnN0cnVjdG9yIGZvciBkZXRhaWxzLlxuICogQGRlc2NyaXB0aW9uXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5IG9ubHkgaWYgeW91IGFyZSBnb2luZyB0byB1c2UgYHZvd2AgYXMgRE9NIFByb21pc2VzIGltcGxlbWVudGF0aW9uLlxuICogSW4gb3RoZXIgY2FzZSB5b3Ugc2hvdWxkIHVzZSBgdm93LmRlZmVyKClgIGFuZCBgZGVmZXIucHJvbWlzZSgpYCBtZXRob2RzLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBmZXRjaEpTT04odXJsKSB7XG4gKiAgICAgcmV0dXJuIG5ldyB2b3cuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG5vdGlmeSkge1xuICogICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gKiAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICogICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICogICAgICAgICB4aHIuc2VuZCgpO1xuICogICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBpZih4aHIucmVzcG9uc2UpIHtcbiAqICAgICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigpKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfTtcbiAqICAgICB9KTtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZjtcbiAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5QRU5ESU5HO1xuXG4gICAgdGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgaWYocmVzb2x2ZXIpIHsgLy8gTk9URTogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL3Byb21pc2VzLXVud3JhcHBpbmcvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICByZXNvbHZlckZuTGVuID0gcmVzb2x2ZXIubGVuZ3RoO1xuXG4gICAgICAgIHJlc29sdmVyKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSZXNvbHZlZCgpIHx8IF90aGlzLl9yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb2x2ZXJGbkxlbiA+IDE/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzUmVzb2x2ZWQoKSB8fCBfdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgdW5kZWYsXG4gICAgICAgICAgICByZXNvbHZlckZuTGVuID4gMj9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNSZXNvbHZlZCgpIHx8IF90aGlzLl9ub3RpZnkodmFsKTtcbiAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICB1bmRlZik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFByb21pc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIG9mIGZ1bGZpbGxlZCBwcm9taXNlIG9yIHJlYXNvbiBpbiBjYXNlIG9mIHJlamVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhbHVlT2YgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBwcm9taXNlIGlzIHJlc29sdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZXNvbHZlZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzICE9PSBQUk9NSVNFX1NUQVRVUy5QRU5ESU5HO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsZmlsbGVkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFBST01JU0VfU1RBVFVTLkZVTEZJTExFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVqZWN0ZWQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gUFJPTUlTRV9TVEFUVVMuUkVKRUNURUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVhY3Rpb25zIHRvIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfSBBIG5ldyBwcm9taXNlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMgZm9yIGRldGFpbHNcbiAgICAgKi9cbiAgICB0aGVuIDogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGRlZmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyByZWplY3Rpb24gcmVhY3Rpb24gb25seS4gSXQgaXMgc2hvcnRjdXQgZm9yIGBwcm9taXNlLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkIENhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgICdjYXRjaCcgOiBmdW5jdGlvbihvblJlamVjdGVkLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZiwgb25SZWplY3RlZCwgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyByZWplY3Rpb24gcmVhY3Rpb24gb25seS4gSXQgaXMgc2hvcnRjdXQgZm9yIGBwcm9taXNlLnRoZW4obnVsbCwgb25SZWplY3RlZClgLiBJdCdzIGFsaWFzIGZvciBgY2F0Y2hgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZCBDYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmYWlsIDogZnVuY3Rpb24ob25SZWplY3RlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWYsIG9uUmVqZWN0ZWQsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVzb2x2aW5nIHJlYWN0aW9uICh0byBmdWxmaWxsbWVudCBhbmQgcmVqZWN0aW9uIGJvdGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZXNvbHZlZCBDYWxsYmFjayB0aGF0IHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGFsd2F5cyA6IGZ1bmN0aW9uKG9uUmVzb2x2ZWQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlZC5jYWxsKHRoaXMsIF90aGlzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihjYiwgY2IsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcHJvZ3Jlc3MgcmVhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblByb2dyZXNzIENhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSB3aGVuIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbihvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZiwgdW5kZWYsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpa2UgYHByb21pc2UudGhlbmAsIGJ1dCBcInNwcmVhZHNcIiB0aGUgYXJyYXkgaW50byBhIHZhcmlhZGljIHZhbHVlIGhhbmRsZXIuXG4gICAgICogSXQgaXMgdXNlZnVsIHdpdGggYHZvdy5hbGxgIGFuZCBgdm93LmFsbFJlc29sdmVkYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRnVsZmlsbGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIGZ1bGZpbGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblJlamVjdGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrcyBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyMSA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBkZWZlcjIgPSB2b3cuZGVmZXIoKTtcbiAgICAgKlxuICAgICAqIHZvdy5hbGwoW2RlZmVyMS5wcm9taXNlKCksIGRlZmVyMi5wcm9taXNlKCldKS5zcHJlYWQoZnVuY3Rpb24oYXJnMSwgYXJnMikge1xuICAgICAqICAgICAvLyBhcmcxIGlzIFwiMVwiLCBhcmcyIGlzIFwiJ3R3bydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlcjEucmVzb2x2ZSgxKTtcbiAgICAgKiBkZWZlcjIucmVzb2x2ZSgndHdvJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3ByZWFkIDogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRnVsZmlsbGVkLmFwcGx5KHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWplY3RlZCxcbiAgICAgICAgICAgIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpa2UgYHRoZW5gLCBidXQgdGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLlxuICAgICAqIElmIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLCB0aHJvd3MgaXQgYXMgYW4gZXhjZXB0aW9uIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyID0gdm93LmRlZmVyKCk7XG4gICAgICogZGVmZXIucmVqZWN0KEVycm9yKCdJbnRlcm5hbCBlcnJvcicpKTtcbiAgICAgKiBkZWZlci5wcm9taXNlKCkuZG9uZSgpOyAvLyBleGNlcHRpb24gdG8gYmUgdGhyb3duXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZG9uZSA6IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eClcbiAgICAgICAgICAgIC5mYWlsKHRocm93RXhjZXB0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaW4gYGRlbGF5YCBtaWxsaXNlY29uZHMgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLFxuICAgICAqIG9yIGltbWVkaWF0ZWx5IHJlamVjdGVkIGlmIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgZGVsYXkgOiBmdW5jdGlvbihkZWxheSkge1xuICAgICAgICB2YXIgdGltZXIsXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy50aGVuKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIGJlIHJlamVjdGVkIGluIGB0aW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAgKiBpZiB0aGUgcHJvbWlzZSBpcyBub3QgcmVzb2x2ZWQgYmVmb3JlaGFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBwcm9taXNlV2l0aFRpbWVvdXQxID0gZGVmZXIucHJvbWlzZSgpLnRpbWVvdXQoNTApLFxuICAgICAqICAgICBwcm9taXNlV2l0aFRpbWVvdXQyID0gZGVmZXIucHJvbWlzZSgpLnRpbWVvdXQoMjAwKTtcbiAgICAgKlxuICAgICAqIHNldFRpbWVvdXQoXG4gICAgICogICAgIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgZGVmZXIucmVzb2x2ZSgnb2snKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgMTAwKTtcbiAgICAgKlxuICAgICAqIHByb21pc2VXaXRoVGltZW91dDEuZmFpbChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgKiAgICAgLy8gcHJvbWlzZVdpdGhUaW1lb3V0IHRvIGJlIHJlamVjdGVkIGluIDUwbXNcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHByb21pc2VXaXRoVGltZW91dDIudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAvLyBwcm9taXNlV2l0aFRpbWVvdXQgdG8gYmUgZnVsZmlsbGVkIHdpdGggXCInb2snXCIgdmFsdWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aW1lb3V0IDogZnVuY3Rpb24odGltZW91dCkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KG5ldyB2b3cuVGltZWRPdXRFcnJvcigndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZW91dCk7XG5cbiAgICAgICAgdGhpcy50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmZXIucHJvbWlzZSgpLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIF92b3cgOiB0cnVlLFxuXG4gICAgX3Jlc29sdmUgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzID4gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHZhbCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KFR5cGVFcnJvcignQ2FuXFwndCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5SRVNPTFZFRDtcblxuICAgICAgICBpZih2YWwgJiYgISF2YWwuX3ZvdykgeyAvLyBzaG9ydHBhdGggZm9yIHZvdy5Qcm9taXNlXG4gICAgICAgICAgICB2YWwuaXNGdWxmaWxsZWQoKT9cbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsKHZhbC52YWx1ZU9mKCkpIDpcbiAgICAgICAgICAgICAgICB2YWwuaXNSZWplY3RlZCgpP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QodmFsLnZhbHVlT2YoKSkgOlxuICAgICAgICAgICAgICAgICAgICB2YWwudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbm90aWZ5KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkIHx8IHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mdWxmaWxsKHZhbCk7XG4gICAgfSxcblxuICAgIF9mdWxmaWxsIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA+IFBST01JU0VfU1RBVFVTLlJFU09MVkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5GVUxGSUxMRUQ7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuXG4gICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3ModGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzLCB2YWwpO1xuICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MgPSB0aGlzLl9yZWplY3RlZENhbGxiYWNrcyA9IHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzID0gdW5kZWY7XG4gICAgfSxcblxuICAgIF9yZWplY3QgOiBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzID4gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFBST01JU0VfU1RBVFVTLlJFSkVDVEVEO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHJlYXNvbjtcblxuICAgICAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzLCByZWFzb24pO1xuICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MgPSB0aGlzLl9yZWplY3RlZENhbGxiYWNrcyA9IHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzID0gdW5kZWY7XG4gICAgfSxcblxuICAgIF9ub3RpZnkgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyh0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcywgdmFsKTtcbiAgICB9LFxuXG4gICAgX2FkZENhbGxiYWNrcyA6IGZ1bmN0aW9uKGRlZmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIGlmKG9uUmVqZWN0ZWQgJiYgIWlzRnVuY3Rpb24ob25SZWplY3RlZCkpIHtcbiAgICAgICAgICAgIGN0eCA9IG9uUmVqZWN0ZWQ7XG4gICAgICAgICAgICBvblJlamVjdGVkID0gdW5kZWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihvblByb2dyZXNzICYmICFpc0Z1bmN0aW9uKG9uUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICBjdHggPSBvblByb2dyZXNzO1xuICAgICAgICAgICAgb25Qcm9ncmVzcyA9IHVuZGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNiO1xuXG4gICAgICAgIGlmKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2IgPSB7IGRlZmVyIDogZGVmZXIsIGZuIDogaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCk/IG9uRnVsZmlsbGVkIDogdW5kZWYsIGN0eCA6IGN0eCB9O1xuICAgICAgICAgICAgdGhpcy5pc0Z1bGZpbGxlZCgpP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3MoW2NiXSwgdGhpcy5fdmFsdWUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBjYiA9IHsgZGVmZXIgOiBkZWZlciwgZm4gOiBvblJlamVjdGVkLCBjdHggOiBjdHggfTtcbiAgICAgICAgICAgIHRoaXMuaXNSZWplY3RlZCgpP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3MoW2NiXSwgdGhpcy5fdmFsdWUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RlZENhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA8PSBQUk9NSVNFX1NUQVRVUy5SRVNPTFZFRCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MucHVzaCh7IGRlZmVyIDogZGVmZXIsIGZuIDogb25Qcm9ncmVzcywgY3R4IDogY3R4IH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jYWxsQ2FsbGJhY2tzIDogZnVuY3Rpb24oY2FsbGJhY2tzLCBhcmcpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGlmKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1Jlc29sdmVkID0gdGhpcy5pc1Jlc29sdmVkKCksXG4gICAgICAgICAgICBpc0Z1bGZpbGxlZCA9IHRoaXMuaXNGdWxmaWxsZWQoKTtcblxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gMCwgY2IsIGRlZmVyLCBmbjtcbiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tpKytdO1xuICAgICAgICAgICAgICAgIGRlZmVyID0gY2IuZGVmZXI7XG4gICAgICAgICAgICAgICAgZm4gPSBjYi5mbjtcblxuICAgICAgICAgICAgICAgIGlmKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYi5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBjdHg/IGZuLmNhbGwoY3R4LCBhcmcpIDogZm4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIubm90aWZ5KHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShhcmcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoYXJnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ub3RpZnkoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKiBAbGVuZHMgUHJvbWlzZSAqL1xudmFyIHN0YXRpY01ldGhvZHMgPSB7XG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBnaXZlbiBgdmFsdWVgIHRvIGEgcHJvbWlzZSwgb3IgcmV0dXJucyB0aGUgYHZhbHVlYCBpZiBpdCdzIGFscmVhZHkgYSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBjYXN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5jYXN0KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGFyZSBmdWxmaWxsZWQsXG4gICAgICogb3IgdG8gYmUgcmVqZWN0ZWQgd2hlbiBhbnkgb2YgdGhlIGBpdGVyYWJsZWAgaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYWxsIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5hbGwoaXRlcmFibGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb25seSB3aGVuIGFueSBvZiB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgZnVsZmlsbGVkLFxuICAgICAqIG9yIHRvIGJlIHJlamVjdGVkIHdoZW4gdGhlIGZpcnN0IGl0ZW0gaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVyYWJsZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByYWNlIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5hbnlSZXNvbHZlZChpdGVyYWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiBgdmFsdWVgLlxuICAgICAqIElmIGB2YWx1ZWAgaXMgYSBwcm9taXNlLCByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgYWRvcHRlZCB3aXRoIHRoZSBzdGF0ZSBvZiBnaXZlbiBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByZXNvbHZlIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWFzb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcmVqZWN0IDogZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHJldHVybiB2b3cucmVqZWN0KHJlYXNvbik7XG4gICAgfVxufTtcblxuZm9yKHZhciBwcm9wIGluIHN0YXRpY01ldGhvZHMpIHtcbiAgICBzdGF0aWNNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApICYmXG4gICAgICAgIChQcm9taXNlW3Byb3BdID0gc3RhdGljTWV0aG9kc1twcm9wXSk7XG59XG5cbnZhciB2b3cgPSAvKiogQGV4cG9ydHMgdm93ICovIHtcbiAgICBEZWZlcnJlZCA6IERlZmVycmVkLFxuXG4gICAgUHJvbWlzZSA6IFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRlZmVycmVkLiBUaGlzIG1ldGhvZCBpcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBgdm93OkRlZmVycmVkYCBjbGFzcy5cbiAgICAgKiBJdCdzIGVxdWl2YWxlbnQgdG8gYG5ldyB2b3cuRGVmZXJyZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dm93OkRlZmVycmVkfVxuICAgICAqL1xuICAgIGRlZmVyIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UudGhlbmAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHdoZW4gOiBmdW5jdGlvbih2YWx1ZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LmNhc3QodmFsdWUpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLmZhaWxgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZCBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmYWlsIDogZnVuY3Rpb24odmFsdWUsIG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LndoZW4odmFsdWUsIHVuZGVmLCBvblJlamVjdGVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5hbHdheXNgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZXNvbHZlZCBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhbHdheXMgOiBmdW5jdGlvbih2YWx1ZSwgb25SZXNvbHZlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkuYWx3YXlzKG9uUmVzb2x2ZWQsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLnByb2dyZXNzYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUHJvZ3Jlc3MgQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbih2YWx1ZSwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkucHJvZ3Jlc3Mob25Qcm9ncmVzcywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2Uuc3ByZWFkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZ1bGZpbGxlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBmdWxmaWxsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25SZWplY3RlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHNwcmVhZCA6IGZ1bmN0aW9uKHZhbHVlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkuc3ByZWFkKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5kb25lYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZ1bGZpbGxlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBmdWxmaWxsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25SZWplY3RlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBub3RpZmllZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrcyBleGVjdXRpb25cbiAgICAgKi9cbiAgICBkb25lIDogZnVuY3Rpb24odmFsdWUsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgdm93LndoZW4odmFsdWUpLmRvbmUob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBgdmFsdWVgIGlzIGEgcHJvbWlzZS1saWtlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZvdy5pc1Byb21pc2UoJ3NvbWV0aGluZycpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogdm93LmlzUHJvbWlzZSh2b3cuZGVmZXIoKS5wcm9taXNlKCkpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiB2b3cuaXNQcm9taXNlKHsgdGhlbiA6IGZ1bmN0aW9uKCkgeyB9KTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaXNQcm9taXNlIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2VyY2VzIGdpdmVuIGB2YWx1ZWAgdG8gYSBwcm9taXNlLCBvciByZXR1cm5zIHRoZSBgdmFsdWVgIGlmIGl0J3MgYWxyZWFkeSBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGNhc3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgISF2YWx1ZS5fdm93P1xuICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgdm93LnJlc29sdmUodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS52YWx1ZU9mYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgdm93LlByb21pc2VgLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZU9mIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUudmFsdWVPZik/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc0Z1bGZpbGxlZGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYHZvdy5Qcm9taXNlYCwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGdWxmaWxsZWQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5pc0Z1bGZpbGxlZCk/IHZhbHVlLmlzRnVsZmlsbGVkKCkgOiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc1JlamVjdGVkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgdm93LlByb21pc2VgLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlamVjdGVkIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuaXNSZWplY3RlZCk/IHZhbHVlLmlzUmVqZWN0ZWQoKSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc1Jlc29sdmVkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVzb2x2ZWQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5pc1Jlc29sdmVkKT8gdmFsdWUuaXNSZXNvbHZlZCgpIDogdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIGB2YWx1ZWAuXG4gICAgICogSWYgYHZhbHVlYCBpcyBhIHByb21pc2UsIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBhZG9wdGVkIHdpdGggdGhlIHN0YXRlIG9mIGdpdmVuIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHJlc29sdmUgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gdm93LmRlZmVyKCk7XG4gICAgICAgIHJlcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlcy5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW4gYHZhbHVlYC5cbiAgICAgKiBJZiBgdmFsdWVgIGlzIGEgcHJvbWlzZSwgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGZ1bGZpbGwvcmVqZWN0aW9uIHZhbHVlIG9mIGdpdmVuIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bGZpbGwgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgICAgICAgIHByb21pc2UgPSBkZWZlci5wcm9taXNlKCk7XG5cbiAgICAgICAgZGVmZXIucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UuaXNGdWxmaWxsZWQoKT9cbiAgICAgICAgICAgIHByb21pc2UgOlxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuICAgICAqIElmIGByZWFzb25gIGlzIGEgcHJvbWlzZSwgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggZnVsZmlsbC9yZWplY3Rpb24gdmFsdWUgb2YgZ2l2ZW4gcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHJlamVjdCA6IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKTtcbiAgICAgICAgZGVmZXIucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdpdGggYXJndW1lbnRzIGBhcmdzYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcHJvbWlzZTEgPSB2b3cuaW52b2tlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICogICAgIH0sICdvaycpLFxuICAgICAqICAgICBwcm9taXNlMiA9IHZvdy5pbnZva2UoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqIHByb21pc2UxLmlzRnVsZmlsbGVkKCk7IC8vIHRydWVcbiAgICAgKiBwcm9taXNlMS52YWx1ZU9mKCk7IC8vICdvaydcbiAgICAgKiBwcm9taXNlMi5pc1JlamVjdGVkKCk7IC8vIHRydWVcbiAgICAgKiBwcm9taXNlMi52YWx1ZU9mKCk7IC8vIGluc3RhbmNlIG9mIEVycm9yXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaW52b2tlIDogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSAxLCAwKSxcbiAgICAgICAgICAgIGNhbGxBcmdzO1xuICAgICAgICBpZihsZW4pIHsgLy8gb3B0aW1pemF0aW9uIGZvciBWOFxuICAgICAgICAgICAgY2FsbEFyZ3MgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGNhbGxBcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKGNhbGxBcmdzP1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGdsb2JhbCwgY2FsbEFyZ3MpIDpcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGdsb2JhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2b3cucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IGFmdGVyIGFsbCB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgZnVsZmlsbGVkLFxuICAgICAqIG9yIHRvIGJlIHJlamVjdGVkIHdoZW4gYW55IG9mIHRoZSBgaXRlcmFibGVgIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZXJhYmxlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3aXRoIGFycmF5OlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyMSA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBkZWZlcjIgPSB2b3cuZGVmZXIoKTtcbiAgICAgKlxuICAgICAqIHZvdy5hbGwoW2RlZmVyMS5wcm9taXNlKCksIGRlZmVyMi5wcm9taXNlKCksIDNdKVxuICAgICAqICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgICAgIC8vIHZhbHVlIGlzIFwiWzEsIDIsIDNdXCIgaGVyZVxuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqIGRlZmVyMS5yZXNvbHZlKDEpO1xuICAgICAqIGRlZmVyMi5yZXNvbHZlKDIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3aXRoIG9iamVjdDpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlcjEgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgZGVmZXIyID0gdm93LmRlZmVyKCk7XG4gICAgICpcbiAgICAgKiB2b3cuYWxsKHsgcDEgOiBkZWZlcjEucHJvbWlzZSgpLCBwMiA6IGRlZmVyMi5wcm9taXNlKCksIHAzIDogMyB9KVxuICAgICAqICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgICAgIC8vIHZhbHVlIGlzIFwieyBwMSA6IDEsIHAyIDogMiwgcDMgOiAzIH1cIiBoZXJlXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIxLnJlc29sdmUoMSk7XG4gICAgICogZGVmZXIyLnJlc29sdmUoMik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYWxsIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICBpc1Byb21pc2VzQXJyYXkgPSBpc0FycmF5KGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGtleXMgPSBpc1Byb21pc2VzQXJyYXk/XG4gICAgICAgICAgICAgICAgZ2V0QXJyYXlLZXlzKGl0ZXJhYmxlKSA6XG4gICAgICAgICAgICAgICAgZ2V0T2JqZWN0S2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlcyA9IGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fTtcblxuICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBsZW47XG4gICAgICAgIHZvdy5fZm9yRWFjaChcbiAgICAgICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJlc1trZXlzW2lkeF1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYoIS0taSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmVyLnJlamVjdCxcbiAgICAgICAgICAgIGRlZmVyLm5vdGlmeSxcbiAgICAgICAgICAgIGRlZmVyLFxuICAgICAgICAgICAga2V5cyk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGFyZSByZXNvbHZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVyYWJsZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIxID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIGRlZmVyMiA9IHZvdy5kZWZlcigpO1xuICAgICAqXG4gICAgICogdm93LmFsbFJlc29sdmVkKFtkZWZlcjEucHJvbWlzZSgpLCBkZWZlcjIucHJvbWlzZSgpXSkuc3ByZWFkKGZ1bmN0aW9uKHByb21pc2UxLCBwcm9taXNlMikge1xuICAgICAqICAgICBwcm9taXNlMS5pc1JlamVjdGVkKCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICAgICBwcm9taXNlMS52YWx1ZU9mKCk7IC8vIHJldHVybnMgXCInZXJyb3InXCJcbiAgICAgKiAgICAgcHJvbWlzZTIuaXNGdWxmaWxsZWQoKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogICAgIHByb21pc2UyLnZhbHVlT2YoKTsgLy8gcmV0dXJucyBcIidvaydcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIxLnJlamVjdCgnZXJyb3InKTtcbiAgICAgKiBkZWZlcjIucmVzb2x2ZSgnb2snKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhbGxSZXNvbHZlZCA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpLFxuICAgICAgICAgICAgaXNQcm9taXNlc0FycmF5ID0gaXNBcnJheShpdGVyYWJsZSksXG4gICAgICAgICAgICBrZXlzID0gaXNQcm9taXNlc0FycmF5P1xuICAgICAgICAgICAgICAgIGdldEFycmF5S2V5cyhpdGVyYWJsZSkgOlxuICAgICAgICAgICAgICAgIGdldE9iamVjdEtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgaSA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9O1xuXG4gICAgICAgIGlmKCFpKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAtLWkgfHwgZGVmZXIucmVzb2x2ZShpdGVyYWJsZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHZvdy5fZm9yRWFjaChcbiAgICAgICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICAgICAgb25SZXNvbHZlZCxcbiAgICAgICAgICAgIG9uUmVzb2x2ZWQsXG4gICAgICAgICAgICBkZWZlci5ub3RpZnksXG4gICAgICAgICAgICBkZWZlcixcbiAgICAgICAgICAgIGtleXMpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIGFsbFBhdGllbnRseSA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiB2b3cuYWxsUmVzb2x2ZWQoaXRlcmFibGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNQcm9taXNlc0FycmF5ID0gaXNBcnJheShpdGVyYWJsZSksXG4gICAgICAgICAgICAgICAga2V5cyA9IGlzUHJvbWlzZXNBcnJheT9cbiAgICAgICAgICAgICAgICAgICAgZ2V0QXJyYXlLZXlzKGl0ZXJhYmxlKSA6XG4gICAgICAgICAgICAgICAgICAgIGdldE9iamVjdEtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgICAgIHJlamVjdGVkUHJvbWlzZXMsIGZ1bGZpbGxlZFByb21pc2VzLFxuICAgICAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoLCBpID0gMCwga2V5LCBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gaXRlcmFibGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZih2b3cuaXNSZWplY3RlZChwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzIHx8IChyZWplY3RlZFByb21pc2VzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm9taXNlc0FycmF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRQcm9taXNlcy5wdXNoKHByb21pc2UudmFsdWVPZigpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzW2tleV0gPSBwcm9taXNlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZighcmVqZWN0ZWRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAoZnVsZmlsbGVkUHJvbWlzZXMgfHwgKGZ1bGZpbGxlZFByb21pc2VzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9KSlba2V5XSA9IHZvdy52YWx1ZU9mKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocmVqZWN0ZWRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IHJlamVjdGVkUHJvbWlzZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRQcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IHdoZW4gYW55IG9mIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGlzIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIGFsbCB0aGUgaXRlbXMgYXJlIHJlamVjdGVkICh3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHJlamVjdGVkIGl0ZW0pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYW55IDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG5cbiAgICAgICAgaWYoIWxlbikge1xuICAgICAgICAgICAgZGVmZXIucmVqZWN0KEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMCwgcmVhc29uO1xuICAgICAgICB2b3cuX2ZvckVhY2goXG4gICAgICAgICAgICBpdGVyYWJsZSxcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUsXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaSB8fCAocmVhc29uID0gZSk7XG4gICAgICAgICAgICAgICAgKytpID09PSBsZW4gJiYgZGVmZXIucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmZXIubm90aWZ5LFxuICAgICAgICAgICAgZGVmZXIpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IHdoZW4gYW55IG9mIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGlzIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIHRoZSBmaXJzdCBpdGVtIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYW55UmVzb2x2ZWQgOiBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcblxuICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICBkZWZlci5yZWplY3QoRXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdm93Ll9mb3JFYWNoKFxuICAgICAgICAgICAgaXRlcmFibGUsXG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlLFxuICAgICAgICAgICAgZGVmZXIucmVqZWN0LFxuICAgICAgICAgICAgZGVmZXIubm90aWZ5LFxuICAgICAgICAgICAgZGVmZXIpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLmRlbGF5YC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBkZWxheSA6IGZ1bmN0aW9uKHZhbHVlLCBkZWxheSkge1xuICAgICAgICByZXR1cm4gdm93LnJlc29sdmUodmFsdWUpLmRlbGF5KGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UudGltZW91dGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICB0aW1lb3V0IDogZnVuY3Rpb24odmFsdWUsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKHZhbHVlKS50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH0sXG5cbiAgICBfZm9yRWFjaCA6IGZ1bmN0aW9uKHByb21pc2VzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4LCBrZXlzKSB7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzPyBrZXlzLmxlbmd0aCA6IHByb21pc2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHZvdy53aGVuKFxuICAgICAgICAgICAgICAgIHByb21pc2VzW2tleXM/IGtleXNbaV0gOiBpXSxcbiAgICAgICAgICAgICAgICB3cmFwT25GdWxmaWxsZWQob25GdWxmaWxsZWQsIGkpLFxuICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBjdHgpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRpbWVkT3V0RXJyb3IgOiBkZWZpbmVDdXN0b21FcnJvclR5cGUoJ1RpbWVkT3V0Jylcbn07XG5cbnZhciBkZWZpbmVBc0dsb2JhbCA9IHRydWU7XG5pZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2b3c7XG4gICAgZGVmaW5lQXNHbG9iYWwgPSBmYWxzZTtcbn1cblxuaWYodHlwZW9mIG1vZHVsZXMgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24obW9kdWxlcy5kZWZpbmUpKSB7XG4gICAgbW9kdWxlcy5kZWZpbmUoJ3ZvdycsIGZ1bmN0aW9uKHByb3ZpZGUpIHtcbiAgICAgICAgcHJvdmlkZSh2b3cpO1xuICAgIH0pO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbmlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gdm93O1xuICAgIH0pO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbmRlZmluZUFzR2xvYmFsICYmIChnbG9iYWwudm93ID0gdm93KTtcblxufSkodGhpcyk7XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJ2YXIgamFsdmlldyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBqYWx2aWV3O1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8vIGh0dHA6Ly93d3cuamFsdmlldy5vcmcvaGVscC9odG1sL2ZlYXR1cmVzL2ZlYXR1cmVzRm9ybWF0Lmh0bWxcbmphbHZpZXcucmVhZEhlYWRlciA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gIHZhciBjb2xvcnMgPSB7fTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgdmFyIGN1cnJlbnRHcm91cDtcblxuICBmb3IgKDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAobGluZS5pbmRleE9mKFwiI1wiKSA+PSAwKSB7XG4gICAgICAvLyBubyBjb21tZW50cyBhbGxvd2VkIC0+IHN0b3BcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgY29sdW1ucyA9IGxpbmUuc3BsaXQoL1xcdC8pO1xuICAgIHZhciBmaXJzdENlbGwgPSBjb2x1bW5zWzBdLnRyaW0oKTtcbiAgICBpZiAoZmlyc3RDZWxsID09PSBcIkdGRlwiKSB7XG4gICAgICAvLyB0aGlzIHN5bWJvbGl6ZXMgdGhlIGVuZCBcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY29sdW1ucy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChmaXJzdENlbGwgPT09IFwic3RhcnRncm91cFwiKSB7XG4gICAgICAgIGN1cnJlbnRHcm91cCA9IGNvbHVtbnNbMV0udHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENlbGwgPT09IFwiZW5kZ3JvdXBcIikge1xuICAgICAgICBjdXJyZW50R3JvdXAgPSBcIlwiO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcnNlIGNvbG9yXG4gICAgICAgIGNvbG9yc1tjb2x1bW5zWzBdXSA9IGphbHZpZXcucGFyc2VDb2xvcihjb2x1bW5zWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoY29sdW1ucy5sZW5ndGggPj0gNSl7XG4gICAgICB2YXIgYXJyID0gamFsdmlldy5wYXJzZUxpbmUoY29sdW1ucyk7XG4gICAgICBpZiAoY3VycmVudEdyb3VwKSB7XG4gICAgICAgIGFyci5hdHRyaWJ1dGVzLlBhcmVudCA9IGN1cnJlbnRHcm91cDtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goYXJyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9mZnNldDogaSxcbiAgICBjb2xvcnM6IGNvbG9ycyxcbiAgICBmZWF0dXJlczogZmVhdHVyZXNcbiAgfTtcbn07XG5cbmphbHZpZXcucGFyc2VDb2xvciA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgaWYgKGNlbGwuaW5kZXhPZihcIixcIikgPj0gMCkge1xuICAgIC8vIHJnYiBjb2RlXG4gICAgcmV0dXJuIHV0aWxzLnJnYlRvSGV4KGNlbGwuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGVsKTtcbiAgICB9KSk7XG4gIH1cbiAgLy8gY29sb3IgbmFtZXMgd2l0aCBsZW5ndGggPT0gNlxuICAvLyAnYmlzcXVlLG1hcm9vbixvcmFuZ2Usb3JjaGlkLHB1cnBsZSxzYWxtb24sc2llbm5hLHRvbWF0byx2aW9sZXQseWVsbG93J1xuICBpZiAoY2VsbC5sZW5ndGggPT09IDYgJiYgcGFyc2VJbnQoY2VsbC5jaGFyQXQoMCksIDE2KSA8PSAxNiAmJiBjZWxsICE9PSAnYmlzcXVlJykge1xuICAgIC8vIGhleCBjb2RlXG4gICAgcmV0dXJuIFwiI1wiICsgY2VsbDtcbiAgfVxuICAvLyBjb2xvciBuYW1lXG4gIHJldHVybiBjZWxsO1xufTtcblxuXG5qYWx2aWV3LnBhcnNlTGluZSA9IGZ1bmN0aW9uKGNvbHVtbnMpIHtcbiAgdmFyIG9iaiA9IHtcbiAgICBhdHRyaWJ1dGVzOiB7fVxuICB9O1xuICBvYmouYXR0cmlidXRlcy5OYW1lID0gY29sdW1uc1swXS50cmltKCk7IC8vZGVzY1xuICBvYmouc2VxbmFtZSA9IGNvbHVtbnNbMV0udHJpbSgpOyAvLyBpZFxuICBvYmouc3RhcnQgPSBwYXJzZUludChjb2x1bW5zWzNdKTtcbiAgb2JqLmVuZCA9IHBhcnNlSW50KGNvbHVtbnNbNF0pO1xuICBvYmouZmVhdHVyZSA9IGNvbHVtbnNbNV0udHJpbSgpO1xuICBpZiAob2JqLnNlcW5hbWUgPT09IFwiSURfTk9UX1NQRUNJRklFRFwiKSB7XG4gICAgb2JqLnNlcW5hbWUgPSBjb2x1bW5zWzJdLnRyaW0oKTsgLy8gYWx0ZXJuYXRpdmUgaWRcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbiIsInZhciB1dGlscyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSB1dGlscztcblxudXRpbHMuZXh0cmFjdEtleXMgPSBmdW5jdGlvbiBleHRyYWN0S2V5cyhhdHRyKSB7XG4gIC8vIGV4dHJhY3Qga2V5LXZhbHVlIGRlZmluaXRpb25zXG4gIHZhciBhdHRyaWJ1dGVzID0ge307XG4gIHZhciBhdHRyQXJyID0gYXR0ci5zcGxpdChcIjtcIik7XG4gIGF0dHJBcnIuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgIHZhciBrZXlBcnIsIGtleSwgdmFsO1xuICAgIGlmIChlbC5pbmRleE9mKFwiPVwiKSA+IDApIHtcbiAgICAgIGtleUFyciA9IGVsLnNwbGl0KFwiPVwiKTtcbiAgICAgIGtleSA9IGtleUFyclswXTtcbiAgICAgIHZhbCA9IGtleUFyclsxXTtcbiAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKGVsLmluZGV4T2YoXCIgXCIpID4gMCkge1xuICAgICAga2V5QXJyID0gZWwuc3BsaXQoXCIgXCIpO1xuICAgICAga2V5ID0ga2V5QXJyWzBdO1xuICAgICAgdmFsID0ga2V5QXJyWzFdLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbmZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuXG51dGlscy5yZ2JUb0hleCA9IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgaWYoci5sZW5ndGggPT09IDMpe1xuICAgIHJldHVybiB1dGlscy5yZ2JUb0hleChyWzBdLHJbMV0sIHJbMl0pO1xuICB9XG4gIHJldHVybiBcIiNcIiArIGNvbXBvbmVudFRvSGV4KHIpICsgY29tcG9uZW50VG9IZXgoZykgKyBjb21wb25lbnRUb0hleChiKTtcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgdm93XG4gKiBAYXV0aG9yIEZpbGF0b3YgRG1pdHJ5IDxkZmlsYXRvdkB5YW5kZXgtdGVhbS5ydT5cbiAqIEB2ZXJzaW9uIDAuNC45XG4gKiBAbGljZW5zZVxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiAgICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqICAgKiBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbnZhciB1bmRlZixcbiAgICBuZXh0VGljayA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZucyA9IFtdLFxuICAgICAgICAgICAgZW5xdWV1ZUZuID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm5zLnB1c2goZm4pID09PSAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxGbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm5zVG9DYWxsID0gZm5zLCBpID0gMCwgbGVuID0gZm5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuc1RvQ2FsbFtpKytdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7IC8vIGllMTAsIG5vZGVqcyA+PSAwLjEwXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHNldEltbWVkaWF0ZShjYWxsRm5zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5uZXh0VGljaykgeyAvLyBub2RlanMgPCAwLjEwXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHByb2Nlc3MubmV4dFRpY2soY2FsbEZucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZ2xvYmFsLnBvc3RNZXNzYWdlKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgdmFyIGlzUG9zdE1lc3NhZ2VBc3luYyA9IHRydWU7XG4gICAgICAgICAgICBpZihnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQb3N0TWVzc2FnZUFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbm1lc3NhZ2UnLCBjaGVja0FzeW5jKTtcbiAgICAgICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoJ19fY2hlY2tBc3luYycsICcqJyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbm1lc3NhZ2UnLCBjaGVja0FzeW5jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaXNQb3N0TWVzc2FnZUFzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdfX3Byb21pc2UnICsgK25ldyBEYXRlLFxuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlLmRhdGEgPT09IG1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEZucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlLCB0cnVlKSA6XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25tZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIGdsb2JhbC5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgICAgIGlmKCdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkgeyAvLyBpZTYtaWU4XG4gICAgICAgICAgICB2YXIgY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxGbnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIChkb2MuZG9jdW1lbnRFbGVtZW50IHx8IGRvYy5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUZuKGZuKSAmJiBjcmVhdGVTY3JpcHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHsgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICBlbnF1ZXVlRm4oZm4pICYmIHNldFRpbWVvdXQoY2FsbEZucywgMCk7XG4gICAgICAgIH07XG4gICAgfSkoKSxcbiAgICB0aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBpc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuICAgIH0sXG4gICAgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHIuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH0sXG4gICAgZ2V0QXJyYXlLZXlzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXMucHVzaChpKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBnZXRPYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIHJlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWZpbmVDdXN0b21FcnJvclR5cGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciByZXMgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXMucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHdyYXBPbkZ1bGZpbGxlZCA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgb25GdWxmaWxsZWQuY2FsbCh0aGlzLCB2YWwsIGlkeCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuLyoqXG4gKiBAY2xhc3MgRGVmZXJyZWRcbiAqIEBleHBvcnRzIHZvdzpEZWZlcnJlZFxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYERlZmVycmVkYCBjbGFzcyBpcyB1c2VkIHRvIGVuY2Fwc3VsYXRlIG5ld2x5LWNyZWF0ZWQgcHJvbWlzZSBvYmplY3QgYWxvbmcgd2l0aCBmdW5jdGlvbnMgdGhhdCByZXNvbHZlLCByZWplY3Qgb3Igbm90aWZ5IGl0LlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzY3JpcHRpb25cbiAqIFlvdSBjYW4gdXNlIGB2b3cuZGVmZXIoKWAgaW5zdGVhZCBvZiB1c2luZyB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBuZXcgdm93LkRlZmVycmVkKClgIGdpdmVzIHRoZSBzYW1lIHJlc3VsdCBhcyBgdm93LmRlZmVyKClgLlxuICovXG52YXIgRGVmZXJyZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKTtcbn07XG5cbkRlZmVycmVkLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgRGVmZXJyZWQucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29ycmVzcG9uZGluZyBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHByb21pc2UgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIHByb21pc2UgPSBkZWZlci5wcm9taXNlKCk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgLy8gdmFsdWUgaXMgXCInc3VjY2VzcydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5yZXNvbHZlKCdzdWNjZXNzJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzb2x2ZSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuaXNSZXNvbHZlZCgpIHx8IHRoaXMuX3Byb21pc2UuX3Jlc29sdmUodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIGByZWFzb25gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWFzb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgcHJvbWlzZSA9IGRlZmVyLnByb21pc2UoKTtcbiAgICAgKlxuICAgICAqIHByb21pc2UuZmFpbChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgKiAgICAgLy8gcmVhc29uIGlzIFwiJ3NvbWV0aGluZyBpcyB3cm9uZydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5yZWplY3QoJ3NvbWV0aGluZyBpcyB3cm9uZycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlamVjdCA6IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZih0aGlzLl9wcm9taXNlLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodm93LmlzUHJvbWlzZShyZWFzb24pKSB7XG4gICAgICAgICAgICByZWFzb24gPSByZWFzb24udGhlbihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBjb3JyZXNwb25kaW5nIHByb21pc2Ugd2l0aCBnaXZlbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBwcm9taXNlID0gZGVmZXIucHJvbWlzZSgpO1xuICAgICAqXG4gICAgICogcHJvbWlzZS5wcm9ncmVzcyhmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAvLyB2YWx1ZSBpcyBcIicyMCUnXCIsIFwiJzQwJSdcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlci5ub3RpZnkoJzIwJScpO1xuICAgICAqIGRlZmVyLm5vdGlmeSgnNDAlJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbm90aWZ5IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5pc1Jlc29sdmVkKCkgfHwgdGhpcy5fcHJvbWlzZS5fbm90aWZ5KHZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgUFJPTUlTRV9TVEFUVVMgPSB7XG4gICAgUEVORElORyAgIDogMCxcbiAgICBSRVNPTFZFRCAgOiAxLFxuICAgIEZVTEZJTExFRCA6IDIsXG4gICAgUkVKRUNURUQgIDogM1xufTtcblxuLyoqXG4gKiBAY2xhc3MgUHJvbWlzZVxuICogQGV4cG9ydHMgdm93OlByb21pc2VcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBQcm9taXNlYCBjbGFzcyBpcyB1c2VkIHdoZW4geW91IHdhbnQgdG8gZ2l2ZSB0byB0aGUgY2FsbGVyIHNvbWV0aGluZyB0byBzdWJzY3JpYmUgdG8sXG4gKiBidXQgbm90IHRoZSBhYmlsaXR5IHRvIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZC5cbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXIgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL3Byb21pc2VzLXVud3JhcHBpbmcvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RoZS1wcm9taXNlLWNvbnN0cnVjdG9yIGZvciBkZXRhaWxzLlxuICogQGRlc2NyaXB0aW9uXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5IG9ubHkgaWYgeW91IGFyZSBnb2luZyB0byB1c2UgYHZvd2AgYXMgRE9NIFByb21pc2VzIGltcGxlbWVudGF0aW9uLlxuICogSW4gb3RoZXIgY2FzZSB5b3Ugc2hvdWxkIHVzZSBgdm93LmRlZmVyKClgIGFuZCBgZGVmZXIucHJvbWlzZSgpYCBtZXRob2RzLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBmZXRjaEpTT04odXJsKSB7XG4gKiAgICAgcmV0dXJuIG5ldyB2b3cuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG5vdGlmeSkge1xuICogICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gKiAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICogICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICogICAgICAgICB4aHIuc2VuZCgpO1xuICogICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBpZih4aHIucmVzcG9uc2UpIHtcbiAqICAgICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigpKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfTtcbiAqICAgICB9KTtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZjtcbiAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5QRU5ESU5HO1xuXG4gICAgdGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgaWYocmVzb2x2ZXIpIHsgLy8gTk9URTogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL3Byb21pc2VzLXVud3JhcHBpbmcvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICByZXNvbHZlckZuTGVuID0gcmVzb2x2ZXIubGVuZ3RoO1xuXG4gICAgICAgIHJlc29sdmVyKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSZXNvbHZlZCgpIHx8IF90aGlzLl9yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb2x2ZXJGbkxlbiA+IDE/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzUmVzb2x2ZWQoKSB8fCBfdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgdW5kZWYsXG4gICAgICAgICAgICByZXNvbHZlckZuTGVuID4gMj9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNSZXNvbHZlZCgpIHx8IF90aGlzLl9ub3RpZnkodmFsKTtcbiAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICB1bmRlZik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFByb21pc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIG9mIGZ1bGZpbGxlZCBwcm9taXNlIG9yIHJlYXNvbiBpbiBjYXNlIG9mIHJlamVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhbHVlT2YgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBwcm9taXNlIGlzIHJlc29sdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZXNvbHZlZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzICE9PSBQUk9NSVNFX1NUQVRVUy5QRU5ESU5HO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsZmlsbGVkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFBST01JU0VfU1RBVFVTLkZVTEZJTExFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVqZWN0ZWQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gUFJPTUlTRV9TVEFUVVMuUkVKRUNURUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVhY3Rpb25zIHRvIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfSBBIG5ldyBwcm9taXNlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMgZm9yIGRldGFpbHNcbiAgICAgKi9cbiAgICB0aGVuIDogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGRlZmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyByZWplY3Rpb24gcmVhY3Rpb24gb25seS4gSXQgaXMgc2hvcnRjdXQgZm9yIGBwcm9taXNlLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkIENhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgICdjYXRjaCcgOiBmdW5jdGlvbihvblJlamVjdGVkLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZiwgb25SZWplY3RlZCwgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyByZWplY3Rpb24gcmVhY3Rpb24gb25seS4gSXQgaXMgc2hvcnRjdXQgZm9yIGBwcm9taXNlLnRoZW4obnVsbCwgb25SZWplY3RlZClgLiBJdCdzIGFsaWFzIGZvciBgY2F0Y2hgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZCBDYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmYWlsIDogZnVuY3Rpb24ob25SZWplY3RlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWYsIG9uUmVqZWN0ZWQsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVzb2x2aW5nIHJlYWN0aW9uICh0byBmdWxmaWxsbWVudCBhbmQgcmVqZWN0aW9uIGJvdGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZXNvbHZlZCBDYWxsYmFjayB0aGF0IHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHhdIENvbnRleHQgb2YgY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGFsd2F5cyA6IGZ1bmN0aW9uKG9uUmVzb2x2ZWQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlZC5jYWxsKHRoaXMsIF90aGlzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihjYiwgY2IsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcHJvZ3Jlc3MgcmVhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblByb2dyZXNzIENhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSB3aGVuIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbihvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZiwgdW5kZWYsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpa2UgYHByb21pc2UudGhlbmAsIGJ1dCBcInNwcmVhZHNcIiB0aGUgYXJyYXkgaW50byBhIHZhcmlhZGljIHZhbHVlIGhhbmRsZXIuXG4gICAgICogSXQgaXMgdXNlZnVsIHdpdGggYHZvdy5hbGxgIGFuZCBgdm93LmFsbFJlc29sdmVkYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRnVsZmlsbGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhZnRlciBwcm9taXNlIGhhcyBiZWVuIGZ1bGZpbGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblJlamVjdGVkXSBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrcyBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyMSA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBkZWZlcjIgPSB2b3cuZGVmZXIoKTtcbiAgICAgKlxuICAgICAqIHZvdy5hbGwoW2RlZmVyMS5wcm9taXNlKCksIGRlZmVyMi5wcm9taXNlKCldKS5zcHJlYWQoZnVuY3Rpb24oYXJnMSwgYXJnMikge1xuICAgICAqICAgICAvLyBhcmcxIGlzIFwiMVwiLCBhcmcyIGlzIFwiJ3R3bydcIiBoZXJlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZlcjEucmVzb2x2ZSgxKTtcbiAgICAgKiBkZWZlcjIucmVzb2x2ZSgndHdvJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3ByZWFkIDogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRnVsZmlsbGVkLmFwcGx5KHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWplY3RlZCxcbiAgICAgICAgICAgIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpa2UgYHRoZW5gLCBidXQgdGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLlxuICAgICAqIElmIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLCB0aHJvd3MgaXQgYXMgYW4gZXhjZXB0aW9uIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyID0gdm93LmRlZmVyKCk7XG4gICAgICogZGVmZXIucmVqZWN0KEVycm9yKCdJbnRlcm5hbCBlcnJvcicpKTtcbiAgICAgKiBkZWZlci5wcm9taXNlKCkuZG9uZSgpOyAvLyBleGNlcHRpb24gdG8gYmUgdGhyb3duXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZG9uZSA6IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eClcbiAgICAgICAgICAgIC5mYWlsKHRocm93RXhjZXB0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaW4gYGRlbGF5YCBtaWxsaXNlY29uZHMgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLFxuICAgICAqIG9yIGltbWVkaWF0ZWx5IHJlamVjdGVkIGlmIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgZGVsYXkgOiBmdW5jdGlvbihkZWxheSkge1xuICAgICAgICB2YXIgdGltZXIsXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy50aGVuKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIGJlIHJlamVjdGVkIGluIGB0aW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAgKiBpZiB0aGUgcHJvbWlzZSBpcyBub3QgcmVzb2x2ZWQgYmVmb3JlaGFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlciA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBwcm9taXNlV2l0aFRpbWVvdXQxID0gZGVmZXIucHJvbWlzZSgpLnRpbWVvdXQoNTApLFxuICAgICAqICAgICBwcm9taXNlV2l0aFRpbWVvdXQyID0gZGVmZXIucHJvbWlzZSgpLnRpbWVvdXQoMjAwKTtcbiAgICAgKlxuICAgICAqIHNldFRpbWVvdXQoXG4gICAgICogICAgIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgZGVmZXIucmVzb2x2ZSgnb2snKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgMTAwKTtcbiAgICAgKlxuICAgICAqIHByb21pc2VXaXRoVGltZW91dDEuZmFpbChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgKiAgICAgLy8gcHJvbWlzZVdpdGhUaW1lb3V0IHRvIGJlIHJlamVjdGVkIGluIDUwbXNcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHByb21pc2VXaXRoVGltZW91dDIudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAvLyBwcm9taXNlV2l0aFRpbWVvdXQgdG8gYmUgZnVsZmlsbGVkIHdpdGggXCInb2snXCIgdmFsdWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aW1lb3V0IDogZnVuY3Rpb24odGltZW91dCkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KG5ldyB2b3cuVGltZWRPdXRFcnJvcigndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZW91dCk7XG5cbiAgICAgICAgdGhpcy50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmZXIucHJvbWlzZSgpLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIF92b3cgOiB0cnVlLFxuXG4gICAgX3Jlc29sdmUgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzID4gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHZhbCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KFR5cGVFcnJvcignQ2FuXFwndCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5SRVNPTFZFRDtcblxuICAgICAgICBpZih2YWwgJiYgISF2YWwuX3ZvdykgeyAvLyBzaG9ydHBhdGggZm9yIHZvdy5Qcm9taXNlXG4gICAgICAgICAgICB2YWwuaXNGdWxmaWxsZWQoKT9cbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsKHZhbC52YWx1ZU9mKCkpIDpcbiAgICAgICAgICAgICAgICB2YWwuaXNSZWplY3RlZCgpP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QodmFsLnZhbHVlT2YoKSkgOlxuICAgICAgICAgICAgICAgICAgICB2YWwudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbm90aWZ5KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkIHx8IHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mdWxmaWxsKHZhbCk7XG4gICAgfSxcblxuICAgIF9mdWxmaWxsIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA+IFBST01JU0VfU1RBVFVTLlJFU09MVkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBQUk9NSVNFX1NUQVRVUy5GVUxGSUxMRUQ7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuXG4gICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3ModGhpcy5fZnVsZmlsbGVkQ2FsbGJhY2tzLCB2YWwpO1xuICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MgPSB0aGlzLl9yZWplY3RlZENhbGxiYWNrcyA9IHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzID0gdW5kZWY7XG4gICAgfSxcblxuICAgIF9yZWplY3QgOiBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzID4gUFJPTUlTRV9TVEFUVVMuUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFBST01JU0VfU1RBVFVTLlJFSkVDVEVEO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHJlYXNvbjtcblxuICAgICAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzLCByZWFzb24pO1xuICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MgPSB0aGlzLl9yZWplY3RlZENhbGxiYWNrcyA9IHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzID0gdW5kZWY7XG4gICAgfSxcblxuICAgIF9ub3RpZnkgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyh0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcywgdmFsKTtcbiAgICB9LFxuXG4gICAgX2FkZENhbGxiYWNrcyA6IGZ1bmN0aW9uKGRlZmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIGlmKG9uUmVqZWN0ZWQgJiYgIWlzRnVuY3Rpb24ob25SZWplY3RlZCkpIHtcbiAgICAgICAgICAgIGN0eCA9IG9uUmVqZWN0ZWQ7XG4gICAgICAgICAgICBvblJlamVjdGVkID0gdW5kZWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihvblByb2dyZXNzICYmICFpc0Z1bmN0aW9uKG9uUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICBjdHggPSBvblByb2dyZXNzO1xuICAgICAgICAgICAgb25Qcm9ncmVzcyA9IHVuZGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNiO1xuXG4gICAgICAgIGlmKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2IgPSB7IGRlZmVyIDogZGVmZXIsIGZuIDogaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCk/IG9uRnVsZmlsbGVkIDogdW5kZWYsIGN0eCA6IGN0eCB9O1xuICAgICAgICAgICAgdGhpcy5pc0Z1bGZpbGxlZCgpP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3MoW2NiXSwgdGhpcy5fdmFsdWUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsZWRDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBjYiA9IHsgZGVmZXIgOiBkZWZlciwgZm4gOiBvblJlamVjdGVkLCBjdHggOiBjdHggfTtcbiAgICAgICAgICAgIHRoaXMuaXNSZWplY3RlZCgpP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3MoW2NiXSwgdGhpcy5fdmFsdWUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RlZENhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cyA8PSBQUk9NSVNFX1NUQVRVUy5SRVNPTFZFRCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MucHVzaCh7IGRlZmVyIDogZGVmZXIsIGZuIDogb25Qcm9ncmVzcywgY3R4IDogY3R4IH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jYWxsQ2FsbGJhY2tzIDogZnVuY3Rpb24oY2FsbGJhY2tzLCBhcmcpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGlmKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1Jlc29sdmVkID0gdGhpcy5pc1Jlc29sdmVkKCksXG4gICAgICAgICAgICBpc0Z1bGZpbGxlZCA9IHRoaXMuaXNGdWxmaWxsZWQoKTtcblxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gMCwgY2IsIGRlZmVyLCBmbjtcbiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tpKytdO1xuICAgICAgICAgICAgICAgIGRlZmVyID0gY2IuZGVmZXI7XG4gICAgICAgICAgICAgICAgZm4gPSBjYi5mbjtcblxuICAgICAgICAgICAgICAgIGlmKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYi5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBjdHg/IGZuLmNhbGwoY3R4LCBhcmcpIDogZm4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIubm90aWZ5KHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShhcmcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoYXJnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ub3RpZnkoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKiBAbGVuZHMgUHJvbWlzZSAqL1xudmFyIHN0YXRpY01ldGhvZHMgPSB7XG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBnaXZlbiBgdmFsdWVgIHRvIGEgcHJvbWlzZSwgb3IgcmV0dXJucyB0aGUgYHZhbHVlYCBpZiBpdCdzIGFscmVhZHkgYSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBjYXN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5jYXN0KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGFyZSBmdWxmaWxsZWQsXG4gICAgICogb3IgdG8gYmUgcmVqZWN0ZWQgd2hlbiBhbnkgb2YgdGhlIGBpdGVyYWJsZWAgaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYWxsIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5hbGwoaXRlcmFibGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb25seSB3aGVuIGFueSBvZiB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgZnVsZmlsbGVkLFxuICAgICAqIG9yIHRvIGJlIHJlamVjdGVkIHdoZW4gdGhlIGZpcnN0IGl0ZW0gaXMgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVyYWJsZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByYWNlIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5hbnlSZXNvbHZlZChpdGVyYWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiBgdmFsdWVgLlxuICAgICAqIElmIGB2YWx1ZWAgaXMgYSBwcm9taXNlLCByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgYWRvcHRlZCB3aXRoIHRoZSBzdGF0ZSBvZiBnaXZlbiBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICByZXNvbHZlIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWFzb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcmVqZWN0IDogZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHJldHVybiB2b3cucmVqZWN0KHJlYXNvbik7XG4gICAgfVxufTtcblxuZm9yKHZhciBwcm9wIGluIHN0YXRpY01ldGhvZHMpIHtcbiAgICBzdGF0aWNNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApICYmXG4gICAgICAgIChQcm9taXNlW3Byb3BdID0gc3RhdGljTWV0aG9kc1twcm9wXSk7XG59XG5cbnZhciB2b3cgPSAvKiogQGV4cG9ydHMgdm93ICovIHtcbiAgICBEZWZlcnJlZCA6IERlZmVycmVkLFxuXG4gICAgUHJvbWlzZSA6IFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRlZmVycmVkLiBUaGlzIG1ldGhvZCBpcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBgdm93OkRlZmVycmVkYCBjbGFzcy5cbiAgICAgKiBJdCdzIGVxdWl2YWxlbnQgdG8gYG5ldyB2b3cuRGVmZXJyZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dm93OkRlZmVycmVkfVxuICAgICAqL1xuICAgIGRlZmVyIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UudGhlbmAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUmVqZWN0ZWRdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHJlYXNvbiBhZnRlciBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIENhbGxiYWNrIHRoYXQgd2lsbCB0byBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHdoZW4gOiBmdW5jdGlvbih2YWx1ZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LmNhc3QodmFsdWUpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLmZhaWxgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZCBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmYWlsIDogZnVuY3Rpb24odmFsdWUsIG9uUmVqZWN0ZWQsIGN0eCkge1xuICAgICAgICByZXR1cm4gdm93LndoZW4odmFsdWUsIHVuZGVmLCBvblJlamVjdGVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5hbHdheXNgLlxuICAgICAqIElmIGdpdmVuIGB2YWx1ZWAgaXMgbm90IGEgcHJvbWlzZSwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZXNvbHZlZCBDYWxsYmFjayB0aGF0IHdpbGwgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhbHdheXMgOiBmdW5jdGlvbih2YWx1ZSwgb25SZXNvbHZlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkuYWx3YXlzKG9uUmVzb2x2ZWQsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLnByb2dyZXNzYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUHJvZ3Jlc3MgQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbih2YWx1ZSwgb25Qcm9ncmVzcywgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkucHJvZ3Jlc3Mob25Qcm9ncmVzcywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2Uuc3ByZWFkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZ1bGZpbGxlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBmdWxmaWxsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25SZWplY3RlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2N0eF0gQ29udGV4dCBvZiBjYWxsYmFja3MgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHNwcmVhZCA6IGZ1bmN0aW9uKHZhbHVlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB2b3cud2hlbih2YWx1ZSkuc3ByZWFkKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5kb25lYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZ1bGZpbGxlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBmdWxmaWxsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25SZWplY3RlZF0gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgcmVhc29uIGFmdGVyIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gQ2FsbGJhY2sgdGhhdCB3aWxsIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgYWZ0ZXIgcHJvbWlzZSBoYXMgYmVlbiBub3RpZmllZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSBDb250ZXh0IG9mIGNhbGxiYWNrcyBleGVjdXRpb25cbiAgICAgKi9cbiAgICBkb25lIDogZnVuY3Rpb24odmFsdWUsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzLCBjdHgpIHtcbiAgICAgICAgdm93LndoZW4odmFsdWUpLmRvbmUob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBgdmFsdWVgIGlzIGEgcHJvbWlzZS1saWtlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZvdy5pc1Byb21pc2UoJ3NvbWV0aGluZycpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogdm93LmlzUHJvbWlzZSh2b3cuZGVmZXIoKS5wcm9taXNlKCkpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiB2b3cuaXNQcm9taXNlKHsgdGhlbiA6IGZ1bmN0aW9uKCkgeyB9KTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaXNQcm9taXNlIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2VyY2VzIGdpdmVuIGB2YWx1ZWAgdG8gYSBwcm9taXNlLCBvciByZXR1cm5zIHRoZSBgdmFsdWVgIGlmIGl0J3MgYWxyZWFkeSBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGNhc3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgISF2YWx1ZS5fdm93P1xuICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgdm93LnJlc29sdmUodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS52YWx1ZU9mYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgdm93LlByb21pc2VgLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZU9mIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUudmFsdWVPZik/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc0Z1bGZpbGxlZGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYHZvdy5Qcm9taXNlYCwgdGhlbiBgdmFsdWVgIGlzIGVxdWl2YWxlbnQgdG8gZnVsZmlsbGVkIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGdWxmaWxsZWQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5pc0Z1bGZpbGxlZCk/IHZhbHVlLmlzRnVsZmlsbGVkKCkgOiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc1JlamVjdGVkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgdm93LlByb21pc2VgLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlamVjdGVkIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuaXNSZWplY3RlZCk/IHZhbHVlLmlzUmVqZWN0ZWQoKSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgZXF1aXZhbGVudCB0byBgcHJvbWlzZS5pc1Jlc29sdmVkYC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVzb2x2ZWQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5pc1Jlc29sdmVkKT8gdmFsdWUuaXNSZXNvbHZlZCgpIDogdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIGB2YWx1ZWAuXG4gICAgICogSWYgYHZhbHVlYCBpcyBhIHByb21pc2UsIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBhZG9wdGVkIHdpdGggdGhlIHN0YXRlIG9mIGdpdmVuIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHJlc29sdmUgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gdm93LmRlZmVyKCk7XG4gICAgICAgIHJlcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlcy5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW4gYHZhbHVlYC5cbiAgICAgKiBJZiBgdmFsdWVgIGlzIGEgcHJvbWlzZSwgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGZ1bGZpbGwvcmVqZWN0aW9uIHZhbHVlIG9mIGdpdmVuIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bGZpbGwgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKSxcbiAgICAgICAgICAgIHByb21pc2UgPSBkZWZlci5wcm9taXNlKCk7XG5cbiAgICAgICAgZGVmZXIucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UuaXNGdWxmaWxsZWQoKT9cbiAgICAgICAgICAgIHByb21pc2UgOlxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuICAgICAqIElmIGByZWFzb25gIGlzIGEgcHJvbWlzZSwgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggZnVsZmlsbC9yZWplY3Rpb24gdmFsdWUgb2YgZ2l2ZW4gcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqL1xuICAgIHJlamVjdCA6IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB2YXIgZGVmZXIgPSB2b3cuZGVmZXIoKTtcbiAgICAgICAgZGVmZXIucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdpdGggYXJndW1lbnRzIGBhcmdzYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcHJvbWlzZTEgPSB2b3cuaW52b2tlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICogICAgIH0sICdvaycpLFxuICAgICAqICAgICBwcm9taXNlMiA9IHZvdy5pbnZva2UoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqIHByb21pc2UxLmlzRnVsZmlsbGVkKCk7IC8vIHRydWVcbiAgICAgKiBwcm9taXNlMS52YWx1ZU9mKCk7IC8vICdvaydcbiAgICAgKiBwcm9taXNlMi5pc1JlamVjdGVkKCk7IC8vIHRydWVcbiAgICAgKiBwcm9taXNlMi52YWx1ZU9mKCk7IC8vIGluc3RhbmNlIG9mIEVycm9yXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaW52b2tlIDogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSAxLCAwKSxcbiAgICAgICAgICAgIGNhbGxBcmdzO1xuICAgICAgICBpZihsZW4pIHsgLy8gb3B0aW1pemF0aW9uIGZvciBWOFxuICAgICAgICAgICAgY2FsbEFyZ3MgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGNhbGxBcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKGNhbGxBcmdzP1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGdsb2JhbCwgY2FsbEFyZ3MpIDpcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGdsb2JhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2b3cucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IGFmdGVyIGFsbCB0aGUgaXRlbXMgaW4gYGl0ZXJhYmxlYCBhcmUgZnVsZmlsbGVkLFxuICAgICAqIG9yIHRvIGJlIHJlamVjdGVkIHdoZW4gYW55IG9mIHRoZSBgaXRlcmFibGVgIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZXJhYmxlXG4gICAgICogQHJldHVybnMge3ZvdzpQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3aXRoIGFycmF5OlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGRlZmVyMSA9IHZvdy5kZWZlcigpLFxuICAgICAqICAgICBkZWZlcjIgPSB2b3cuZGVmZXIoKTtcbiAgICAgKlxuICAgICAqIHZvdy5hbGwoW2RlZmVyMS5wcm9taXNlKCksIGRlZmVyMi5wcm9taXNlKCksIDNdKVxuICAgICAqICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgICAgIC8vIHZhbHVlIGlzIFwiWzEsIDIsIDNdXCIgaGVyZVxuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqIGRlZmVyMS5yZXNvbHZlKDEpO1xuICAgICAqIGRlZmVyMi5yZXNvbHZlKDIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3aXRoIG9iamVjdDpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBkZWZlcjEgPSB2b3cuZGVmZXIoKSxcbiAgICAgKiAgICAgZGVmZXIyID0gdm93LmRlZmVyKCk7XG4gICAgICpcbiAgICAgKiB2b3cuYWxsKHsgcDEgOiBkZWZlcjEucHJvbWlzZSgpLCBwMiA6IGRlZmVyMi5wcm9taXNlKCksIHAzIDogMyB9KVxuICAgICAqICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgICAgIC8vIHZhbHVlIGlzIFwieyBwMSA6IDEsIHAyIDogMiwgcDMgOiAzIH1cIiBoZXJlXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIxLnJlc29sdmUoMSk7XG4gICAgICogZGVmZXIyLnJlc29sdmUoMik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYWxsIDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICBpc1Byb21pc2VzQXJyYXkgPSBpc0FycmF5KGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGtleXMgPSBpc1Byb21pc2VzQXJyYXk/XG4gICAgICAgICAgICAgICAgZ2V0QXJyYXlLZXlzKGl0ZXJhYmxlKSA6XG4gICAgICAgICAgICAgICAgZ2V0T2JqZWN0S2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlcyA9IGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fTtcblxuICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBsZW47XG4gICAgICAgIHZvdy5fZm9yRWFjaChcbiAgICAgICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJlc1trZXlzW2lkeF1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYoIS0taSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmVyLnJlamVjdCxcbiAgICAgICAgICAgIGRlZmVyLm5vdGlmeSxcbiAgICAgICAgICAgIGRlZmVyLFxuICAgICAgICAgICAga2V5cyk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGFyZSByZXNvbHZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVyYWJsZVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZGVmZXIxID0gdm93LmRlZmVyKCksXG4gICAgICogICAgIGRlZmVyMiA9IHZvdy5kZWZlcigpO1xuICAgICAqXG4gICAgICogdm93LmFsbFJlc29sdmVkKFtkZWZlcjEucHJvbWlzZSgpLCBkZWZlcjIucHJvbWlzZSgpXSkuc3ByZWFkKGZ1bmN0aW9uKHByb21pc2UxLCBwcm9taXNlMikge1xuICAgICAqICAgICBwcm9taXNlMS5pc1JlamVjdGVkKCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICAgICBwcm9taXNlMS52YWx1ZU9mKCk7IC8vIHJldHVybnMgXCInZXJyb3InXCJcbiAgICAgKiAgICAgcHJvbWlzZTIuaXNGdWxmaWxsZWQoKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogICAgIHByb21pc2UyLnZhbHVlT2YoKTsgLy8gcmV0dXJucyBcIidvaydcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmZXIxLnJlamVjdCgnZXJyb3InKTtcbiAgICAgKiBkZWZlcjIucmVzb2x2ZSgnb2snKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhbGxSZXNvbHZlZCA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpLFxuICAgICAgICAgICAgaXNQcm9taXNlc0FycmF5ID0gaXNBcnJheShpdGVyYWJsZSksXG4gICAgICAgICAgICBrZXlzID0gaXNQcm9taXNlc0FycmF5P1xuICAgICAgICAgICAgICAgIGdldEFycmF5S2V5cyhpdGVyYWJsZSkgOlxuICAgICAgICAgICAgICAgIGdldE9iamVjdEtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgaSA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9O1xuXG4gICAgICAgIGlmKCFpKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAtLWkgfHwgZGVmZXIucmVzb2x2ZShpdGVyYWJsZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHZvdy5fZm9yRWFjaChcbiAgICAgICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICAgICAgb25SZXNvbHZlZCxcbiAgICAgICAgICAgIG9uUmVzb2x2ZWQsXG4gICAgICAgICAgICBkZWZlci5ub3RpZnksXG4gICAgICAgICAgICBkZWZlcixcbiAgICAgICAgICAgIGtleXMpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIGFsbFBhdGllbnRseSA6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiB2b3cuYWxsUmVzb2x2ZWQoaXRlcmFibGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNQcm9taXNlc0FycmF5ID0gaXNBcnJheShpdGVyYWJsZSksXG4gICAgICAgICAgICAgICAga2V5cyA9IGlzUHJvbWlzZXNBcnJheT9cbiAgICAgICAgICAgICAgICAgICAgZ2V0QXJyYXlLZXlzKGl0ZXJhYmxlKSA6XG4gICAgICAgICAgICAgICAgICAgIGdldE9iamVjdEtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgICAgIHJlamVjdGVkUHJvbWlzZXMsIGZ1bGZpbGxlZFByb21pc2VzLFxuICAgICAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoLCBpID0gMCwga2V5LCBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJvbWlzZXNBcnJheT8gW10gOiB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gaXRlcmFibGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZih2b3cuaXNSZWplY3RlZChwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzIHx8IChyZWplY3RlZFByb21pc2VzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm9taXNlc0FycmF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRQcm9taXNlcy5wdXNoKHByb21pc2UudmFsdWVPZigpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzW2tleV0gPSBwcm9taXNlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZighcmVqZWN0ZWRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAoZnVsZmlsbGVkUHJvbWlzZXMgfHwgKGZ1bGZpbGxlZFByb21pc2VzID0gaXNQcm9taXNlc0FycmF5PyBbXSA6IHt9KSlba2V5XSA9IHZvdy52YWx1ZU9mKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocmVqZWN0ZWRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IHJlamVjdGVkUHJvbWlzZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRQcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IHdoZW4gYW55IG9mIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGlzIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIGFsbCB0aGUgaXRlbXMgYXJlIHJlamVjdGVkICh3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHJlamVjdGVkIGl0ZW0pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYW55IDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgICAgICBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG5cbiAgICAgICAgaWYoIWxlbikge1xuICAgICAgICAgICAgZGVmZXIucmVqZWN0KEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMCwgcmVhc29uO1xuICAgICAgICB2b3cuX2ZvckVhY2goXG4gICAgICAgICAgICBpdGVyYWJsZSxcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUsXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaSB8fCAocmVhc29uID0gZSk7XG4gICAgICAgICAgICAgICAgKytpID09PSBsZW4gJiYgZGVmZXIucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmZXIubm90aWZ5LFxuICAgICAgICAgICAgZGVmZXIpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvbmx5IHdoZW4gYW55IG9mIHRoZSBpdGVtcyBpbiBgaXRlcmFibGVgIGlzIGZ1bGZpbGxlZCxcbiAgICAgKiBvciB0byBiZSByZWplY3RlZCB3aGVuIHRoZSBmaXJzdCBpdGVtIGlzIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlcmFibGVcbiAgICAgKiBAcmV0dXJucyB7dm93OlByb21pc2V9XG4gICAgICovXG4gICAgYW55UmVzb2x2ZWQgOiBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgICAgICB2YXIgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcblxuICAgICAgICBpZighbGVuKSB7XG4gICAgICAgICAgICBkZWZlci5yZWplY3QoRXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdm93Ll9mb3JFYWNoKFxuICAgICAgICAgICAgaXRlcmFibGUsXG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlLFxuICAgICAgICAgICAgZGVmZXIucmVqZWN0LFxuICAgICAgICAgICAgZGVmZXIubm90aWZ5LFxuICAgICAgICAgICAgZGVmZXIpO1xuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBlcXVpdmFsZW50IHRvIGBwcm9taXNlLmRlbGF5YC5cbiAgICAgKiBJZiBnaXZlbiBgdmFsdWVgIGlzIG5vdCBhIHByb21pc2UsIHRoZW4gYHZhbHVlYCBpcyBlcXVpdmFsZW50IHRvIGZ1bGZpbGxlZCBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICBkZWxheSA6IGZ1bmN0aW9uKHZhbHVlLCBkZWxheSkge1xuICAgICAgICByZXR1cm4gdm93LnJlc29sdmUodmFsdWUpLmRlbGF5KGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGVxdWl2YWxlbnQgdG8gYHByb21pc2UudGltZW91dGAuXG4gICAgICogSWYgZ2l2ZW4gYHZhbHVlYCBpcyBub3QgYSBwcm9taXNlLCB0aGVuIGB2YWx1ZWAgaXMgZXF1aXZhbGVudCB0byBmdWxmaWxsZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgICAqIEByZXR1cm5zIHt2b3c6UHJvbWlzZX1cbiAgICAgKi9cbiAgICB0aW1lb3V0IDogZnVuY3Rpb24odmFsdWUsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHZvdy5yZXNvbHZlKHZhbHVlKS50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH0sXG5cbiAgICBfZm9yRWFjaCA6IGZ1bmN0aW9uKHByb21pc2VzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcywgY3R4LCBrZXlzKSB7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzPyBrZXlzLmxlbmd0aCA6IHByb21pc2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHZvdy53aGVuKFxuICAgICAgICAgICAgICAgIHByb21pc2VzW2tleXM/IGtleXNbaV0gOiBpXSxcbiAgICAgICAgICAgICAgICB3cmFwT25GdWxmaWxsZWQob25GdWxmaWxsZWQsIGkpLFxuICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBjdHgpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRpbWVkT3V0RXJyb3IgOiBkZWZpbmVDdXN0b21FcnJvclR5cGUoJ1RpbWVkT3V0Jylcbn07XG5cbnZhciBkZWZpbmVBc0dsb2JhbCA9IHRydWU7XG5pZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2b3c7XG4gICAgZGVmaW5lQXNHbG9iYWwgPSBmYWxzZTtcbn1cblxuaWYodHlwZW9mIG1vZHVsZXMgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24obW9kdWxlcy5kZWZpbmUpKSB7XG4gICAgbW9kdWxlcy5kZWZpbmUoJ3ZvdycsIGZ1bmN0aW9uKHByb3ZpZGUpIHtcbiAgICAgICAgcHJvdmlkZSh2b3cpO1xuICAgIH0pO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbmlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gdm93O1xuICAgIH0pO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbmRlZmluZUFzR2xvYmFsICYmIChnbG9iYWwudm93ID0gdm93KTtcblxufSkodGhpcyk7XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJtb2R1bGUuZXhwb3J0cy5zZXEgPSByZXF1aXJlKFwiLi9zZXFcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlcSwgbmFtZSwgaWQpIHtcbiAgICB0aGlzLnNlcSA9IHNlcTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLm1ldGEgPSB7fTtcbn07XG4iLCIvLyB0aGlzIGlzIGEgbGlnaHQtd2VpZ2h0IGJ1aWxkIHdpdGhvdXQgdGhlIHNjcm9sbGluZyBtb2R1bGVcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVuZGVyX3hfYXhpc19sYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhYmVsID0gXCJNb2RlbCBQb3NpdGlvblwiO1xuICAgICAgaWYgKHRoaXMuZGlzcGxheV9hbGlfbWFwKSB7XG4gICAgICAgIGxhYmVsID0gXCJBbGlnbm1lbnQgQ29sdW1uXCI7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxlZF9vbi5maW5kKCcubG9nb194YXhpcycpLnJlbW92ZSgpO1xuICAgICAgdGhpcy5jYWxsZWRfb24ucHJlcGVuZCgnPGRpdiBjbGFzcz1cImxvZ29feGF4aXNcIiBjbGFzcz1cImNlbnRlcmVkXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDo0MHB4XCI+PHAgY2xhc3M9XCJ4YXhpc190ZXh0XCIgc3R5bGU9XCJ3aWR0aDoxMGVtO21hcmdpbjoxZW0gYXV0b1wiPicgKyBsYWJlbCArICc8L3A+PC9kaXY+Jyk7XG5cbiAgICB9LFxuICAgIHJlbmRlcl95X2F4aXNfbGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vYXR0YWNoIGEgY2FudmFzIGZvciB0aGUgeS1heGlzXG4gICAgICB0aGlzLmRvbV9lbGVtZW50LnBhcmVudCgpLmJlZm9yZSgnPGNhbnZhcyBjbGFzcz1cImxvZ29feWF4aXNcIiBoZWlnaHQ9XCInK3RoaXMub3B0aW9ucy5oZWlnaHQrJ1wiIHdpZHRoPVwiNTVcIj48L2NhbnZhcz4nKTtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbGxlZF9vbi5maW5kKCcubG9nb195YXhpcycpLFxuICAgICAgdG9wX3BpeF9oZWlnaHQgPSAwLFxuICAgICAgYm90dG9tX3BpeF9oZWlnaHQgPSAwLFxuICAgICAgdG9wX2hlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5tYXhfaGVpZ2h0KSxcbiAgICAgIGJvdHRvbV9oZWlnaHQgPSAoaXNOYU4odGhpcy5kYXRhLm1pbl9oZWlnaHRfb2JzKSkgPyAwIDogcGFyc2VJbnQodGhpcy5kYXRhLm1pbl9oZWlnaHRfb2JzLCAxMCksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGF4aXNfbGFiZWwgPSBcIkluZm9ybWF0aW9uIENvbnRlbnQgKGJpdHMpXCI7XG5cbiAgICAgIGNvbnRleHQgPSBjYW52YXNbMF0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIC8vZHJhdyBtaW4vbWF4IHRpY2sgbWFya3NcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyg1NSwgMSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyg0MCwgMSk7XG5cbiAgICAgIGNvbnRleHQubW92ZVRvKDU1LCB0aGlzLmluZm9fY29udGVudF9oZWlnaHQpO1xuICAgICAgY29udGV4dC5saW5lVG8oNDAsIHRoaXMuaW5mb19jb250ZW50X2hlaWdodCk7XG5cblxuICAgICAgY29udGV4dC5tb3ZlVG8oNTUsICh0aGlzLmluZm9fY29udGVudF9oZWlnaHQgLyAyKSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyg0MCwgKHRoaXMuaW5mb19jb250ZW50X2hlaWdodCAvIDIpKTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiM2NjY2NjZcIjtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgIC8vZHJhdyB0aGUgbGFiZWwgdGV4dFxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiM2NjY2NjZcIjtcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgY29udGV4dC5mb250ID0gXCJib2xkIDEwcHggQXJpYWxcIjtcblxuICAgICAgLy8gZHJhdyB0aGUgbWF4IGxhYmVsXG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHBhcnNlRmxvYXQodGhpcy5kYXRhLm1heF9oZWlnaHQpLnRvRml4ZWQoMSksIDM4LCAwKTtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblxuICAgICAgLy8gZHJhdyB0aGUgbWlkcG9pbnQgbGFiZWxzXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHBhcnNlRmxvYXQodGhpcy5kYXRhLm1heF9oZWlnaHQgLyAyKS50b0ZpeGVkKDEpLCAzOCwgKHRoaXMuaW5mb19jb250ZW50X2hlaWdodCAvIDIpKTtcbiAgICAgIC8vIGRyYXcgdGhlIG1pbiBsYWJlbFxuICAgICAgY29udGV4dC5maWxsVGV4dCgnMCcsIDM4LCB0aGlzLmluZm9fY29udGVudF9oZWlnaHQpO1xuXG4gICAgICAvLyBkcmF3IHRoZSBheGlzIGxhYmVsXG4gICAgICBpZiAodGhpcy5kYXRhLmhlaWdodF9jYWxjID09PSAnc2NvcmUnKSB7XG4gICAgICAgIGF4aXNfbGFiZWwgPSBcIlNjb3JlIChiaXRzKVwiO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKDUsIHRoaXMuaGVpZ2h0IC8gMiAtIDIwKTtcbiAgICAgIGNvbnRleHQucm90YXRlKC1NYXRoLlBJIC8gMik7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICBjb250ZXh0LmZvbnQgPSBcIm5vcm1hbCAxMnB4IEFyaWFsXCI7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KGF4aXNfbGFiZWwsIDEsIDApO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIC8vIGRyYXcgdGhlIGluc2VydCByb3cgbGFiZWxzXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCdvY2N1cGFuY3knLCA1NSwgdGhpcy5pbmZvX2NvbnRlbnRfaGVpZ2h0ICsgNyk7XG4gICAgICBpZiAodGhpcy5zaG93X2luc2VydHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCgnaW5zLiBwcm9iLicsIDUwLCAyODApO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCdpbnMuIGxlbi4nLCA0NiwgMjk2KTtcbiAgICAgIH1cbiAgICB9XG59OyBcbiIsInZhciBjYW52X3N1cHBvcnQgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbnZhc1N1cHBvcnQoKSB7XG4gIGlmICghY2Fudl9zdXBwb3J0KSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52X3N1cHBvcnQgPSAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKTtcbiAgfVxuICByZXR1cm4gY2Fudl9zdXBwb3J0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICdBJzogJyNGRjk5NjYnLFxuICAnQyc6ICcjMDA5OTk5JyxcbiAgJ0QnOiAnI0ZGMDAwMCcsXG4gICdFJzogJyNDQzAwMzMnLFxuICAnRic6ICcjMDBGRjAwJyxcbiAgJ0cnOiAnI2YyZjIwYycsXG4gICdIJzogJyM2NjAwMzMnLFxuICAnSSc6ICcjQ0M5OTMzJyxcbiAgJ0snOiAnIzY2MzMwMCcsXG4gICdMJzogJyNGRjk5MzMnLFxuICAnTSc6ICcjQ0M5OUNDJyxcbiAgJ04nOiAnIzMzNjY2NicsXG4gICdQJzogJyMwMDk5RkYnLFxuICAnUSc6ICcjNjY2NkNDJyxcbiAgJ1InOiAnIzk5MDAwMCcsXG4gICdTJzogJyMwMDAwRkYnLFxuICAnVCc6ICcjMDBGRkZGJyxcbiAgJ1YnOiAnI0ZGQ0MzMycsXG4gICdXJzogJyM2NkNDNjYnLFxuICAnWSc6ICcjMDA2NjAwJ1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdBJzogJyNjYmY3NTEnLFxuICAgICdDJzogJyM1ZWMwY2MnLFxuICAgICdHJzogJyNmZmRmNTknLFxuICAgICdUJzogJyNiNTFmMTYnLFxuICAgICdVJzogJyNiNTFmMTYnXG4gIH07XG4iLCJ2YXIgJCA9IHJlcXVpcmUoXCJqYm9uZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkZWwsbG9nbywgbG9nb19ncmFwaGljKXtcblxuICAkZWwuZmluZCgnLmxvZ29fc2V0dGluZ3Nfc3dpdGNoLCAubG9nb19zZXR0aW5ncyAuY2xvc2UnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKCcubG9nb19zZXR0aW5ncycpLnRvZ2dsZSgpO1xuICB9KTtcblxuICAkZWwuZmluZCgnLmxvZ29fcmVzZXQnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBsb2dvLmNoYW5nZVpvb20oeyd0YXJnZXQnOiBsb2dvLmRlZmF1bHRfem9vbX0pO1xuICB9KTtcblxuICAkZWwuZmluZCgnLmxvZ29fY2hhbmdlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gICRlbC5maW5kKCcubG9nb196b29taW4nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBsb2dvLmNoYW5nZVpvb20oeydkaXN0YW5jZSc6IDAuMSwgJ2RpcmVjdGlvbic6ICcrJ30pO1xuICB9KTtcblxuICAkZWwuZmluZCgnLmxvZ29fem9vbW91dCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxvZ28uY2hhbmdlWm9vbSh7J2Rpc3RhbmNlJzogMC4xLCAnZGlyZWN0aW9uJzogJy0nfSk7XG4gIH0pO1xuXG4gICRlbC5maW5kKCcubG9nb19zY2FsZScpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIGxvZ28udG9nZ2xlU2NhbGUodGhpcy52YWx1ZSk7XG4gIH0pO1xuXG4gICRlbC5maW5kKCcubG9nb19jb2xvcicpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIGxvZ28udG9nZ2xlQ29sb3JzY2hlbWUodGhpcy52YWx1ZSk7XG4gIH0pO1xuXG4gICRlbC5maW5kKCcubG9nb19hbGlfbWFwJykub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgbG9nby50b2dnbGVBbGlNYXAodGhpcy52YWx1ZSk7XG4gIH0pO1xuXG4gICRlbC5maW5kKCcubG9nb19wb3NpdGlvbicpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlLm1hdGNoKC9eXFxkKyQvbSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nby5zY3JvbGxUb0NvbHVtbih0aGlzLnZhbHVlLCAxKTtcbiAgfSk7XG5cbiAgbG9nb19ncmFwaGljLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gbmVlZCB0byBnZXQgY29vcmRpbmF0ZXMgb2YgbW91c2UgY2xpY2tcbiAgICBjb25zb2xlLmxvZyhcImRibGNsaWNrXCIsIGxvZ28pO1xuXG4gICAgb2Zmc2V0ID0gbG9nby5sb2dvX2dyYXBoaWMub2Zmc2V0KCksXG4gICAgeCA9IHBhcnNlSW50KChlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQpLCAxMCksXG5cbiAgICAvLyBnZXQgbW91c2UgcG9zaXRpb24gaW4gdGhlIHdpbmRvd1xuICAgIHdpbmRvd19wb3NpdGlvbiA9IGUucGFnZVggLSAkZWwucGFyZW50KCkub2Zmc2V0KCkubGVmdCxcblxuICAgIC8vIGdldCBjb2x1bW4gbnVtYmVyXG4gICAgY29sID0gbG9nby5jb2x1bW5Gcm9tQ29vcmRpbmF0ZXMoeCksXG5cbiAgICBjb25zb2xlLmxvZyhcImNvbFwiLCBjb2wpO1xuXG4gICAgLy8gY2hvb3NlIG5ldyB6b29tIGxldmVsIGFuZCB6b29tIGluLlxuICAgIGN1cnJlbnQgPSBsb2dvLnpvb207XG5cbiAgICBpZiAoY3VycmVudCA8IDEpIHtcbiAgICAgIGxvZ28uY2hhbmdlWm9vbSh7J3RhcmdldCc6IDEsIG9mZnNldDogd2luZG93X3Bvc2l0aW9uLCBjb2x1bW46IGNvbH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dvLmNoYW5nZVpvb20oeyd0YXJnZXQnOiAwLjMsIG9mZnNldDogd2luZG93X3Bvc2l0aW9uLCBjb2x1bW46IGNvbH0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSk7XG5cbiAgJChkb2N1bWVudCkub24oJGVsLmF0dHIoJ2lkJykgKyBcIi5zY3JvbGxlZFRvXCIsIGZ1bmN0aW9uIChlLCBsZWZ0LCB0b3AsIHpvb20pIHtcbiAgICBsb2dvLnJlbmRlcih7dGFyZ2V0OiBsZWZ0fSk7XG4gIH0pO1xuXG4gICQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUuY3RybEtleSkge1xuICAgICAgaWYgKGUud2hpY2ggPT09IDYxIHx8IGUud2hpY2ggPT09IDEwNykge1xuICAgICAgICB6b29tICs9IDAuMTtcbiAgICAgICAgbG9nby5jaGFuZ2Vab29tKHsnZGlzdGFuY2UnOiAwLjEsICdkaXJlY3Rpb24nOiAnKyd9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlLndoaWNoID09PSAxMDkgfHwgZS53aGljaCA9PT0gMCkge1xuICAgICAgICB6b29tID0gem9vbSAtIDAuMTtcbiAgICAgICAgbG9nby5jaGFuZ2Vab29tKHsnZGlzdGFuY2UnOiAwLjEsICdkaXJlY3Rpb24nOiAnLSd9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwiXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4vL3ZhciBDb25zZW5zdXNDb2xvcnMgPSByZXF1aXJlKFwiLi9jb25zZW5zdXNDb2xvcnMuanNcIik7XG52YXIgY2FudmFzU3VwcG9ydCA9IHJlcXVpcmUoXCIuL2NhbnZhc1N1cHBvcnQuanNcIik7XG52YXIgcmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyL3JlbmRlci5qc1wiKTtcbnZhciBMZXR0ZXIgPSByZXF1aXJlKFwiLi9tb2RlbC9sZXR0ZXIuanNcIik7XG52YXIgdmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS12aWV3alwiKTtcbnZhciBheGlzID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbnZhciBldmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vZXZlbnRMaXN0ZW5lci5qc1wiKTtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoXCIuL2luZm8vc2V0dGluZ3MuanNcIik7XG5cbnZhciBqYm9uZSA9IHJlcXVpcmUoXCJqYm9uZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2aWV3LmV4dGVuZCh7XG5cbiAgb3B0aW9uczoge1xuICAgIHhheGlzOiB0cnVlLFxuICAgIHlheGlzOiB0cnVlLFxuICAgIGhlaWdodDogMzAwLFxuICAgIGNvbHVtbl93aWR0aDogMzQsXG4gICAgZGVidWc6IHRydWUsXG4gICAgc2NhbGVfaGVpZ2h0X2VuYWJsZWQ6IHRydWUsXG4gICAgc2NhbGVkX21heDogdHJ1ZSxcbiAgICB6b29tX2J1dHRvbnM6IHRydWUsXG4gICAgY29sb3JzY2hlbWU6ICdkZWZhdWx0JyxcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgc3RhcnQ6IDEsXG4gICAgZW5kOiB1bmRlZmluZWQsXG4gICAgem9vbTogMC40LFxuICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgIGRpdmlkZXI6IGZhbHNlLFxuICAgIHNob3dfcHJvYnM6IGZhbHNlLFxuICAgIGRpdmlkZXJfc3RlcDogNSxcbiAgICBzaG93X2RpdmlkZXI6IGZhbHNlLFxuICAgIGJvcmRlcjogZmFsc2UsXG4gICAgc2V0dGluZ3M6IGZhbHNlLFxuICAgIHNjcm9sbGVyOiB0cnVlLFxuICAgIHBvc2l0aW9uTWFya2VyOiB0cnVlXG4gIH0sXG5cbiAgbG9hZERlZmF1bHQ6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIC8vIG5ldmVyIHNob3cgdGhlIGFsaWdubWVudCBjb29yZGluYXRlcyBieSBkZWZhdWx0IGFzIHRoYXQgd291bGQgZ2V0XG4gICAgLy8gcmVhbGx5IGNvbmZ1c2luZy5cbiAgICB0aGlzLmRpc3BsYXlfYWxpX21hcCA9IDA7XG5cbiAgICB0aGlzLmFscGhhYmV0ID0gb3B0aW9ucy5kYXRhLmFscGhhYmV0IHx8ICdkbmEnO1xuXG4gICAgdGhpcy5zdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgLy90aGlzLmVuZCA9IG9wdGlvbnMuZW5kIHx8IHRoaXMuZGF0YS5oZWlnaHRBcnIubGVuZ3RoO1xuICAgIHRoaXMuem9vbSA9IHBhcnNlRmxvYXQob3B0aW9ucy56b29tKSB8fCAwLjQ7XG4gICAgdGhpcy5kZWZhdWx0X3pvb20gPSB0aGlzLnpvb207XG5cbiAgICB0aGlzLmNvbHVtbl93aWR0aCA9IG9wdGlvbnMuY29sdW1uX3dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5jYW52YXNfd2lkdGggPSA1MDAwO1xuICAgIHRoaXMuc2NhbGVfaGVpZ2h0X2VuYWJsZWQgPSBvcHRpb25zLnNjYWxlX2hlaWdodF9lbmFibGVkO1xuXG4gICAgLy8gdGhpcyBuZWVkcyB0byBiZSBzZXQgdG8gbnVsbCBoZXJlIHNvIHRoYXQgd2UgY2FuIGluaXRpYWxpc2UgaXQgYWZ0ZXJcbiAgICAvLyB0aGUgcmVuZGVyIGZ1bmN0aW9uIGhhcyBmaXJlZCBhbmQgdGhlIHdpZHRoIGRldGVybWluZWQuXG4gICAgdGhpcy5zY3JvbGxtZSA9IG51bGw7XG5cbiAgICB0aGlzLnByZXZpb3VzX3RhcmdldCA9IDA7XG4gICAgLy8ga2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2FudmFzIGVsZW1lbnRzIGhhdmUgYmVlbiBkcmF3biBhbmQgd2hpY2ggb25lcyBoYXZlbid0LlxuICAgIHRoaXMucmVuZGVyZWQgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzX3pvb20gPSAwO1xuXG4gICAgaWYodGhpcy5kYXRhLm1heF9oZWlnaHQgPT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMuZGF0YS5tYXhfaGVpZ2h0ID0gdGhpcy5jYWxjTWF4SGVpZ2h0KHRoaXMuZGF0YS5oZWlnaHRBcnIpOyBcbiAgICB9XG5cbiAgICAvLyBvbmx5IHNob3cgaW5zZXJ0IHdoZW4gd2UgYWN0dWFsbHkgaGF2ZSB0aGUgZGF0YVxuICAgIGlmKCF0aGlzLmRhdGEuaW5zZXJ0X3Byb2JzIHx8ICF0aGlzLmRhdGEuZGVsZXRlX3Byb2JzKXtcbiAgICAgIHRoaXMub3B0aW9ucy5zaG93X3Byb2JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NhbGVkX21heCkge1xuICAgICAgdGhpcy5kYXRhLm1heF9oZWlnaHQgPSBvcHRpb25zLmRhdGEubWF4X2hlaWdodF9vYnMgfHwgdGhpcy5kYXRhLm1heF9oZWlnaHQgfHwgMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhLm1heF9oZWlnaHQgPSBvcHRpb25zLmRhdGEubWF4X2hlaWdodF90aGVvcnkgfHwgdGhpcy5kYXRhLm1heF9oZWlnaHQgfHwgMjtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLmNvbG9ycyl7XG4gICAgICB0aGlzLmNoYW5nZUNvbG9ycyhvcHRpb25zLmNvbG9ycyk7XG4gICAgfWVsc2V7XG4gICAgICBpZiAodGhpcy5hbHBoYWJldCA9PT0gJ2FhJykge1xuICAgICAgICB0aGlzLmFhX2NvbG9ycyA9IHJlcXVpcmUoXCIuL2NvbG9ycy9hYS5qc1wiKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VDb2xvcnModGhpcy5hYV9jb2xvcnMpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuZG5hX2NvbG9ycyA9IHJlcXVpcmUoXCIuL2NvbG9ycy9kbmEuanNcIik7XG4gICAgICAgIHRoaXMuY2hhbmdlQ29sb3JzKHRoaXMuZG5hX2NvbG9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFjYW52YXNTdXBwb3J0KCkpIHtcbiAgICAgIHRoaXMuZWwudGV4dENvbnRlbnQgPSBcIllvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FudmFzLlwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZihvcHRpb25zLmRhdGEgPT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMuZWwudGV4dENvbnRlbnQgPSBcIk5vIGRhdGEgYWRkZWQuXCI7XG4gICAgfVxuXG4gICAgLy8gbG9hZCBkZWZhdWx0IHNldHRpbmdzXG4gICAgXy5leHRlbmQodGhpcy5vcHRpb25zLG9wdGlvbnMpO1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5sb2FkRGVmYXVsdChvcHQpO1xuXG4gICAgaWYoIXRoaXMub3B0aW9ucy5zaG93X3Byb2JzKXtcbiAgICAgIHRoaXMuaW5mb19jb250ZW50X2hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1lbHNle1xuICAgICAgLy8gdHVybiBvZmYgdGhlIGluc2VydCByb3dzIGlmIHRoZSBobW0gdXNlZCB0aGUgb2JzZXJ2ZWQgb3Igd2VpZ2h0ZWQgcHJvY2Vzc2luZyBmbGFncy5cbiAgICAgIGlmICh0aGlzLmRhdGEucHJvY2Vzc2luZyAmJiAvXm9ic2VydmVkfHdlaWdodGVkLy50ZXN0KHRoaXMuZGF0YS5wcm9jZXNzaW5nKSkge1xuICAgICAgICB0aGlzLnNob3dfaW5zZXJ0cyA9IDA7XG4gICAgICAgIHRoaXMuaW5mb19jb250ZW50X2hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gMTQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dfaW5zZXJ0cyA9IDE7XG4gICAgICAgIHRoaXMuaW5mb19jb250ZW50X2hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gNDQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVsID0gamJvbmUodGhpcy5lbCk7XG5cbiAgICB0aGlzLmluaXREaXZzKCk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuc2V0dGluZ3Mpe1xuICAgICAgdmFyIGZvcm0gPSBzZXR0aW5ncyh0aGlzLG9wdCk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoZm9ybSk7XG4gICAgfVxuXG4gICAgZXZlbnRMaXN0ZW5lcih0aGlzLiRlbCx0aGlzLCB0aGlzLmxvZ29fZ3JhcGhpYyk7XG4gICAgLypcbiAgICAgICBpZiAob3B0LmNvbHVtbkluZm8pIHtcbiAgICAgICB2YXIgY29sdW1uSW5mbyA9IHJlcXVpcmUoXCIuL2luZm8vY29sdW1uX2luZm8uanNcIik7XG4gICAgICAgY29sdW1uSW5mbyh0aGlzKTtcbiAgICAgICB9XG4gICAgICAgKi9cblxuICB9LFxuICBpbml0RGl2czogZnVuY3Rpb24oKXtcbiAgICB2YXIgbG9nb19ncmFwaGljID0gbWsoXCJkaXZcIik7XG4gICAgbG9nb19ncmFwaGljLmNsYXNzTmFtZSA9IFwibG9nb19ncmFwaGljXCI7XG4gICAgdGhpcy5sb2dvX2dyYXBoaWMgPSBqYm9uZShsb2dvX2dyYXBoaWMpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG1rKFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxvZ29fY29udGFpbmVyXCI7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY29udGFpbmVyID0gamJvbmUoY29udGFpbmVyKTtcblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChsb2dvX2dyYXBoaWMpO1xuXG4gICAgLy8gYWRkIHNvbWUgaW50ZXJuYWwgZGl2cyBmb3Igc2Nyb2xsaW5nIGV0Yy5cbiAgICB0aGlzLiRlbC5hcHBlbmQoY29udGFpbmVyKTtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5kaXZpZGVyKXtcbiAgICAgIHZhciBkaXZpZGVyID0gbWsoXCJkaXZcIik7XG4gICAgICBkaXZpZGVyLmNsYXNzTmFtZSA9IFwibG9nb19kaXZpZGVyXCI7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoZGl2aWRlcik7XG4gICAgfVxuXG4gICAgdGhpcy5kb21fZWxlbWVudCA9IGpib25lKGxvZ29fZ3JhcGhpYyk7XG4gICAgdGhpcy5jYWxsZWRfb24gPSB0aGlzLiRlbDtcblxuICAgIGlmKHRoaXMub3B0aW9ucy54YXhpcyl7XG4gICAgICBheGlzLnJlbmRlcl94X2F4aXNfbGFiZWwuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgaWYodGhpcy5vcHRpb25zLnlheGlzKXtcbiAgICAgIGF4aXMucmVuZGVyX3lfYXhpc19sYWJlbC5jYWxsKHRoaXMpO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5jb250YWluZXJbMF0uc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgfVxuXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHJlbmRlci5jYWxsKHRoaXMpOyBcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjaGFuZ2VDb2xvcnM6IGZ1bmN0aW9uKGNvbG9ycyl7XG4gICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgdmFyIGJVc2VDb2xvck9iamVjdCA9IChjb2xvcnMgIT0gdW5kZWZpbmVkICYmIGNvbG9ycy50eXBlICE9IHVuZGVmaW5lZCk7XG4gICAgaWYoYlVzZUNvbG9yT2JqZWN0KXtcbiAgICAgIHRoaXMuY29sb3JzY2hlbWUgPSBcImR5bmFtaWNcIjtcbiAgICB9XG4gICAgdGhpcy5idWlsZEFscGhhYmV0KCk7XG4gIH0sXG5cbiAgYnVpbGRBbHBoYWJldDogZnVuY3Rpb24oKXtcbiAgICAvKlxuICAgICAgIGlmICh0aGlzLmFscGhhYmV0ID09PSAnYWEnKSB7XG4gICAgICAgdmFyIHByb2JzX2FyciA9IHRoaXMuZGF0YS5wcm9ic19hcnI7XG4gICAgICAgaWYgKHByb2JzX2Fycikge1xuICAgICAgIHZhciBjYyA9IG5ldyBDb25zZW5zdXNDb2xvcnMoKTtcbiAgICAgICB0aGlzLmNtYXAgPSBjYy5jb2xvcl9tYXAocHJvYnNfYXJyKTtcbiAgICAgICB9XG4gICAgICAgfVxuICAgICAgICovXG5cbiAgICAvL2J1aWxkIHRoZSBsZXR0ZXIgY2FudmFzZXNcbiAgICB0aGlzLmxldHRlcnMgPSB7fTtcbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgaWYodGhpcy5jb2xvcnNjaGVtZSA9PSBcImR5bmFtaWNcIil7XG4gICAgICB2YXIgdENvbG9ycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIi5zcGxpdCgnJyk7XG4gICAgICBjb2xvcnMgPSB7fTtcbiAgICAgIHRDb2xvcnMuZm9yRWFjaChmdW5jdGlvbihlKXtcbiAgICAgICAgY29sb3JzW2VdID0gXCJcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBsZXR0ZXIgaW4gY29sb3JzKSB7XG4gICAgICBpZiAoY29sb3JzLmhhc093blByb3BlcnR5KGxldHRlcikpIHtcbiAgICAgICAgdmFyIGxvcHRpb25zID0ge2NvbG9yOiBjb2xvcnNbbGV0dGVyXX07XG4gICAgICAgIHRoaXMubGV0dGVyc1tsZXR0ZXJdID0gbmV3IExldHRlcihsZXR0ZXIsIGxvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlQ29sb3JzY2hlbWU6IGZ1bmN0aW9uIChzY2hlbWUpIHtcbiAgICAvLyB3b3JrIG91dCB0aGUgY3VycmVudCBjb2x1bW4gd2UgYXJlIG9uIHNvIHdlIGNhbiByZXR1cm4gdGhlcmVcbiAgICB2YXIgY29sX3RvdGFsID0gdGhpcy5jdXJyZW50Q29sdW1uKCk7XG5cbiAgICBpZiAoc2NoZW1lKSB7XG4gICAgICBpZiAoc2NoZW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdGhpcy5jb2xvcnNjaGVtZSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sb3JzY2hlbWUgPSAnY29uc2Vuc3VzJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY29sb3JzY2hlbWUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICB0aGlzLmNvbG9yc2NoZW1lID0gJ2NvbnNlbnN1cyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbG9yc2NoZW1lID0gJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSByZW5kZXJlZCBjb3VudGVyIHNvIHRoYXQgZWFjaCBzZWN0aW9uIHdpbGwgcmUtcmVuZGVyXG4gICAgLy8gd2l0aCB0aGUgbmV3IGhlaWdodHNcbiAgICB0aGlzLnJlbmRlcmVkID0gW107XG5cbiAgICAvLyByZS1mbG93IGFuZCByZS1yZW5kZXIgdGhlIGNvbnRlbnRcbiAgICB0aGlzLnNjcm9sbG1lLnJlZmxvdygpO1xuICAgIC8vc2Nyb2xsIG9mZiBieSBvbmUgdG8gZm9yY2UgYSByZW5kZXIgb2YgdGhlIGNhbnZhcy5cbiAgICB0aGlzLnNjcm9sbFRvQ29sdW1uKGNvbF90b3RhbCArIDEpO1xuICAgIC8vc2Nyb2xsIGJhY2sgdG8gdGhlIGxvY2F0aW9uIHdlIHN0YXJ0ZWQgYXQuXG4gICAgdGhpcy5zY3JvbGxUb0NvbHVtbihjb2xfdG90YWwpO1xuICB9LFxuXG4gIHRvZ2dsZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAvLyB3b3JrIG91dCB0aGUgY3VycmVudCBjb2x1bW4gd2UgYXJlIG9uIHNvIHdlIGNhbiByZXR1cm4gdGhlcmVcbiAgICB2YXIgY29sX3RvdGFsID0gdGhpcy5jdXJyZW50Q29sdW1uKCk7XG5cbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgIGlmIChzY2FsZSA9PT0gJ29icycpIHtcbiAgICAgICAgdGhpcy5kYXRhLm1heF9oZWlnaHQgPSB0aGlzLmRhdGEubWF4X2hlaWdodF9vYnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEubWF4X2hlaWdodCA9IHRoaXMuZGF0YS5tYXhfaGVpZ2h0X3RoZW9yeTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9nZ2xlIHRoZSBtYXggaGVpZ2h0XG4gICAgICBpZiAodGhpcy5kYXRhLm1heF9oZWlnaHQgPT09IHRoaXMuZGF0YS5tYXhfaGVpZ2h0X29icykge1xuICAgICAgICB0aGlzLmRhdGEubWF4X2hlaWdodCA9IHRoaXMuZGF0YS5tYXhfaGVpZ2h0X3RoZW9yeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YS5tYXhfaGVpZ2h0ID0gdGhpcy5kYXRhLm1heF9oZWlnaHRfb2JzO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXNldCB0aGUgcmVuZGVyZWQgY291bnRlciBzbyB0aGF0IGVhY2ggc2VjdGlvbiB3aWxsIHJlLXJlbmRlclxuICAgIC8vIHdpdGggdGhlIG5ldyBoZWlnaHRzXG4gICAgdGhpcy5yZW5kZXJlZCA9IFtdO1xuICAgIC8vdXBkYXRlIHRoZSB5LWF4aXNcbiAgICBpZih0aGlzLmxvZ29ZQXhpcyl7XG4gICAgICB0aGlzLmxvZ29ZQXhpcy5yZW1vdmUoKTtcbiAgICAgIC8vdGhpcy5jYWxsZWRfb24uZmluZCgnLmxvZ29feWF4aXMnKS5yZW1vdmUoKTtcbiAgICB9XG4gICAgYXhpcy5yZW5kZXJfeV9heGlzX2xhYmVsLmNhbGwodGhpcyk7XG5cbiAgICAvLyByZS1mbG93IGFuZCByZS1yZW5kZXIgdGhlIGNvbnRlbnRcbiAgICB0aGlzLnNjcm9sbG1lLnJlZmxvdygpO1xuICAgIC8vc2Nyb2xsIG9mZiBieSBvbmUgdG8gZm9yY2UgYSByZW5kZXIgb2YgdGhlIGNhbnZhcy5cbiAgICB0aGlzLnNjcm9sbFRvQ29sdW1uKGNvbF90b3RhbCArIDEpO1xuICAgIC8vc2Nyb2xsIGJhY2sgdG8gdGhlIGxvY2F0aW9uIHdlIHN0YXJ0ZWQgYXQuXG4gICAgdGhpcy5zY3JvbGxUb0NvbHVtbihjb2xfdG90YWwpO1xuICB9LFxuICB0b2dnbGVBbGlNYXA6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAvLyB3b3JrIG91dCB0aGUgY3VycmVudCBjb2x1bW4gd2UgYXJlIG9uIHNvIHdlIGNhbiByZXR1cm4gdGhlcmVcbiAgICB2YXIgY29sX3RvdGFsID0gdGhpcy5jdXJyZW50Q29sdW1uKCk7XG5cbiAgICBpZiAoY29vcmRzKSB7XG4gICAgICBpZiAoY29vcmRzID09PSAnbW9kZWwnKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheV9hbGlfbWFwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheV9hbGlfbWFwID0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9nZ2xlIHRoZSBtYXggaGVpZ2h0XG4gICAgICBpZiAodGhpcy5kaXNwbGF5X2FsaV9tYXAgPT09IDEpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5X2FsaV9tYXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5X2FsaV9tYXAgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBheGlzLnJlbmRlcl94X2F4aXNfbGFiZWwodGhpcyk7XG5cbiAgICAvLyByZXNldCB0aGUgcmVuZGVyZWQgY291bnRlciBzbyB0aGF0IGVhY2ggc2VjdGlvbiB3aWxsIHJlLXJlbmRlclxuICAgIC8vIHdpdGggdGhlIG5ldyBoZWlnaHRzXG4gICAgdGhpcy5yZW5kZXJlZCA9IFtdO1xuXG4gICAgLy8gcmUtZmxvdyBhbmQgcmUtcmVuZGVyIHRoZSBjb250ZW50XG4gICAgdGhpcy5zY3JvbGxtZS5yZWZsb3coKTtcbiAgICAvL3Njcm9sbCBvZmYgYnkgb25lIHRvIGZvcmNlIGEgcmVuZGVyIG9mIHRoZSBjYW52YXMuXG4gICAgdGhpcy5zY3JvbGxUb0NvbHVtbihjb2xfdG90YWwgKyAxKTtcbiAgICAvL3Njcm9sbCBiYWNrIHRvIHRoZSBsb2NhdGlvbiB3ZSBzdGFydGVkIGF0LlxuICAgIHRoaXMuc2Nyb2xsVG9Db2x1bW4oY29sX3RvdGFsKTtcbiAgfSxcblxuICBjdXJyZW50Q29sdW1uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJlZm9yZV9sZWZ0ID0gdGhpcy5zY3JvbGxtZS5zY3JvbGxlci5nZXRWYWx1ZXMoKS5sZWZ0LFxuICAgIGNvbF93aWR0aCA9ICh0aGlzLmNvbHVtbl93aWR0aCAqIHRoaXMuem9vbSksXG4gICAgY29sX2NvdW50ID0gYmVmb3JlX2xlZnQgLyBjb2xfd2lkdGgsXG4gICAgaGFsZl92aXNpYmxlX2NvbHVtbnMgPSAodGhpcy5jb250YWluZXIud2lkdGgoKSAvIGNvbF93aWR0aCkgLyAyLFxuICAgIGNvbF90b3RhbCA9IE1hdGguY2VpbChjb2xfY291bnQgKyBoYWxmX3Zpc2libGVfY29sdW1ucyk7XG4gICAgcmV0dXJuIGNvbF90b3RhbDtcbiAgfSxcblxuICBjaGFuZ2Vab29tOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB6b29tX2xldmVsID0gMC4zLFxuICAgIGV4cGVjdGVkX3dpZHRoID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHpvb21fbGV2ZWwgPSBvcHRpb25zLnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGlzdGFuY2UpIHtcbiAgICAgIHpvb21fbGV2ZWwgPSAocGFyc2VGbG9hdCh0aGlzLnpvb20pIC0gcGFyc2VGbG9hdChvcHRpb25zLmRpc3RhbmNlKSkudG9GaXhlZCgxKTtcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIHpvb21fbGV2ZWwgPSAocGFyc2VGbG9hdCh0aGlzLnpvb20pICsgcGFyc2VGbG9hdChvcHRpb25zLmRpc3RhbmNlKSkudG9GaXhlZCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoem9vbV9sZXZlbCA+IDEpIHtcbiAgICAgIHpvb21fbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAoem9vbV9sZXZlbCA8IDAuMSkge1xuICAgICAgem9vbV9sZXZlbCA9IDAuMTtcbiAgICB9XG5cbiAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byB6b29tIG9yIG5vdFxuICAgIGV4cGVjdGVkX3dpZHRoID0gKHRoaXMubG9nb19ncmFwaGljLndpZHRoKCkgKiB6b29tX2xldmVsKSAvIHRoaXMuem9vbTtcbiAgICBpZiAoZXhwZWN0ZWRfd2lkdGggPiB0aGlzLmNvbnRhaW5lci53aWR0aCgpKSB7XG4gICAgICAvLyBpZiBhIGNlbnRlciBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHVzZSB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIHZpZXdcbiAgICAgIGlmICghb3B0aW9ucy5jb2x1bW4pIHtcbiAgICAgICAgLy93b3JrIG91dCBteSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIHZhciBjb2xfdG90YWwgPSB0aGlzLmN1cnJlbnRDb2x1bW4oKTtcblxuICAgICAgICB0aGlzLnpvb20gPSB6b29tX2xldmVsO1xuICAgICAgICB0aGlzLnJlbmRlcih7em9vbTogdGhpcy56b29tfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsbWUucmVmbG93KCk7XG5cbiAgICAgICAgLy9zY3JvbGwgdG8gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgICAgdGhpcy5zY3JvbGxUb0NvbHVtbihjb2xfdG90YWwpO1xuICAgICAgfSBlbHNlIHsgLy8gY2VudGVyIGFyb3VuZCB0aGUgbW91c2UgY2xpY2sgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuem9vbSA9IHpvb21fbGV2ZWw7XG4gICAgICAgIHRoaXMucmVuZGVyKHt6b29tOiB0aGlzLnpvb219KTtcbiAgICAgICAgdGhpcy5zY3JvbGxtZS5yZWZsb3coKTtcblxuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZGluYXRlc0Zyb21Db2x1bW4ob3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLnNjcm9sbG1lLnNjcm9sbGVyLnNjcm9sbFRvKGNvb3JkcyAtIG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuem9vbTtcblxuICB9LFxuXG4gIGNvbHVtbkZyb21Db29yZGluYXRlczogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgY29sdW1uID0gTWF0aC5jZWlsKHggLyAodGhpcy5jb2x1bW5fd2lkdGggKiB0aGlzLnpvb20pKTtcbiAgICByZXR1cm4gY29sdW1uO1xuICB9LFxuXG4gIGNvb3JkaW5hdGVzRnJvbUNvbHVtbjogZnVuY3Rpb24gKGNvbCkge1xuICAgIHZhciBuZXdfY29sdW1uID0gY29sIC0gMSxcbiAgICB4ID0gKG5ld19jb2x1bW4gICogKHRoaXMuY29sdW1uX3dpZHRoICogdGhpcy56b29tKSkgKyAoKHRoaXMuY29sdW1uX3dpZHRoICogdGhpcy56b29tKSAvIDIpO1xuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIHNjcm9sbFRvQ29sdW1uOiBmdW5jdGlvbiAobnVtLCBhbmltYXRlKSB7XG4gICAgdmFyIGhhbGZfdmlldyA9ICh0aGlzLmxvZ29fY29udGFpbmVyLndpZHRoKCkgLyAyKSxcbiAgICBuZXdfbGVmdCA9IHRoaXMuY29vcmRpbmF0ZXNGcm9tQ29sdW1uKG51bSk7XG4gICAgdGhpcy5zY3JvbGxtZS5zY3JvbGxlci5zY3JvbGxUbyhuZXdfbGVmdCAtIGhhbGZfdmlldywgMCwgYW5pbWF0ZSk7XG4gIH0sXG4gIGNhbGNNYXhIZWlnaHQ6IGZ1bmN0aW9uKGNvbHVtbnMpe1xuICAgIC8vIGxvb3BzIG92ZXIgYWxsIGNvbHVtbnMgYW5kIHJldHVybiB0aGUgbWF4IGhlaWdodCBzZWVuIFxuICAgIHJldHVybiBjb2x1bW5zLnJlZHVjZShmdW5jdGlvbihtLGMpe1xuICAgICAgdmFyIGNvbCA9IDA7XG4gICAgICBmb3IodmFyIGsgaW4gYyl7XG4gICAgICAgIGNvbCArPSBjW2tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbCA+IG0gPyBjb2wgOiBtO1xuICAgIH0sMCk7XG4gIH1cblxuXG59KTtcblxudmFyIG1rID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuIiwidmFyICQgPSByZXF1aXJlKFwiamJvbmVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obG9nbyxvcHRpb25zKXtcbiAgdmFyIGZvcm0gPSAkKCc8Zm9ybSBjbGFzcz1cImxvZ29fZm9ybVwiPjxmaWVsZHNldD48bGFiZWwgZm9yPVwicG9zaXRpb25cIj5Db2x1bW4gbnVtYmVyPC9sYWJlbD4nICtcbiAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwicG9zaXRpb25cIiBjbGFzcz1cImxvZ29fcG9zaXRpb25cIj48L2lucHV0PicgK1xuICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJidXR0b24gbG9nb19jaGFuZ2VcIj5HbzwvYnV0dG9uPjwvZmllbGRzZXQ+JyArXG4gICAgICAgICAgICAgICAnPC9mb3JtPicpO1xuXG4gIHZhciBzZXR0aW5ncyA9ICQoJzxkaXYgY2xhc3M9XCJsb2dvX3NldHRpbmdzXCI+PC9kaXY+Jyk7XG4gIHNldHRpbmdzLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJjbG9zZVwiPng8L3NwYW4+Jyk7XG5cblxuXG4gIC8qIHdlIGRvbid0IHdhbnQgdG8gdG9nZ2xlIGlmIHRoZSBtYXggaGVpZ2h0X29icyBpcyBncmVhdGVyIHRoYW4gbWF4IHRoZW9yZXRpY2FsXG4gICAqIGFzIGxldHRlcnMgd2lsbCBmYWxsIG9mZiB0aGUgdG9wLlxuICAgKi9cbiAgaWYgKGxvZ28uc2NhbGVfaGVpZ2h0X2VuYWJsZWQgJiYgKGxvZ28uZGF0YS5tYXhfaGVpZ2h0X29icyA8IGxvZ28uZGF0YS5tYXhfaGVpZ2h0X3RoZW9yeSkpIHtcbiAgICB2YXIgb2JzX2NoZWNrZWQgPSAnJyxcbiAgICB0aGVvcnlfY2hlY2tlZCA9ICcnLFxuICAgIHRoZW9yeV9oZWxwID0gJycsXG4gICAgb2JzX2hlbHAgPSAnJztcblxuICAgIGlmIChsb2dvLmRhdGEubWF4X2hlaWdodF9vYnMgPT09IGxvZ28uZGF0YS5tYXhfaGVpZ2h0KSB7XG4gICAgICBvYnNfY2hlY2tlZCA9ICdjaGVja2VkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlb3J5X2NoZWNrZWQgPSAnY2hlY2tlZCc7XG4gICAgfVxuICB9XG5cblxuXG4gIHZhciBzY2FsZV9jb250cm9scyA9ICc8ZmllbGRzZXQ+PGxlZ2VuZD5TY2FsZTwvbGVnZW5kPicgK1xuICAgICc8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJzY2FsZVwiIGNsYXNzPVwibG9nb19zY2FsZVwiIHZhbHVlPVwib2JzXCIgJyArIG9ic19jaGVja2VkICtcbiAgICAnLz5NYXhpbXVtIE9ic2VydmVkICcgKyBvYnNfaGVscCArXG4gICAgJzwvbGFiZWw+PC9icj4nICtcbiAgICAnPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwic2NhbGVcIiBjbGFzcz1cImxvZ29fc2NhbGVcIiB2YWx1ZT1cInRoZW9yeVwiICcgKyB0aGVvcnlfY2hlY2tlZCArXG4gICAgJy8+TWF4aW11bSBUaGVvcmV0aWNhbCAnICsgdGhlb3J5X2hlbHAgK1xuICAgICc8L2xhYmVsPicgK1xuICAgICc8L2ZpZWxkc2V0Pic7XG5cbiAgc2V0dGluZ3MuYXBwZW5kKHNjYWxlX2NvbnRyb2xzKTtcblxuICBpZiAobG9nby5kYXRhLmhlaWdodF9jYWxjICE9PSAnc2NvcmUnICYmIGxvZ28uZGF0YS5hbHBoYWJldCA9PT0gJ2FhJyAmJiBsb2dvLmRhdGEucHJvYnNfYXJyKSB7XG5cbiAgICB2YXIgZGVmX2NvbG9yID0gbnVsbCxcbiAgICBjb25fY29sb3IgPSBudWxsLFxuICAgIGRlZl9oZWxwID0gJycsXG4gICAgY29uX2hlbHAgPSAnJztcblxuICAgIGlmIChsb2dvLmNvbG9yc2NoZW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIGRlZl9jb2xvciA9ICdjaGVja2VkJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uX2NvbG9yID0gJ2NoZWNrZWQnO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5oZWxwKSB7XG4gICAgICBkZWZfaGVscCA9ICc8YSBjbGFzcz1cImhlbHBcIiBocmVmPVwiL2hlbHAjY29sb3JzX2RlZmF1bHRcIiB0aXRsZT1cIkVhY2ggbGV0dGVyIHJlY2VpdmVzIGl0cyBvd24gY29sb3IuXCI+JyArXG4gICAgICAgICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBkYXRhLWljb249XCI/XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwicmVhZGVyLXRleHRcIj5oZWxwPC9zcGFuPjwvYT4nO1xuICAgICAgY29uX2hlbHAgPSAnPGEgY2xhc3M9XCJoZWxwXCIgaHJlZj1cIi9oZWxwI2NvbG9yc19jb25zZW5zdXNcIiB0aXRsZT1cIkxldHRlcnMgYXJlIGNvbG9yZWQgYXMgaW4gQ2x1c3RhbHggYW5kIEphbHZpZXcsIHdpdGggY29sb3JzIGRlcGVuZGluZyBvbiBjb21wb3NpdGlvbiBvZiB0aGUgY29sdW1uLlwiPicgK1xuICAgICAgICAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgZGF0YS1pY29uPVwiP1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInJlYWRlci10ZXh0XCI+aGVscDwvc3Bhbj48L2E+JztcbiAgICB9XG5cbiAgICB2YXIgY29sb3JfY29udHJvbHMgPSAnPGZpZWxkc2V0PjxsZWdlbmQ+Q29sb3IgU2NoZW1lPC9sZWdlbmQ+JyArXG4gICAgICAnPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiY29sb3JcIiBjbGFzcz1cImxvZ29fY29sb3JcIiB2YWx1ZT1cImRlZmF1bHRcIiAnICsgZGVmX2NvbG9yICtcbiAgICAgICcvPkRlZmF1bHQgJyArIGRlZl9oZWxwICtcbiAgICAgICc8L2xhYmVsPjwvYnI+JyArXG4gICAgICAnPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiY29sb3JcIiBjbGFzcz1cImxvZ29fY29sb3JcIiB2YWx1ZT1cImNvbnNlbnN1c1wiICcgKyBjb25fY29sb3IgK1xuICAgICAgJy8+Q29uc2Vuc3VzIENvbG9ycyAnICsgY29uX2hlbHAgK1xuICAgICAgJzwvbGFiZWw+JyArXG4gICAgICAnPC9maWVsZHNldD4nO1xuICAgIHNldHRpbmdzLmFwcGVuZChjb2xvcl9jb250cm9scyk7XG4gIH1cblxuXG4gIGlmIChsb2dvLmRhdGEuYWxpX21hcCkge1xuICAgIHZhciBtb2RfY2hlY2tlZCA9IG51bGwsXG4gICAgYWxpX2NoZWNrZWQgPSBudWxsLFxuICAgIG1vZF9oZWxwID0gJycsXG4gICAgYWxpX2hlbHAgPSAnJztcblxuICAgIGlmIChsb2dvLmRpc3BsYXlfYWxpX21hcCA9PT0gMCkge1xuICAgICAgbW9kX2NoZWNrZWQgPSAnY2hlY2tlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaV9jaGVja2VkID0gJ2NoZWNrZWQnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhlbHApIHtcbiAgICAgIG1vZF9oZWxwID0gJzxhIGNsYXNzPVwiaGVscFwiIGhyZWY9XCIvaGVscCNjb29yZHNfbW9kZWxcIiB0aXRsZT1cIlRoZSBjb29yZGluYXRlcyBhbG9uZyB0aGUgdG9wIG9mIHRoZSBwbG90IHNob3cgdGhlIG1vZGVsIHBvc2l0aW9uLlwiPicgK1xuICAgICAgICAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgZGF0YS1pY29uPVwiP1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInJlYWRlci10ZXh0XCI+aGVscDwvc3Bhbj48L2E+JztcbiAgICAgIGFsaV9oZWxwID0gJzxhIGNsYXNzPVwiaGVscFwiIGhyZWY9XCIvaGVscCNjb29yZHNfYWxpXCIgdGl0bGU9XCJUaGUgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHRvcCBvZiB0aGUgcGxvdCBzaG93IHRoZSBjb2x1bW4gaW4gdGhlIGFsaWdubWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIG1vZGVsXCI+JyArXG4gICAgICAgICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBkYXRhLWljb249XCI/XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwicmVhZGVyLXRleHRcIj5oZWxwPC9zcGFuPjwvYT4nO1xuICAgIH1cblxuICAgIHZhciBhbGlfY29udHJvbHMgPSAnPGZpZWxkc2V0PjxsZWdlbmQ+Q29vcmRpbmF0ZXM8L2xlZ2VuZD4nICtcbiAgICAgICc8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJjb29yZHNcIiBjbGFzcz1cImxvZ29fYWxpX21hcFwiIHZhbHVlPVwibW9kZWxcIiAnICsgbW9kX2NoZWNrZWQgK1xuICAgICAgJy8+TW9kZWwgJyArIG1vZF9oZWxwICtcbiAgICAgICc8L2xhYmVsPjwvYnI+JyArXG4gICAgICAnPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiY29vcmRzXCIgY2xhc3M9XCJsb2dvX2FsaV9tYXBcIiB2YWx1ZT1cImFsaWdubWVudFwiICcgKyBhbGlfY2hlY2tlZCArXG4gICAgICAnLz5BbGlnbm1lbnQgJyArIGFsaV9oZWxwICtcbiAgICAgICc8L2xhYmVsPicgK1xuICAgICAgJzwvZmllbGRzZXQ+JztcbiAgICBzZXR0aW5ncy5hcHBlbmQoYWxpX2NvbnRyb2xzKTtcbiAgfVxuXG5cbiAgdmFyIGNvbnRyb2xzID0gJCgnPGRpdiBjbGFzcz1cImxvZ29fY29udHJvbHNcIj48L2Rpdj4nKTtcbiAgaWYgKGxvZ28uem9vbV9lbmFibGVkKSB7XG4gICAgY29udHJvbHMuYXBwZW5kKCc8YnV0dG9uIGNsYXNzPVwibG9nb196b29tb3V0IGJ1dHRvblwiPi08L2J1dHRvbj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJsb2dvX3pvb21pbiBidXR0b25cIj4rPC9idXR0b24+Jyk7XG4gIH1cblxuICBpZiAoc2V0dGluZ3MuY2hpbGRyZW4oKS5sZW5ndGggPiAwKSB7XG4gICAgY29udHJvbHMuYXBwZW5kKCc8YnV0dG9uIGNsYXNzPVwibG9nb19zZXR0aW5nc19zd2l0Y2ggYnV0dG9uXCI+U2V0dGluZ3M8L2J1dHRvbj4nKTtcbiAgICBjb250cm9scy5hcHBlbmQoc2V0dGluZ3MpO1xuICB9XG5cbiAgZm9ybS5hcHBlbmQoY29udHJvbHMpO1xuXG4gIHJldHVybiBmb3JtO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBMZXR0ZXIobGV0dGVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnZhbHVlID0gbGV0dGVyO1xuICB0aGlzLndpZHRoID0gcGFyc2VJbnQob3B0aW9ucy53aWR0aCwgMTApIHx8IDEwMDtcblxuICAvL1cgaXMgMzAlIHdpZGVyIHRoYW4gdGhlIG90aGVyIGxldHRlcnMsIHNvIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vaXQgZ2V0cyBtb2RpZmllZCBhY2NvcmRpbmdseS5cbiAgaWYgKHRoaXMudmFsdWUgPT09ICdXJykge1xuICAgIHRoaXMud2lkdGggKz0gKHRoaXMud2lkdGggKiAzMCkgLyAxMDA7XG4gIH1cblxuICB0aGlzLmhlaWdodCA9IHBhcnNlSW50KG9wdGlvbnMuaGVpZ2h0LCAxMCkgfHwgMTAwO1xuXG4gIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgLy8gaWYgdGhlIGhlaWdodCBhbmQgd2lkdGggYXJlIGNoYW5nZWQgZnJvbSB0aGUgZGVmYXVsdCwgdGhlblxuICAvLyB0aGlzIHdpbGwgYWxzbyBuZWVkIHRvIGJlIGNoYW5nZWQgYXMgaXQgY2FudCBiZSBjYWxjdWxhdGVkXG4gIC8vIGR5bmFtaWNhbGx5LlxuICB0aGlzLmZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMzg7XG5cbiAgdGhpcy5zY2FsZWQgPSBmdW5jdGlvbiAoKSB7IH07XG5cbiAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKGV4dF9jdHgsIHRhcmdldF9oZWlnaHQsIHRhcmdldF93aWR0aCwgeCwgeSwgY29sb3IpIHtcbiAgICB2YXIgaF9yYXRpbyA9IHRhcmdldF9oZWlnaHQgLyB0aGlzLmhlaWdodCxcbiAgICB3X3JhdGlvID0gdGFyZ2V0X3dpZHRoIC8gdGhpcy53aWR0aCxcbiAgICBwcmV2X2ZvbnQgPSBleHRfY3R4LmZvbnQ7XG4gICAgZXh0X2N0eC50cmFuc2Zvcm0od19yYXRpbywgMCwgMCwgaF9yYXRpbywgeCwgeSk7XG4gICAgZXh0X2N0eC5maWxsU3R5bGUgPSBjb2xvciB8fCB0aGlzLmNvbG9yO1xuICAgIGV4dF9jdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBleHRfY3R4LmZvbnQgPSBcImJvbGQgXCIgKyB0aGlzLmZvbnRTaXplICsgXCJweCBBcmlhbFwiO1xuXG4gICAgZXh0X2N0eC5maWxsVGV4dCh0aGlzLnZhbHVlLCAwLCAwKTtcbiAgICAvL3Jlc3RvcmUgdGhlIGNhbnZhcyBzZXR0aW5nc1xuICAgIGV4dF9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGV4dF9jdHguZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuICAgIGV4dF9jdHguZm9udCA9IHByZXZfZm9udDtcbiAgfTtcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3X2JvcmRlcihjb250ZXh0LCB5LCB3aWR0aCkge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0Lm1vdmVUbygwLCB5KTtcbiAgY29udGV4dC5saW5lVG8od2lkdGgsIHkpO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiM5OTk5OTlcIjtcbiAgY29udGV4dC5zdHJva2UoKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhd19jb2x1bW5fbnVtYmVyKGNvbnRleHQsIHgsIHksIGNvbF93aWR0aCwgY29sX251bSwgZm9udHNpemUsIHJpZ2h0KSB7XG4gIGNvbnRleHQuZm9udCA9IGZvbnRzaXplICsgXCJweCBBcmlhbFwiO1xuICBjb250ZXh0LnRleHRBbGlnbiA9IHJpZ2h0ID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiM2NjY2NjZcIjtcbiAgY29udGV4dC5maWxsVGV4dChjb2xfbnVtLCB4ICsgKGNvbF93aWR0aCAvIDIpLCB5KTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhd190aWNrcyhjb250ZXh0LCB4LCB5LCBoZWlnaHQsIGNvbG9yKSB7XG4gIGNvbG9yID0gY29sb3IgfHwgJyM5OTk5OTknO1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSArIGhlaWdodCk7XG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjb250ZXh0LnN0cm9rZSgpO1xufVxuIiwidmFyIHJlbmRlcldpdGhUZXh0ID0gcmVxdWlyZShcIi4vcmVuZGVyX3dpdGhfdGV4dC5qc1wiKTtcbnZhciByZW5kZXJXaXRoUmVjdCA9IHJlcXVpcmUoXCIuL3JlbmRlcl93aXRoX3JlY3RzLmpzXCIpO1xudmFyIGpib25lID0gcmVxdWlyZShcImpib25lXCIpO1xuXG4vLyB0aGUgbWFpbiByZW5kZXIgZnVuY3Rpb24gdGhhdCBkcmF3cyB0aGUgbG9nbyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3B0aW9ucyAgICA9IG9wdGlvbnMgfHwge307XG4gIHZhciB6b29tICAgPSBvcHRpb25zLnpvb20gfHwgdGhpcy56b29tLFxuICB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCAxLFxuICBzY2FsZWQgPSBvcHRpb25zLnNjYWxlZCB8fCBudWxsO1xuICB2YXIgcGFyZW50X3dpZHRoID0gdGhpcy5kb21fZWxlbWVudC5wYXJlbnQoKS5hdHRyKCd3aWR0aCcpLFxuICBtYXhfY2FudmFzX3dpZHRoID0gMSxcbiAgZW5kID0gbnVsbCxcbiAgc3RhcnQgPSBudWxsLFxuICBpID0gMDtcblxuICAvKlxuICBpZiAodGFyZ2V0ID09PSB0aGlzLnByZXZpb3VzX3RhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICAqL1xuXG4gIHRoaXMucHJldmlvdXNfdGFyZ2V0ID0gdGFyZ2V0O1xuXG5cbiAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgfVxuICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kO1xuICB9XG5cbiAgaWYgKHpvb20gPD0gMC4xKSB7XG4gICAgem9vbSA9IDAuMTtcbiAgfSBlbHNlIGlmICh6b29tID49IDEpIHtcbiAgICB6b29tID0gMTtcbiAgfVxuXG4gIHRoaXMuem9vbSA9IHpvb207XG5cbiAgZW5kID0gdGhpcy5lbmQgfHwgdGhpcy5kYXRhLmhlaWdodEFyci5sZW5ndGg7XG4gIHN0YXJ0ID0gdGhpcy5zdGFydCB8fCAxO1xuICBlbmQgICAgID0gKGVuZCA+IHRoaXMuZGF0YS5oZWlnaHRBcnIubGVuZ3RoKSA/IHRoaXMuZGF0YS5oZWlnaHRBcnIubGVuZ3RoIDogZW5kO1xuICBlbmQgICAgID0gKGVuZCA8IHN0YXJ0KSA/IHN0YXJ0IDogZW5kO1xuXG4gIHN0YXJ0ICAgICA9IChzdGFydCA+IGVuZCkgPyBlbmQgOiBzdGFydDtcbiAgc3RhcnQgICAgID0gKHN0YXJ0ID4gMSkgPyBzdGFydCA6IDE7XG5cbiAgdGhpcy55ID0gdGhpcy5oZWlnaHQgLSAyMDtcbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBsb2dvIHdpbGwgZml0IG9uIHRoZSBzY3JlZW4gYXQgZnVsbCB6b29tLlxuICB0aGlzLm1heF93aWR0aCA9IHRoaXMuY29sdW1uX3dpZHRoICogKChlbmQgLSBzdGFydCkgKyAxKTtcbiAgLy8gSWYgaXQgZml0cyB0aGVuIHpvb20gb3V0IGFuZCBkaXNhYmxlIHpvb21pbmcuXG4gIGlmIChwYXJlbnRfd2lkdGggPiB0aGlzLm1heF93aWR0aCkge1xuICAgIHpvb20gPSAxO1xuICAgIHRoaXMuem9vbV9lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgdGhpcy56b29tID0gem9vbTtcblxuICB0aGlzLnpvb21lZF9jb2x1bW4gPSB0aGlzLmNvbHVtbl93aWR0aCAqIHpvb207XG4gIHRoaXMudG90YWxfd2lkdGggPSB0aGlzLnpvb21lZF9jb2x1bW4gKiAoKGVuZCAtIHN0YXJ0KSArIDEpO1xuXG4gIC8vIElmIHpvb20gaXMgbm90IG1heGVkIGFuZCB3ZSBzdGlsbCBhcmVuJ3QgZmlsbGluZyB0aGUgd2luZG93XG4gIC8vIHRoZW4gcmFtcCB1cCB0aGUgem9vbSBsZXZlbCB1bnRpbCBpdCBmaXRzLCB0aGVuIGRpc2FibGUgem9vbWluZy5cbiAgLy8gVGhlbiB3ZSBnZXQgYSBkZWNlbnQgbG9nbyB3aXRoIG91dCBuZWVkaW5nIHRvIHpvb20gaW4gb3Igb3V0LlxuICBpZiAoem9vbSA8IDEpIHtcbiAgICB3aGlsZSAodGhpcy50b3RhbF93aWR0aCA8IHBhcmVudF93aWR0aCkge1xuICAgICAgdGhpcy56b29tICs9IDAuMTtcbiAgICAgIHRoaXMuem9vbWVkX2NvbHVtbiA9IHRoaXMuY29sdW1uX3dpZHRoICogdGhpcy56b29tO1xuICAgICAgdGhpcy50b3RhbF93aWR0aCA9IHRoaXMuem9vbWVkX2NvbHVtbiAqICgoZW5kIC0gc3RhcnQpICsgMSk7XG4gICAgICB0aGlzLnpvb21fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHpvb20gPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGFyZ2V0ID4gdGhpcy50b3RhbF93aWR0aCkge1xuICAgIHRhcmdldCA9IHRoaXMudG90YWxfd2lkdGg7XG4gIH1cbiAgdGhpcy5kb21fZWxlbWVudC5hdHRyKHsnd2lkdGgnOiB0aGlzLnRvdGFsX3dpZHRoICsgJ3B4J30pLmNzcyh7d2lkdGg6IHRoaXMudG90YWxfd2lkdGggKyAncHgnfSk7XG5cbiAgdGhpcy5jYW52YXNfd2lkdGggPSB0aGlzLnRvdGFsX3dpZHRoO1xuICB2YXIgY2FudmFzX2NvdW50ID0gTWF0aC5jZWlsKHRoaXMudG90YWxfd2lkdGggLyB0aGlzLmNhbnZhc193aWR0aCk7XG4gIHRoaXMuY29sdW1uc19wZXJfY2FudmFzID0gTWF0aC5jZWlsKHRoaXMuY2FudmFzX3dpZHRoIC8gdGhpcy56b29tZWRfY29sdW1uKTtcblxuXG4gIGlmICh0aGlzLnByZXZpb3VzX3pvb20gIT09IHRoaXMuem9vbSkge1xuICAgIHRoaXMuZG9tX2VsZW1lbnQuZmluZCgnY2FudmFzJykucmVtb3ZlKCk7XG4gICAgdGhpcy5wcmV2aW91c196b29tID0gdGhpcy56b29tO1xuICAgIHRoaXMucmVuZGVyZWQgPSBbXTtcbiAgfVxuXG4gIHRoaXMuY2FudmFzZXMgPSBbXTtcbiAgdGhpcy5jb250ZXh0cyA9IFtdO1xuXG5cbiAgZm9yIChpID0gMDsgaSA8IGNhbnZhc19jb3VudDsgaSsrKSB7XG5cbiAgICB2YXIgc3BsaXRfc3RhcnQgPSAodGhpcy5jb2x1bW5zX3Blcl9jYW52YXMgKiBpKSArIHN0YXJ0LFxuICAgIHNwbGl0X2VuZCAgID0gc3BsaXRfc3RhcnQgKyB0aGlzLmNvbHVtbnNfcGVyX2NhbnZhcyAtIDE7XG4gICAgaWYgKHNwbGl0X2VuZCA+IGVuZCkge1xuICAgICAgc3BsaXRfZW5kID0gZW5kO1xuICAgIH1cblxuICAgIHZhciBhZGp1c3RlZF93aWR0aCA9ICgoc3BsaXRfZW5kIC0gc3BsaXRfc3RhcnQpICsgMSkgKiB0aGlzLnpvb21lZF9jb2x1bW47XG5cbiAgICBpZiAoYWRqdXN0ZWRfd2lkdGggPiBtYXhfY2FudmFzX3dpZHRoKSB7XG4gICAgICBtYXhfY2FudmFzX3dpZHRoID0gYWRqdXN0ZWRfd2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZfc3RhcnQgPSBtYXhfY2FudmFzX3dpZHRoICogaSxcbiAgICBjYW52X2VuZCA9IGNhbnZfc3RhcnQgKyBhZGp1c3RlZF93aWR0aDtcblxuICAgIGlmICh0YXJnZXQgPCBjYW52X2VuZCArIChjYW52X2VuZCAvIDIpICYmIHRhcmdldCA+IGNhbnZfc3RhcnQgLSAoY2Fudl9zdGFydCAvIDIpKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGFyZW4ndCByZWRyYXdpbmcgdGhlIGNhbnZhcyBhbmQgaWYgbm90LCB0aGVuIGF0dGFjaCBpdCBhbmQgZHJhdy5cbiAgICAgIC8vaWYgKHRoaXMucmVuZGVyZWRbaV0gIT09IDEpIHtcblxuICAgICAgICB0aGlzLmNhbnZhc2VzW2ldID0gYXR0YWNoX2NhbnZhcyh0aGlzLmRvbV9lbGVtZW50LCB0aGlzLmhlaWdodCwgYWRqdXN0ZWRfd2lkdGgsIGksIG1heF9jYW52YXNfd2lkdGgpO1xuICAgICAgICB0aGlzLmNvbnRleHRzW2ldID0gdGhpcy5jYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmNvbnRleHRzW2ldLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tpXS5jbGVhclJlY3QoMCwgMCwgYWRqdXN0ZWRfd2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tpXS5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tpXS5maWxsUmVjdCgwLCAwLCBjYW52X2VuZCwgdGhpcy5oZWlnaHQpO1xuXG5cbiAgICAgICAgaWYgKHRoaXMuem9vbWVkX2NvbHVtbiA+IDEyKSB7XG4gICAgICAgICAgdmFyIGZvbnRzaXplID0gcGFyc2VJbnQoMTAgKiB6b29tLCAxMCk7XG4gICAgICAgICAgZm9udHNpemUgPSAoZm9udHNpemUgPiAxMCkgPyAxMCA6IGZvbnRzaXplO1xuICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICByZW5kZXJXaXRoUmVjdC5jYWxsKHRoaXMsc3BsaXRfc3RhcnQsIHNwbGl0X2VuZCwgaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbmRlcldpdGhUZXh0LmNhbGwodGhpcyxzcGxpdF9zdGFydCwgc3BsaXRfZW5kLCBpLCBmb250c2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyV2l0aFJlY3QuY2FsbCh0aGlzLHNwbGl0X3N0YXJ0LCBzcGxpdF9lbmQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5yZW5kZXJlZFtpXSA9IDE7XG4gICAgICAvL31cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRoZSBzY3JvbGxlciBvYmplY3QgaGFzIGJlZW4gaW5pdGlhbGlzZWQgYW5kIGlmIG5vdCB0aGVuIGRvIHNvLlxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgYXMgb3Bwb3NlZCB0byBhdCBvYmplY3QgY3JlYXRpb24sIGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAvLyBtYWtlIHN1cmUgdGhlIGxvZ28gaGFzIGJlZW4gcmVuZGVyZWQgYW5kIHRoZSB3aWR0aCBpcyBjb3JyZWN0LCBvdGhlcndpc2VcbiAgLy8gd2UgZ2V0IGEgd2VpcmQgaW5pdGlhbCBzdGF0ZSB3aGVyZSB0aGUgY2FudmFzIHdpbGwgYm91bmNlIGJhY2sgdG8gdGhlXG4gIC8vIGJlZ2lubmluZyB0aGUgZmlyc3QgdGltZSBpdCBpcyBzY3JvbGxlZCwgYmVjYXVzZSBpdCB0aGlua3MgaXQgaGFzIGFcbiAgLy8gd2lkdGggb2YgMC5cbiAgaWYgKCF0aGlzLnNjcm9sbG1lICYmIHRoaXMub3B0aW9ucy5zY3JvbGxlcikge1xuICAgIHRoaXMuc2Nyb2xsbWUgPSBuZXcgRWFzeVNjcm9sbGVyKHRoaXMuZG9tX2VsZW1lbnRbMF0sIHtcbiAgICAgIHNjcm9sbGluZ1g6IDEsXG4gICAgICBzY3JvbGxpbmdZOiAwLFxuICAgICAgZXZlbnRUYXJnZXQ6IHRoaXMuY2FsbGVkX29uXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGFyZ2V0ICE9PSAxKSB7XG4gICAgdGhpcy5zY3JvbGxtZS5yZWZsb3coKTtcbiAgfVxuICByZXR1cm47XG59O1xuXG5cbmZ1bmN0aW9uIGF0dGFjaF9jYW52YXMoRE9NaWQsIGhlaWdodCwgd2lkdGgsIGlkLCBjYW52X3dpZHRoKSB7XG4gIHZhciBjYW52YXMgPSBqYm9uZShET01pZCkuZmluZCgnI2NhbnZfJyArIGlkKTtcblxuICBpZiAoIWNhbnZhcy5sZW5ndGgpIHtcbiAgICBqYm9uZShET01pZCkuYXBwZW5kKCc8Y2FudmFzIGNsYXNzPVwiY2FudmFzX2xvZ29cIiBpZD1cImNhbnZfJyArIGlkICsgJ1wiICBoZWlnaHQ9XCInICsgaGVpZ2h0ICsgJ1wiIHdpZHRoPVwiJyArIHdpZHRoICsgJ1wiIHN0eWxlPVwibGVmdDonICsgY2Fudl93aWR0aCAqIGlkICsgJ3B4XCI+PC9jYW52YXM+Jyk7XG4gICAgY2FudmFzID0gamJvbmUoRE9NaWQpLmZpbmQoJyNjYW52XycgKyBpZCk7XG4gIH1cblxuICBqYm9uZShjYW52YXMpLmF0dHIoJ3dpZHRoJywgd2lkdGgpLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgcmV0dXJuIGNhbnZhc1swXTtcbn1cbiIsInZhciBkcmF3X2JvcmRlciA9IHJlcXVpcmUoXCIuL2RyYXcvYm9yZGVyLmpzXCIpO1xudmFyIGRyYXdfdGlja3MgPSByZXF1aXJlKFwiLi9kcmF3L3RpY2tzLmpzXCIpO1xudmFyIGRyYXdfY29sdW1uX251bWJlciA9IHJlcXVpcmUoXCIuL2RyYXcvY29sdW1uX251bWJlci5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dF9udW0sIGJvcmRlcnMpIHtcbiAgdmFyIHggPSAwLFxuICBjb2x1bW5fbnVtID0gc3RhcnQsXG4gIGNvbHVtbl9sYWJlbCA9IG51bGwsXG4gIGkgPSAwLFxuICB0b3BfaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLm1heF9oZWlnaHQpLFxuICBib3R0b21faGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLm1pbl9oZWlnaHRfb2JzKSxcbiAgdG90YWxfaGVpZ2h0ID0gdG9wX2hlaWdodCArIGJvdHRvbV9oZWlnaHQsXG4gIHRvcF9wZXJjZW50YWdlICAgID0gTWF0aC5yb3VuZCgoTWF0aC5hYnModGhpcy5kYXRhLm1heF9oZWlnaHQpICogMTAwKSAvIHRvdGFsX2hlaWdodCksXG4gIC8vY29udmVydCAlIHRvIHBpeGVsc1xuICB0b3BfcGl4X2hlaWdodCA9IE1hdGgucm91bmQoKHRoaXMuaW5mb19jb250ZW50X2hlaWdodCAqIHRvcF9wZXJjZW50YWdlKSAvIDEwMCksXG4gIGJvdHRvbV9waXhfaGVpZ2h0ID0gdGhpcy5pbmZvX2NvbnRlbnRfaGVpZ2h0IC0gdG9wX3BpeF9oZWlnaHQsXG4gIG1vZCA9IDEwO1xuXG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBpZiAodGhpcy5kYXRhLm1tbGluZSAmJiB0aGlzLmRhdGEubW1saW5lW2kgLSAxXSA9PT0gMSkge1xuICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uZmlsbFN0eWxlID0gJyNjY2NjY2MnO1xuICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uZmlsbFJlY3QoeCwgMTAsIHRoaXMuem9vbWVkX2NvbHVtbiwgdGhpcy5oZWlnaHQgLSA0MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmRhdGEuaGVpZ2h0QXJyW2kgLSAxXSxcbiAgICAgIHByZXZpb3VzX2hlaWdodCA9IDAsXG4gICAgICBwcmV2aW91c19uZWdfaGVpZ2h0ID0gdG9wX3BpeF9oZWlnaHQsXG4gICAgICBsZXR0ZXJzID0gY29sdW1uLmxlbmd0aCxcbiAgICAgIGogPSAwO1xuICAgICAgZm9yKHZhciBqIGluIGNvbHVtbil7XG4gICAgICAgIHZhbHVlcyA9IFtqLGNvbHVtbltqXV07XG4gICAgICAgIGlmICh2YWx1ZXNbMV0gPiAwLjAxKSB7XG4gICAgICAgICAgdmFyIGxldHRlcl9oZWlnaHQgPSBwYXJzZUZsb2F0KHZhbHVlc1sxXSkgLyB0aGlzLmRhdGEubWF4X2hlaWdodCxcbiAgICAgICAgICB4X3BvcyA9IHgsXG4gICAgICAgICAgZ2x5cGhfaGVpZ2h0ID0gKHRoaXMuaW5mb19jb250ZW50X2hlaWdodCAtIDIpICogbGV0dGVyX2hlaWdodCxcbiAgICAgICAgICB5X3BvcyA9ICh0aGlzLmluZm9fY29udGVudF9oZWlnaHQgLSAyKSAtIHByZXZpb3VzX2hlaWdodCAtIGdseXBoX2hlaWdodCxcbiAgICAgICAgICBjb2xvciA9IG51bGw7XG5cblxuICAgICAgICAgIGlmKHRoaXMuY29sb3JzY2hlbWUgPT09ICdkeW5hbWljJyl7XG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlc1swXSwge3BvczogaSAtIDF9IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmKHRoaXMuY29sb3JzY2hlbWUgPT09ICdjb25zZW5zdXMnKSB7XG4gICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jbWFwW2kgLSAxXVt2YWx1ZXNbMF1dIHx8IFwiIzdhN2E3YVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9yc1t2YWx1ZXNbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3JkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXS5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uc3Ryb2tlUmVjdCh4X3BvcywgeV9wb3MsIHRoaXMuem9vbWVkX2NvbHVtbiwgZ2x5cGhfaGVpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXS5maWxsUmVjdCh4X3BvcywgeV9wb3MsIHRoaXMuem9vbWVkX2NvbHVtbiwgZ2x5cGhfaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2aW91c19oZWlnaHQgPSBwcmV2aW91c19oZWlnaHQgKyBnbHlwaF9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICh0aGlzLnpvb20gPCAwLjIpIHtcbiAgICAgIG1vZCA9IDIwO1xuICAgIH0gZWxzZSBpZiAodGhpcy56b29tIDwgMC4zKSB7XG4gICAgICBtb2QgPSAxMDtcbiAgICB9XG5cbiAgICBpZih0aGlzLm9wdGlvbnMucG9zaXRpb25NYXJrZXIpe1xuICAgICAgaWYgKGkgJSBtb2QgPT09IDApIHtcbiAgICAgICAgLy8gZHJhdyBjb2x1bW4gZGl2aWRlcnNcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dfcHJvYnMpe1xuICAgICAgICAgIGRyYXdfdGlja3ModGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHggKyB0aGlzLnpvb21lZF9jb2x1bW4sIHRoaXMuaGVpZ2h0IC0gMzAsIHBhcnNlRmxvYXQodGhpcy5oZWlnaHQpLCAnI2RkZGRkZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRyYXcgdG9wIHRpY2tzXG4gICAgICAgIGRyYXdfdGlja3ModGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHggKyB0aGlzLnpvb21lZF9jb2x1bW4sIDAsIDUpO1xuXG4gICAgICAgIC8vIGlmIGFsaV9jb29yZGluYXRlcyBleGlzdCBhbmQgdG9nZ2xlIGlzIHNldCB0aGVuIGRpc3BsYXkgdGhlXG4gICAgICAgIC8vIGFsaWdubWVudCBjb29yZGluYXRlcyBhbmQgbm90IHRoZSBtb2RlbCBjb29yZGluYXRlcy5cbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheV9hbGlfbWFwKSB7XG4gICAgICAgICAgY29sdW1uX2xhYmVsID0gdGhpcy5kYXRhLmFsaV9tYXBbaSAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHVtbl9sYWJlbCA9IGNvbHVtbl9udW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhdyBjb2x1bW4gbnVtYmVyc1xuICAgICAgICBkcmF3X2NvbHVtbl9udW1iZXIodGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHggLSAyLCAgMTAsIHRoaXMuem9vbWVkX2NvbHVtbiwgY29sdW1uX2xhYmVsLCAxMCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIGRyYXcgaW5zZXJ0IHByb2JhYmlsaXRpZXMvbGVuZ3Roc1xuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93X3Byb2JzKXtcbiAgICAgIGRyYXdfc21hbGxfaW5zZXJ0KFxuICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSxcbiAgICAgICAgeCxcbiAgICAgICAgdGhpcy5oZWlnaHQgLSA0MixcbiAgICAgICAgdGhpcy56b29tZWRfY29sdW1uLFxuICAgICAgICB0aGlzLmRhdGEuaW5zZXJ0X3Byb2JzW2kgLSAxXSxcbiAgICAgICAgdGhpcy5kYXRhLmluc2VydF9sZW5ndGhzW2kgLSAxXSxcbiAgICAgICAgdGhpcy5kYXRhLmRlbGV0ZV9wcm9ic1tpIC0gMV0sXG4gICAgICAgIHRoaXMuc2hvd19pbnNlcnRzXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93X3Byb2JzKXtcbiAgICAgIC8vIGRyYXcgb3RoZXIgZGl2aWRlcnNcbiAgICAgIGlmICh0aGlzLnNob3dfaW5zZXJ0cykge1xuICAgICAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgdGhpcy5oZWlnaHQgLSA0NSwgdGhpcy50b3RhbF93aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgdGhpcy5oZWlnaHQgLSAxNSwgdGhpcy50b3RhbF93aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5vcHRpb25zLmJvcmRlcil7XG4gICAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgMCwgdGhpcy50b3RhbF93aWR0aCk7XG4gICAgfVxuXG4gICAgeCArPSB0aGlzLnpvb21lZF9jb2x1bW47XG4gICAgY29sdW1uX251bSsrO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gZHJhd19zbWFsbF9pbnNlcnQoY29udGV4dCwgeCwgeSwgY29sX3dpZHRoLCBpbl9vZGRzLCBpbl9sZW5ndGgsIGRlbF9vZGRzLCBzaG93X2luc2VydHMpIHtcbiAgdmFyIGZpbGwgPSBcIiNmZmZmZmZcIjtcbiAgaWYgKHNob3dfaW5zZXJ0cykge1xuICAgIGlmIChpbl9vZGRzID4gMC4xKSB7XG4gICAgICBmaWxsID0gJyNkNzMwMWYnO1xuICAgIH0gZWxzZSBpZiAoaW5fb2RkcyA+IDAuMDUpIHtcbiAgICAgIGZpbGwgPSAnI2ZjOGQ1OSc7XG4gICAgfSBlbHNlIGlmIChpbl9vZGRzID4gMC4wMykge1xuICAgICAgZmlsbCA9ICcjZmRjYzhhJztcbiAgICB9XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSArIDE1LCBjb2xfd2lkdGgsIDEwKTtcblxuICAgIGZpbGwgPSBcIiNmZmZmZmZcIjtcbiAgICAvLyBkcmF3IGluc2VydCBsZW5ndGhcbiAgICBpZiAoaW5fbGVuZ3RoID4gOSkge1xuICAgICAgZmlsbCA9ICcjZDczMDFmJztcbiAgICB9IGVsc2UgaWYgKGluX2xlbmd0aCA+IDcpIHtcbiAgICAgIGZpbGwgPSAnI2ZjOGQ1OSc7XG4gICAgfSBlbHNlIGlmIChpbl9sZW5ndGggPiA0KSB7XG4gICAgICBmaWxsID0gJyNmZGNjOGEnO1xuICAgIH1cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgY29udGV4dC5maWxsUmVjdCh4LCB5ICsgMzAsIGNvbF93aWR0aCwgMTApO1xuICB9IGVsc2Uge1xuICAgIHkgID0geSArIDMwO1xuICB9XG5cbiAgZmlsbCA9IFwiI2ZmZmZmZlwiO1xuICAvLyBkcmF3IGRlbGV0ZSBvZGRzXG4gIGlmIChkZWxfb2RkcyA8IDAuNzUpIHtcbiAgICBmaWxsID0gJyMyMTcxYjUnO1xuICB9IGVsc2UgaWYgKGRlbF9vZGRzIDwgMC44NSkge1xuICAgIGZpbGwgPSAnIzZiYWVkNic7XG4gIH0gZWxzZSBpZiAoZGVsX29kZHMgPCAwLjk1KSB7XG4gICAgZmlsbCA9ICcjYmRkN2U3JztcbiAgfVxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGw7XG4gIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgY29sX3dpZHRoLCAxMCk7XG59XG5cblxuIiwidmFyIGRyYXdfYm9yZGVyID0gcmVxdWlyZShcIi4vZHJhdy9ib3JkZXIuanNcIik7XG52YXIgZHJhd190aWNrcyA9IHJlcXVpcmUoXCIuL2RyYXcvdGlja3MuanNcIik7XG52YXIgZHJhd19jb2x1bW5fbnVtYmVyID0gcmVxdWlyZShcIi4vZHJhdy9jb2x1bW5fbnVtYmVyLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0X251bSwgZm9udHNpemUpIHtcbiAgdmFyIHggPSAwLFxuICBjb2x1bW5fbnVtID0gc3RhcnQsXG4gIGNvbHVtbl9sYWJlbCA9IG51bGwsXG4gIGkgPSAwLFxuICB0b3BfaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLm1heF9oZWlnaHQpLFxuICBib3R0b21faGVpZ2h0ID0gKGlzTmFOKHRoaXMuZGF0YS5taW5faGVpZ2h0X29icykpID8gMCA6IHBhcnNlSW50KHRoaXMuZGF0YS5taW5faGVpZ2h0X29icywgMTApLFxuICB0b3RhbF9oZWlnaHQgPSB0b3BfaGVpZ2h0ICsgTWF0aC5hYnMoYm90dG9tX2hlaWdodCksXG4gIHRvcF9wZXJjZW50YWdlICAgID0gTWF0aC5yb3VuZCgoTWF0aC5hYnModGhpcy5kYXRhLm1heF9oZWlnaHQpICogMTAwKSAvIHRvdGFsX2hlaWdodCksXG4gIC8vY29udmVydCAlIHRvIHBpeGVsc1xuICB0b3BfcGl4X2hlaWdodCA9IE1hdGgucm91bmQoKHRoaXMuaW5mb19jb250ZW50X2hlaWdodCAqIHRvcF9wZXJjZW50YWdlKSAvIDEwMCksXG4gIGJvdHRvbV9waXhfaGVpZ2h0ID0gdGhpcy5pbmZvX2NvbnRlbnRfaGVpZ2h0IC0gdG9wX3BpeF9oZWlnaHQsXG4gIC8vIHRoaXMgaXMgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIDI1NnB4IGhpZ2ggbGV0dGVycyBpbnRvIHRoZSBjb3JyZWN0IHNpemVcbiAgLy8gd2hlbiBkaXNwbGF5aW5nIG5lZ2F0aXZlIHZhbHVlcywgc28gdGhhdCB0aGV5IGZpdCBhYm92ZSB0aGUgMCBsaW5lLlxuICB0b3BfcGl4X2NvbnZlcnNpb24gPSB0b3BfcGl4X2hlaWdodCAvIHRoaXMuaW5mb19jb250ZW50X2hlaWdodCxcbiAgYm90dG9tX3BpeF9jb252ZXJzaW9uID0gYm90dG9tX3BpeF9oZWlnaHQgLyB0aGlzLmluZm9fY29udGVudF9oZWlnaHQ7XG5cbiAgLy8gYWRkIDMgZXh0cmEgY29sdW1ucyBzbyB0aGF0IG51bWJlcnMgZG9uJ3QgZ2V0IGNsaXBwZWQgYXQgdGhlIGVuZCBvZiBhIGNhbnZhc1xuICAvLyB0aGF0IGVuZHMgYmVmb3JlIGEgbGFyZ2UgY29sdW1uLiBERjAwMDA4MzAgd2FzIHN1ZmZlcmluZyBhdCB6b29tIGxldmVsIDAuNixcbiAgLy8gY29sdW1uIDIyMTUuIFRoaXMgYWRkcyBhIGxpdHRsZSBleHRyYSBvdmVyaGVhZCwgYnV0IGlzIHRoZSBlYXNpZXN0IGZpeCBmb3Igbm93LlxuICBpZiAoZW5kICsgMyA8PSB0aGlzLmVuZCkge1xuICAgIGVuZCArPSAzO1xuICB9XG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBpZiAodGhpcy5kYXRhLm1tbGluZSAmJiB0aGlzLmRhdGEubW1saW5lW2kgLSAxXSA9PT0gMSkge1xuICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uZmlsbFN0eWxlID0gJyNjY2NjY2MnO1xuICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0uZmlsbFJlY3QoeCwgMTAsIHRoaXMuem9vbWVkX2NvbHVtbiwgdGhpcy5oZWlnaHQgLSA0MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmRhdGEuaGVpZ2h0QXJyW2kgLSAxXSxcbiAgICAgIGNvbF9wb3NpdGlvbnMgPSBbXTtcbiAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIHByZXZpb3VzX2hlaWdodCA9IDAsXG4gICAgICAgIGxldHRlcnMgPSBjb2x1bW4ubGVuZ3RoLFxuICAgICAgICBwcmV2aW91c19uZWdfaGVpZ2h0ID0gdG9wX3BpeF9oZWlnaHQsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBjb2xvciA9IG51bGw7XG5cbiAgICAgICAgZm9yKHZhciBqIGluIGNvbHVtbil7XG4gICAgICAgICAgdmFyIGxldHRlciA9IGNvbHVtbltqXSxcbiAgICAgICAgICB2YWx1ZXMgPSBbaixsZXR0ZXJdO1xuICAgICAgICAgIHhfcG9zID0geCArICh0aGlzLnpvb21lZF9jb2x1bW4gLyAyKSxcbiAgICAgICAgICBsZXR0ZXJfaGVpZ2h0ID0gbnVsbDtcblxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZyB3aXRoIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAwLjAxLiBUaGVzZVxuICAgICAgICAgIC8vIGxldHRlcnMgd291bGQgYmUgdG9vIHNtYWxsIHRvIGJlIG1lYW5pbmdmdWwgb24gYW55IHNjYWxlLCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3Qgc3F1YXNoIHRoZW0gb3V0LlxuICAgICAgICAgIGlmICh2YWx1ZXNbMV0gPiAwLjAxKSB7XG4gICAgICAgICAgICBsZXR0ZXJfaGVpZ2h0ID0gcGFyc2VGbG9hdCh2YWx1ZXNbMV0pIC8gdGhpcy5kYXRhLm1heF9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgeV9wb3MgPSAodGhpcy5pbmZvX2NvbnRlbnRfaGVpZ2h0IC0gMikgLSBwcmV2aW91c19oZWlnaHQsXG4gICAgICAgICAgICBnbHlwaF9oZWlnaHQgPSAodGhpcy5pbmZvX2NvbnRlbnRfaGVpZ2h0IC0gMikgKiBsZXR0ZXJfaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb2xfcG9zaXRpb25zW2pdID0gW2dseXBoX2hlaWdodCwgdGhpcy56b29tZWRfY29sdW1uLCB4X3BvcywgeV9wb3NdO1xuICAgICAgICAgICAgcHJldmlvdXNfaGVpZ2h0ID0gcHJldmlvdXNfaGVpZ2h0ICsgZ2x5cGhfaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgbGV0dGVycyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdGhlIGxhcmdlciBsZXR0ZXJzIG9uIHRoZSB0b3BcbiAgICAgICAgLy8gZG9uJ3QgY2xvYmJlciB0aGUgc21hbGxlciBsZXR0ZXJzIGJlbG93IHRoZW0uXG4gICAgICAgIC8vZm9yIChqID0gbGV0dGVyczsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgZm9yKHZhciBqIGluIGNvbHVtbil7XG4gICAgICAgICAgaWYgKGNvbF9wb3NpdGlvbnNbal0gJiYgdGhpcy5sZXR0ZXJzW2pdKSB7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuY29sb3JzY2hlbWUgPT09ICdkeW5hbWljJyl7XG4gICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3Ioaiwge3BvczogaSAtIDF9ICk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JzY2hlbWUgPT09ICdjb25zZW5zdXMnKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNtYXBbaSAtIDFdW2pdIHx8IFwiIzdhN2E3YVwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZXR0ZXJzW2pdLmRyYXcodGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIGNvbF9wb3NpdGlvbnNbal1bMF0sIGNvbF9wb3NpdGlvbnNbal1bMV0sIGNvbF9wb3NpdGlvbnNbal1bMl0sIGNvbF9wb3NpdGlvbnNbal1bM10sIGNvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIGlmIGFsaV9jb29yZGluYXRlcyBleGlzdCBhbmQgdG9nZ2xlIGlzIHNldCB0aGVuIGRpc3BsYXkgdGhlXG4gICAgLy8gYWxpZ25tZW50IGNvb3JkaW5hdGVzIGFuZCBub3QgdGhlIG1vZGVsIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmRpc3BsYXlfYWxpX21hcCkge1xuICAgICAgY29sdW1uX2xhYmVsID0gdGhpcy5kYXRhLmFsaV9tYXBbaSAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2x1bW5fbGFiZWwgPSBjb2x1bW5fbnVtO1xuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93X2RpdmlkZXIpe1xuICAgICAgaWYgKHRoaXMuem9vbSA8IDAuNykge1xuICAgICAgICBpZiAoaSAlIHRoaXMub3B0aW9ucy5kaXZpZGVyX3N0ZXAgPT09IDApIHtcbiAgICAgICAgICBkcmF3X2NvbHVtbl9kaXZpZGVyKHRoaXMse1xuICAgICAgICAgICAgY29udGV4dF9udW0gOiBjb250ZXh0X251bSxcbiAgICAgICAgICAgIHggOiB4LFxuICAgICAgICAgICAgZm9udHNpemU6IDEwLFxuICAgICAgICAgICAgY29sdW1uX251bTogY29sdW1uX2xhYmVsLFxuICAgICAgICAgICAgcmFsaWduOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXdfY29sdW1uX2RpdmlkZXIodGhpcyx7XG4gICAgICAgICAgY29udGV4dF9udW0gOiBjb250ZXh0X251bSxcbiAgICAgICAgICB4IDogeCxcbiAgICAgICAgICBmb250c2l6ZTogZm9udHNpemUsXG4gICAgICAgICAgY29sdW1uX251bTogY29sdW1uX2xhYmVsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93X3Byb2JzKXtcbiAgICAgIGRyYXdfZGVsZXRlX29kZHModGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHgsIHRoaXMuaGVpZ2h0LCB0aGlzLnpvb21lZF9jb2x1bW4sIHRoaXMuZGF0YS5kZWxldGVfcHJvYnNbaSAtIDFdLCBmb250c2l6ZSwgdGhpcy5zaG93X2luc2VydHMpO1xuICAgICAgLy9kcmF3IGluc2VydCBsZW5ndGggdGlja3NcbiAgICAgIGRyYXdfdGlja3ModGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHgsIHRoaXMuaGVpZ2h0IC0gMTUsIDUpO1xuICAgICAgaWYgKHRoaXMuc2hvd19pbnNlcnRzKSB7XG4gICAgICAgIGRyYXdfaW5zZXJ0X29kZHModGhpcy5jb250ZXh0c1tjb250ZXh0X251bV0sIHgsIHRoaXMuaGVpZ2h0LCB0aGlzLnpvb21lZF9jb2x1bW4sIHRoaXMuZGF0YS5pbnNlcnRfcHJvYnNbaSAtIDFdLCBmb250c2l6ZSk7XG4gICAgICAgIGRyYXdfaW5zZXJ0X2xlbmd0aCh0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgeCwgdGhpcy5oZWlnaHQgLSA1LCB0aGlzLnpvb21lZF9jb2x1bW4sIHRoaXMuZGF0YS5pbnNlcnRfbGVuZ3Roc1tpIC0gMV0sIGZvbnRzaXplKTtcblxuICAgICAgICAvLyBkcmF3IGRlbGV0ZSBwcm9iYWJpbGl0eSB0aWNrc1xuICAgICAgICBkcmF3X3RpY2tzKHRoaXMuY29udGV4dHNbY29udGV4dF9udW1dLCB4LCB0aGlzLmhlaWdodCAtIDQ1LCA1KTtcbiAgICAgICAgLy8gZHJhdyBpbnNlcnQgcHJvYmFiaWxpdHkgdGlja3NcbiAgICAgICAgZHJhd190aWNrcyh0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgeCwgdGhpcy5oZWlnaHQgLSAzMCwgNSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB4ICs9IHRoaXMuem9vbWVkX2NvbHVtbjtcbiAgICBjb2x1bW5fbnVtKys7XG4gIH1cblxuXG4gIGlmKHRoaXMub3B0aW9ucy5zaG93X3Byb2JzKXtcbiAgICAvLyBkcmF3IG90aGVyIGRpdmlkZXJzXG4gICAgaWYgKHRoaXMuc2hvd19pbnNlcnRzKSB7XG4gICAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgdGhpcy5oZWlnaHQgLSAzMCwgdGhpcy50b3RhbF93aWR0aCk7XG4gICAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgdGhpcy5oZWlnaHQgLSA0NSwgdGhpcy50b3RhbF93aWR0aCk7XG4gICAgfVxuICAgIGRyYXdfYm9yZGVyKHRoaXMuY29udGV4dHNbY29udGV4dF9udW1dLCB0aGlzLmhlaWdodCAtIDE1LCB0aGlzLnRvdGFsX3dpZHRoKTtcbiAgfVxuICBpZih0aGlzLm9wdGlvbnMuYm9yZGVyKXtcbiAgICBkcmF3X2JvcmRlcih0aGlzLmNvbnRleHRzW2NvbnRleHRfbnVtXSwgMCwgdGhpcy50b3RhbF93aWR0aCk7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZHJhd19kZWxldGVfb2Rkcyhjb250ZXh0LCB4LCBoZWlnaHQsIGNvbF93aWR0aCwgdGV4dCwgZm9udHNpemUsIHNob3dfaW5zZXJ0cykge1xuICB2YXIgeSAgICAgICAgPSBoZWlnaHQgLSA0LFxuICBmaWxsICAgICA9ICcjZmZmZmZmJyxcbiAgdGV4dGZpbGwgPSAnIzU1NTU1NSc7XG5cbiAgaWYgKHNob3dfaW5zZXJ0cykge1xuICAgIHkgPSBoZWlnaHQgLSAzNTtcbiAgfVxuXG4gIGlmICh0ZXh0IDwgMC43NSkge1xuICAgIGZpbGwgICAgID0gJyMyMTcxYjUnO1xuICAgIHRleHRmaWxsID0gJyNmZmZmZmYnO1xuICB9IGVsc2UgaWYgKHRleHQgPCAwLjg1KSB7XG4gICAgZmlsbCA9ICcjNmJhZWQ2JztcbiAgfSBlbHNlIGlmICh0ZXh0IDwgMC45NSkge1xuICAgIGZpbGwgPSAnI2JkZDdlNyc7XG4gIH1cblxuICBkcmF3X3JlY3Rfd2l0aF90ZXh0KGNvbnRleHQsIHgsIHksIHRleHQsIGZvbnRzaXplLCBjb2xfd2lkdGgsIGZpbGwsIHRleHRmaWxsKTtcbn1cblxuZnVuY3Rpb24gZHJhd19yZWN0X3dpdGhfdGV4dChjb250ZXh0LCB4LCB5LCB0ZXh0LCBmb250c2l6ZSwgY29sX3dpZHRoLCBmaWxsLCB0ZXh0ZmlsbCkge1xuICBjb250ZXh0LmZvbnQgPSBmb250c2l6ZSArIFwicHggQXJpYWxcIjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsO1xuICBjb250ZXh0LmZpbGxSZWN0KHgsIHkgLSAxMCwgY29sX3dpZHRoLCAxNCk7XG4gIGNvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0ZmlsbDtcbiAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4ICsgKGNvbF93aWR0aCAvIDIpLCB5KTtcbn1cblxuZnVuY3Rpb24gZHJhd19jb2x1bW5fZGl2aWRlcihpbnN0LCBvcHRzKSB7XG4gIHZhciBkaXZfeCA9IG9wdHMucmFsaWduID8gb3B0cy54ICsgaW5zdC56b29tZWRfY29sdW1uIDogb3B0cy54LFxuICBudW1feCA9IG9wdHMucmFsaWduID8gb3B0cy54ICsgMiA6IG9wdHMueDtcbiAgLy8gZHJhdyBjb2x1bW4gZGl2aWRlcnNcbiAgZHJhd190aWNrcyhpbnN0LmNvbnRleHRzW29wdHMuY29udGV4dF9udW1dLCBkaXZfeCwgaW5zdC5oZWlnaHQgLSAzMCwgLTMwIC0gaW5zdC5oZWlnaHQsICcjZGRkZGRkJyk7XG4gIC8vIGRyYXcgdG9wIHRpY2tzXG4gIGRyYXdfdGlja3MoaW5zdC5jb250ZXh0c1tvcHRzLmNvbnRleHRfbnVtXSwgZGl2X3gsIDAsIDUpO1xuICAvLyBkcmF3IGNvbHVtbiBudW1iZXJzXG4gIGRyYXdfY29sdW1uX251bWJlcihpbnN0LmNvbnRleHRzW29wdHMuY29udGV4dF9udW1dLCBudW1feCwgMTAsIGluc3Quem9vbWVkX2NvbHVtbiwgb3B0cy5jb2x1bW5fbnVtLCBvcHRzLmZvbnRzaXplLCBvcHRzLnJhbGlnbik7XG59O1xuXG5cblxuZnVuY3Rpb24gZHJhd19pbnNlcnRfb2Rkcyhjb250ZXh0LCB4LCBoZWlnaHQsIGNvbF93aWR0aCwgdGV4dCwgZm9udHNpemUpIHtcbiAgdmFyIHkgICAgICAgID0gaGVpZ2h0IC0gMjAsXG4gIGZpbGwgICAgID0gJyNmZmZmZmYnLFxuICB0ZXh0ZmlsbCA9ICcjNTU1NTU1JztcblxuICBpZiAodGV4dCA+IDAuMSkge1xuICAgIGZpbGwgICAgID0gJyNkNzMwMWYnO1xuICAgIHRleHRmaWxsID0gJyNmZmZmZmYnO1xuICB9IGVsc2UgaWYgKHRleHQgPiAwLjA1KSB7XG4gICAgZmlsbCA9ICcjZmM4ZDU5JztcbiAgfSBlbHNlIGlmICh0ZXh0ID4gMC4wMykge1xuICAgIGZpbGwgPSAnI2ZkY2M4YSc7XG4gIH1cblxuICBkcmF3X3JlY3Rfd2l0aF90ZXh0KGNvbnRleHQsIHgsIHksIHRleHQsIGZvbnRzaXplLCBjb2xfd2lkdGgsIGZpbGwsIHRleHRmaWxsKTtcblxuICAvL2RyYXcgdmVydGljYWwgbGluZSB0byBpbmRpY2F0ZSB3aGVyZSB0aGUgaW5zZXJ0IHdvdWxkIG9jY3VyXG4gIGlmICh0ZXh0ID4gMC4wMykge1xuICAgIGRyYXdfdGlja3MoY29udGV4dCwgeCArIGNvbF93aWR0aCwgaGVpZ2h0IC0gMzAsIC0zMCAtIGhlaWdodCwgZmlsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdfaW5zZXJ0X2xlbmd0aChjb250ZXh0LCB4LCB5LCBjb2xfd2lkdGgsIHRleHQsIGZvbnRzaXplKSB7XG4gIHZhciBmaWxsID0gJyNmZmZmZmYnLFxuICB0ZXh0ZmlsbCA9ICcjNTU1NTU1JztcblxuICBpZiAodGV4dCA+IDkpIHtcbiAgICBmaWxsICAgICA9ICcjZDczMDFmJztcbiAgICB0ZXh0ZmlsbCA9ICcjZmZmZmZmJztcbiAgfSBlbHNlIGlmICh0ZXh0ID4gNykge1xuICAgIGZpbGwgPSAnI2ZjOGQ1OSc7XG4gIH0gZWxzZSBpZiAodGV4dCA+IDQpIHtcbiAgICBmaWxsID0gJyNmZGNjOGEnO1xuICB9XG4gIGRyYXdfcmVjdF93aXRoX3RleHQoY29udGV4dCwgeCwgeSwgdGV4dCwgZm9udHNpemUsIGNvbF93aWR0aCwgZmlsbCwgdGV4dGZpbGwpO1xufVxuIiwiLypcbiAqIEphdmFTY3JpcHQgQ2FudmFzIHRvIEJsb2IgMi4wLjVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtQ2FudmFzLXRvLUJsb2JcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb24gc3RhY2tvdmVyZmxvdyB1c2VyIFN0b2l2ZSdzIGNvZGUgc25pcHBldDpcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzQ5OTg5MDhcbiAqL1xudmFyIENhbnZhc1Byb3RvdHlwZSA9IHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCAmJlxud2luZG93LkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSxcbiAgaGFzQmxvYkNvbnN0cnVjdG9yID0gd2luZG93LkJsb2IgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4obmV3IEJsb2IoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSgpKSxcbiAgaGFzQXJyYXlCdWZmZXJWaWV3U3VwcG9ydCA9IGhhc0Jsb2JDb25zdHJ1Y3RvciAmJiB3aW5kb3cuVWludDhBcnJheSAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KDEwMCldKS5zaXplID09PSAxMDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSgpKSxcbiAgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8XG4gIHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcixcbiAgZGF0YVVSTHRvQmxvYiA9IChoYXNCbG9iQ29uc3RydWN0b3IgfHwgQmxvYkJ1aWxkZXIpICYmIHdpbmRvdy5hdG9iICYmXG4gIHdpbmRvdy5BcnJheUJ1ZmZlciAmJiB3aW5kb3cuVWludDhBcnJheSAmJiBmdW5jdGlvbiAoZGF0YVVSSSkge1xuICAgIHZhciBieXRlU3RyaW5nLFxuICAgIGFycmF5QnVmZmVyLFxuICAgIGludEFycmF5LFxuICAgICAgaSxcbiAgICAgIG1pbWVTdHJpbmcsXG4gICAgICAgIGJiO1xuICAgIGlmIChkYXRhVVJJLnNwbGl0KCcsJylbMF0uaW5kZXhPZignYmFzZTY0JykgPj0gMCkge1xuICAgICAgLy8gQ29udmVydCBiYXNlNjQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBzdHJpbmc6XG4gICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb252ZXJ0IGJhc2U2NC9VUkxFbmNvZGVkIGRhdGEgY29tcG9uZW50IHRvIHJhdyBiaW5hcnkgZGF0YTpcbiAgICAgIGJ5dGVTdHJpbmcgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YVVSSS5zcGxpdCgnLCcpWzFdKTtcbiAgICB9XG4gICAgLy8gV3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXI6XG4gICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgLy8gU2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudDpcbiAgICBtaW1lU3RyaW5nID0gZGF0YVVSSS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXTtcbiAgICAvLyBXcml0ZSB0aGUgQXJyYXlCdWZmZXIgKG9yIEFycmF5QnVmZmVyVmlldykgdG8gYSBibG9iOlxuICAgIGlmIChoYXNCbG9iQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgQmxvYihcbiAgICAgICAgICBbaGFzQXJyYXlCdWZmZXJWaWV3U3VwcG9ydCA/IGludEFycmF5IDogYXJyYXlCdWZmZXJdLFxuICAgICAgICAgIHt0eXBlOiBtaW1lU3RyaW5nfVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICByZXR1cm4gYmIuZ2V0QmxvYihtaW1lU3RyaW5nKTtcbiAgfTtcbmlmICh3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgJiYgIUNhbnZhc1Byb3RvdHlwZS50b0Jsb2IpIHtcbiAgaWYgKENhbnZhc1Byb3RvdHlwZS5tb3pHZXRBc0ZpbGUpIHtcbiAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICBpZiAocXVhbGl0eSAmJiBDYW52YXNQcm90b3R5cGUudG9EYXRhVVJMICYmIGRhdGFVUkx0b0Jsb2IpIHtcbiAgICAgICAgY2FsbGJhY2soZGF0YVVSTHRvQmxvYih0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5tb3pHZXRBc0ZpbGUoJ2Jsb2InLCB0eXBlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChDYW52YXNQcm90b3R5cGUudG9EYXRhVVJMICYmIGRhdGFVUkx0b0Jsb2IpIHtcbiAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICBjYWxsYmFjayhkYXRhVVJMdG9CbG9iKHRoaXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFVUkx0b0Jsb2I7XG4iLCIvKiBGaWxlU2F2ZXIuanNcbiAqICBBIHNhdmVBcygpIEZpbGVTYXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqICAyMDE0LTA1LTI3XG4gKlxuICogIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqICBMaWNlbnNlOiBYMTEvTUlUXG4gKiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlLCBpbmRlbnQ6IDQsIGxheGJyZWFrOiB0cnVlLCBsYXhjb21tYTogdHJ1ZSwgc21hcnR0YWJzOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0ZpbGVTYXZlci5qcyAqL1xuXG52YXIgc2F2ZUFzID0gc2F2ZUFzXG4gIC8vIElFIDEwKyAobmF0aXZlIHNhdmVBcylcbiAgfHwgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iLmJpbmQobmF2aWdhdG9yKSlcbiAgLy8gRXZlcnlvbmUgZWxzZVxuICB8fCAoZnVuY3Rpb24odmlldykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0Ly8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0ICAgIC9NU0lFIFsxLTldXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhclxuXHRcdCAgZG9jID0gdmlldy5kb2N1bWVudFxuXHRcdCAgLy8gb25seSBnZXQgVVJMIHdoZW4gbmVjZXNzYXJ5IGluIGNhc2UgQmxvYi5qcyBoYXNuJ3Qgb3ZlcnJpZGRlbiBpdCB5ZXRcblx0XHQsIGdldF9VUkwgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3O1xuXHRcdH1cblx0XHQsIHNhdmVfbGluayA9IGRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIFwiYVwiKVxuXHRcdCwgY2FuX3VzZV9zYXZlX2xpbmsgPSAhdmlldy5leHRlcm5hbEhvc3QgJiYgXCJkb3dubG9hZFwiIGluIHNhdmVfbGlua1xuXHRcdCwgY2xpY2sgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcblx0XHRcdGV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdFx0XHRcImNsaWNrXCIsIHRydWUsIGZhbHNlLCB2aWV3LCAwLCAwLCAwLCAwLCAwXG5cdFx0XHRcdCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGxcblx0XHRcdCk7XG5cdFx0XHRub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHQsIHdlYmtpdF9yZXFfZnMgPSB2aWV3LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtXG5cdFx0LCByZXFfZnMgPSB2aWV3LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdlYmtpdF9yZXFfZnMgfHwgdmlldy5tb3pSZXF1ZXN0RmlsZVN5c3RlbVxuXHRcdCwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uKGV4KSB7XG5cdFx0XHQodmlldy5zZXRJbW1lZGlhdGUgfHwgdmlldy5zZXRUaW1lb3V0KShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgZXg7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdFx0LCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuXHRcdCwgZnNfbWluX3NpemUgPSAwXG5cdFx0LCBkZWxldGlvbl9xdWV1ZSA9IFtdXG5cdFx0LCBwcm9jZXNzX2RlbGV0aW9uX3F1ZXVlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IGRlbGV0aW9uX3F1ZXVlLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFyIGZpbGUgPSBkZWxldGlvbl9xdWV1ZVtpXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7IC8vIGZpbGUgaXMgYW4gb2JqZWN0IFVSTFxuXHRcdFx0XHRcdGdldF9VUkwoKS5yZXZva2VPYmplY3RVUkwoZmlsZSk7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGZpbGUgaXMgYSBGaWxlXG5cdFx0XHRcdFx0ZmlsZS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGVsZXRpb25fcXVldWUubGVuZ3RoID0gMDsgLy8gY2xlYXIgcXVldWVcblx0XHR9XG5cdFx0LCBkaXNwYXRjaCA9IGZ1bmN0aW9uKGZpbGVzYXZlciwgZXZlbnRfdHlwZXMsIGV2ZW50KSB7XG5cdFx0XHRldmVudF90eXBlcyA9IFtdLmNvbmNhdChldmVudF90eXBlcyk7XG5cdFx0XHR2YXIgaSA9IGV2ZW50X3R5cGVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZmlsZXNhdmVyW1wib25cIiArIGV2ZW50X3R5cGVzW2ldXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGwoZmlsZXNhdmVyLCBldmVudCB8fCBmaWxlc2F2ZXIpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0XHR0aHJvd19vdXRzaWRlKGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0LCBGaWxlU2F2ZXIgPSBmdW5jdGlvbihibG9iLCBuYW1lKSB7XG5cdFx0XHQvLyBGaXJzdCB0cnkgYS5kb3dubG9hZCwgdGhlbiB3ZWIgZmlsZXN5c3RlbSwgdGhlbiBvYmplY3QgVVJMc1xuXHRcdFx0dmFyXG5cdFx0XHRcdCAgZmlsZXNhdmVyID0gdGhpc1xuXHRcdFx0XHQsIHR5cGUgPSBibG9iLnR5cGVcblx0XHRcdFx0LCBibG9iX2NoYW5nZWQgPSBmYWxzZVxuXHRcdFx0XHQsIG9iamVjdF91cmxcblx0XHRcdFx0LCB0YXJnZXRfdmlld1xuXHRcdFx0XHQsIGdldF9vYmplY3RfdXJsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRcdGRlbGV0aW9uX3F1ZXVlLnB1c2gob2JqZWN0X3VybCk7XG5cdFx0XHRcdFx0cmV0dXJuIG9iamVjdF91cmw7XG5cdFx0XHRcdH1cblx0XHRcdFx0LCBkaXNwYXRjaF9hbGwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkaXNwYXRjaChmaWxlc2F2ZXIsIFwid3JpdGVzdGFydCBwcm9ncmVzcyB3cml0ZSB3cml0ZWVuZFwiLnNwbGl0KFwiIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb24gYW55IGZpbGVzeXMgZXJyb3JzIHJldmVydCB0byBzYXZpbmcgd2l0aCBvYmplY3QgVVJMc1xuXHRcdFx0XHQsIGZzX2Vycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgY3JlYXRlIG1vcmUgb2JqZWN0IFVSTHMgdGhhbiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoYmxvYl9jaGFuZ2VkIHx8ICFvYmplY3RfdXJsKSB7XG5cdFx0XHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X29iamVjdF91cmwoYmxvYik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0YXJnZXRfdmlldykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0X3ZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdpbmRvdy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCwgYWJvcnRhYmxlID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmIChmaWxlc2F2ZXIucmVhZHlTdGF0ZSAhPT0gZmlsZXNhdmVyLkRPTkUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdCwgY3JlYXRlX2lmX25vdF9mb3VuZCA9IHtjcmVhdGU6IHRydWUsIGV4Y2x1c2l2ZTogZmFsc2V9XG5cdFx0XHRcdCwgc2xpY2Vcblx0XHRcdDtcblx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cdFx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdFx0bmFtZSA9IFwiZG93bmxvYWRcIjtcblx0XHRcdH1cblx0XHRcdGlmIChjYW5fdXNlX3NhdmVfbGluaykge1xuXHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X29iamVjdF91cmwoYmxvYik7XG5cdFx0XHRcdHNhdmVfbGluay5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0c2F2ZV9saW5rLmRvd25sb2FkID0gbmFtZTtcblx0XHRcdFx0Y2xpY2soc2F2ZV9saW5rKTtcblx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIE9iamVjdCBhbmQgd2ViIGZpbGVzeXN0ZW0gVVJMcyBoYXZlIGEgcHJvYmxlbSBzYXZpbmcgaW4gR29vZ2xlIENocm9tZSB3aGVuXG5cdFx0XHQvLyB2aWV3ZWQgaW4gYSB0YWIsIHNvIEkgZm9yY2Ugc2F2ZSB3aXRoIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVxuXHRcdFx0Ly8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTExNThcblx0XHRcdGlmICh2aWV3LmNocm9tZSAmJiB0eXBlICYmIHR5cGUgIT09IGZvcmNlX3NhdmVhYmxlX3R5cGUpIHtcblx0XHRcdFx0c2xpY2UgPSBibG9iLnNsaWNlIHx8IGJsb2Iud2Via2l0U2xpY2U7XG5cdFx0XHRcdGJsb2IgPSBzbGljZS5jYWxsKGJsb2IsIDAsIGJsb2Iuc2l6ZSwgZm9yY2Vfc2F2ZWFibGVfdHlwZSk7XG5cdFx0XHRcdGJsb2JfY2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaW5jZSBJIGNhbid0IGJlIHN1cmUgdGhhdCB0aGUgZ3Vlc3NlZCBtZWRpYSB0eXBlIHdpbGwgdHJpZ2dlciBhIGRvd25sb2FkXG5cdFx0XHQvLyBpbiBXZWJLaXQsIEkgYXBwZW5kIC5kb3dubG9hZCB0byB0aGUgZmlsZW5hbWUuXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjU0NDBcblx0XHRcdGlmICh3ZWJraXRfcmVxX2ZzICYmIG5hbWUgIT09IFwiZG93bmxvYWRcIikge1xuXHRcdFx0XHRuYW1lICs9IFwiLmRvd25sb2FkXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PT0gZm9yY2Vfc2F2ZWFibGVfdHlwZSB8fCB3ZWJraXRfcmVxX2ZzKSB7XG5cdFx0XHRcdHRhcmdldF92aWV3ID0gdmlldztcblx0XHRcdH1cblx0XHRcdGlmICghcmVxX2ZzKSB7XG5cdFx0XHRcdGZzX2Vycm9yKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGZzX21pbl9zaXplICs9IGJsb2Iuc2l6ZTtcblx0XHRcdHJlcV9mcyh2aWV3LlRFTVBPUkFSWSwgZnNfbWluX3NpemUsIGFib3J0YWJsZShmdW5jdGlvbihmcykge1xuXHRcdFx0XHRmcy5yb290LmdldERpcmVjdG9yeShcInNhdmVkXCIsIGNyZWF0ZV9pZl9ub3RfZm91bmQsIGFib3J0YWJsZShmdW5jdGlvbihkaXIpIHtcblx0XHRcdFx0XHR2YXIgc2F2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGlyLmdldEZpbGUobmFtZSwgY3JlYXRlX2lmX25vdF9mb3VuZCwgYWJvcnRhYmxlKGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRcdFx0ZmlsZS5jcmVhdGVXcml0ZXIoYWJvcnRhYmxlKGZ1bmN0aW9uKHdyaXRlcikge1xuXHRcdFx0XHRcdFx0XHRcdHdyaXRlci5vbndyaXRlZW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldF92aWV3LmxvY2F0aW9uLmhyZWYgPSBmaWxlLnRvVVJMKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGlvbl9xdWV1ZS5wdXNoKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZWVuZFwiLCBldmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHR3cml0ZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gd3JpdGVyLmVycm9yO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVycm9yLmNvZGUgIT09IGVycm9yLkFCT1JUX0VSUikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmc19lcnJvcigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0XCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIGFib3J0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlcltcIm9uXCIgKyBldmVudF0gPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRdO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHdyaXRlci53cml0ZShibG9iKTtcblx0XHRcdFx0XHRcdFx0XHRmaWxlc2F2ZXIuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLldSSVRJTkc7XG5cdFx0XHRcdFx0XHRcdH0pLCBmc19lcnJvcik7XG5cdFx0XHRcdFx0XHR9KSwgZnNfZXJyb3IpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGlyLmdldEZpbGUobmFtZSwge2NyZWF0ZTogZmFsc2V9LCBhYm9ydGFibGUoZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdFx0Ly8gZGVsZXRlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHNcblx0XHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRzYXZlKCk7XG5cdFx0XHRcdFx0fSksIGFib3J0YWJsZShmdW5jdGlvbihleCkge1xuXHRcdFx0XHRcdFx0aWYgKGV4LmNvZGUgPT09IGV4Lk5PVF9GT1VORF9FUlIpIHtcblx0XHRcdFx0XHRcdFx0c2F2ZSgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZnNfZXJyb3IoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH0pLCBmc19lcnJvcik7XG5cdFx0XHR9KSwgZnNfZXJyb3IpO1xuXHRcdH1cblx0XHQsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuXHRcdCwgc2F2ZUFzID0gZnVuY3Rpb24oYmxvYiwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBGaWxlU2F2ZXIoYmxvYiwgbmFtZSk7XG5cdFx0fVxuXHQ7XG5cdEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpbGVzYXZlciA9IHRoaXM7XG5cdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRkaXNwYXRjaChmaWxlc2F2ZXIsIFwiYWJvcnRcIik7XG5cdH07XG5cdEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcblx0RlNfcHJvdG8uV1JJVElORyA9IDE7XG5cdEZTX3Byb3RvLkRPTkUgPSAyO1xuXG5cdEZTX3Byb3RvLmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZXN0YXJ0ID1cblx0RlNfcHJvdG8ub25wcm9ncmVzcyA9XG5cdEZTX3Byb3RvLm9ud3JpdGUgPVxuXHRGU19wcm90by5vbmFib3J0ID1cblx0RlNfcHJvdG8ub25lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuXHRcdG51bGw7XG5cblx0dmlldy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIHByb2Nlc3NfZGVsZXRpb25fcXVldWUsIGZhbHNlKTtcblx0c2F2ZUFzLnVubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHByb2Nlc3NfZGVsZXRpb25fcXVldWUoKTtcblx0XHR2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgcHJvY2Vzc19kZWxldGlvbl9xdWV1ZSwgZmFsc2UpO1xuXHR9O1xuXHRyZXR1cm4gc2F2ZUFzO1xufShcblx0ICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuXHR8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuXHR8fCB0aGlzLmNvbnRlbnRcbikpO1xuLy8gYHNlbGZgIGlzIHVuZGVmaW5lZCBpbiBGaXJlZm94IGZvciBBbmRyb2lkIGNvbnRlbnQgc2NyaXB0IGNvbnRleHRcbi8vIHdoaWxlIGB0aGlzYCBpcyBuc0lDb250ZW50RnJhbWVNZXNzYWdlTWFuYWdlclxuLy8gd2l0aCBhbiBhdHRyaWJ1dGUgYGNvbnRlbnRgIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHdpbmRvd1xuXG5hbWREZWZpbmUgPSB3aW5kb3cuZGVmaW5lO1xuaWYoIHR5cGVvZiBhbWREZWZpbmUgPT09IFwidW5kZWZpbmVkXCIgJiYgKHR5cGVvZiB3aW5kb3cuYWxtb25kICE9PSBcInVuZGVmaW5lZFwiIFxuICAgICYmIFwiZGVmaW5lXCIgaW4gd2luZG93LmFsbW9uZCApKXtcbiAgYW1kRGVmaW5lID0gd2luZG93LmFsbW9uZC5kZWZpbmU7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZSAhPT0gbnVsbCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNhdmVBcztcbn0gZWxzZSBpZiAoKHR5cGVvZiBhbWREZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgYW1kRGVmaW5lICE9PSBudWxsKSAmJiAoYW1kRGVmaW5lLmFtZCAhPSBudWxsKSkge1xuICBhbWREZWZpbmUoXCJzYXZlQXNcIixbXSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNhdmVBcztcbiAgfSk7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzLCBjdXN0b21Eb2N1bWVudCkge1xuICB2YXIgZG9jID0gY3VzdG9tRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGlmIChkb2MuY3JlYXRlU3R5bGVTaGVldCkge1xuICAgIHZhciBzaGVldCA9IGRvYy5jcmVhdGVTdHlsZVNoZWV0KClcbiAgICBzaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIHJldHVybiBzaGVldC5vd25lck5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcbiAgICAgICAgc3R5bGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgIH1cblxuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuYnlVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCh1cmwpLm93bmVyTm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIHJldHVybiBsaW5rO1xuICB9XG59O1xuIiwidmFyIFV0aWxzID0ge307XG5cblxuLypcblJlbW92ZSBhbiBlbGVtZW50IGFuZCBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpbnNlcnRzIGl0IGludG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG5odHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zcGVlZC9hcnRpY2xlcy9qYXZhc2NyaXB0LWRvbVxuQHBhcmFtIGVsZW1lbnQge0VsZW1lbnR9IFRoZSBlbGVtZW50IHRvIGJlIHRlbXBvcmFyaWx5IHJlbW92ZWRcbkByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgaW5zZXJ0cyB0aGUgZWxlbWVudCBpbnRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICovXG5cblV0aWxzLnJlbW92ZVRvSW5zZXJ0TGF0ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBuZXh0U2libGluZywgcGFyZW50Tm9kZTtcbiAgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgbmV4dFNpYmxpbmcgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBuZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9O1xufTtcblxuXG4vKlxuZmFzdGVzdCBwb3NzaWJsZSB3YXkgdG8gZGVzdHJveSBhbGwgc3ViIG5vZGVzIChha2EgY2hpbGRzKVxuaHR0cDovL2pzcGVyZi5jb20vaW5uZXJodG1sLXZzLXJlbW92ZWNoaWxkLzE1XG5AcGFyYW0gZWxlbWVudCB7RWxlbWVudH0gVGhlIGVsZW1lbnQgZm9yIHdoaWNoIGFsbCBjaGlsZHMgc2hvdWxkIGJlIHJlbW92ZWRcbiAqL1xuXG5VdGlscy5yZW1vdmVBbGxDaGlsZHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBjb3VudDtcbiAgY291bnQgPSAwO1xuICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgY291bnQrKztcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG4iLCIvKiFcbiAqIGpCb25lIHYxLjAuMjQgLSAyMDE1LTAzLTMwIC0gTGlicmFyeSBmb3IgRE9NIG1hbmlwdWxhdGlvblxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXByaXlhbmVua28vamJvbmVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNSBBbGV4ZXkgS3Vwcml5YW5lbmtvXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uICh3aW4pIHtcblxudmFyXG4vLyBjYWNoZSBwcmV2aW91cyB2ZXJzaW9uc1xuXyQgPSB3aW4uJCxcbl9qQm9uZSA9IHdpbi5qQm9uZSxcblxuLy8gUXVpY2sgbWF0Y2ggYSBzdGFuZGFsb25lIHRhZ1xucnF1aWNrU2luZ2xlVGFnID0gL148KFxcdyspXFxzKlxcLz8+JC8sXG5cbi8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG4vLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaFxucnF1aWNrRXhwciA9IC9eKD86W14jPF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKikkKS8sXG5cbi8vIEFsaWFzIGZvciBmdW5jdGlvblxuc2xpY2UgPSBbXS5zbGljZSxcbnNwbGljZSA9IFtdLnNwbGljZSxcbmtleXMgPSBPYmplY3Qua2V5cyxcblxuLy8gQWxpYXMgZm9yIGdsb2JhbCB2YXJpYWJsZXNcbmRvYyA9IGRvY3VtZW50LFxuXG5pc1N0cmluZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIjtcbn0sXG5pc09iamVjdCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsIGluc3RhbmNlb2YgT2JqZWN0O1xufSxcbmlzRnVuY3Rpb24gPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAoe30pLnRvU3RyaW5nLmNhbGwoZWwpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG59LFxuaXNBcnJheSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWwpO1xufSxcbmpCb25lID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YSkge1xuICAgIHJldHVybiBuZXcgZm4uaW5pdChlbGVtZW50LCBkYXRhKTtcbn0sXG5mbjtcblxuLy8gc2V0IHByZXZpb3VzIHZhbHVlcyBhbmQgcmV0dXJuIHRoZSBpbnN0YW5jZSB1cG9uIGNhbGxpbmcgdGhlIG5vLWNvbmZsaWN0IG1vZGVcbmpCb25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4uJCA9IF8kO1xuICAgIHdpbi5qQm9uZSA9IF9qQm9uZTtcblxuICAgIHJldHVybiBqQm9uZTtcbn07XG5cbmZuID0gakJvbmUuZm4gPSBqQm9uZS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgZGF0YSkge1xuICAgICAgICB2YXIgZWxlbWVudHMsIHRhZywgd3JhcGVyLCBmcmFnbWVudDtcblxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNpbmdsZSBET00gZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRhZyA9IHJxdWlja1NpbmdsZVRhZy5leGVjKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1swXSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBET00gY29sbGVjdGlvblxuICAgICAgICAgICAgaWYgKCh0YWcgPSBycXVpY2tFeHByLmV4ZWMoZWxlbWVudCkpICYmIHRhZ1sxXSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB3cmFwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICB3cmFwZXIuaW5uZXJIVE1MID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAod3JhcGVyLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3cmFwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gc2xpY2UuY2FsbChmcmFnbWVudC5jaGlsZE5vZGVzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBqQm9uZS5tZXJnZSh0aGlzLCBlbGVtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIERPTSBlbGVtZW50cyB3aXRoIHF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgIGlmIChqQm9uZS5pc0VsZW1lbnQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gakJvbmUoZGF0YSkuZmluZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpCb25lLm1lcmdlKHRoaXMsIGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXcmFwIERPTUVsZW1lbnRcbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gZnVuY3Rpb25cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGpCb25lIGVsZW1lbnQgYXMgaXNcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBqQm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gZWxlbWVudCB3cmFwcGVkIGJ5IGpCb25lXG4gICAgICAgIHJldHVybiBqQm9uZS5tYWtlQXJyYXkoZWxlbWVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIHBvcDogW10ucG9wLFxuICAgIHB1c2g6IFtdLnB1c2gsXG4gICAgcmV2ZXJzZTogW10ucmV2ZXJzZSxcbiAgICBzaGlmdDogW10uc2hpZnQsXG4gICAgc29ydDogW10uc29ydCxcbiAgICBzcGxpY2U6IFtdLnNwbGljZSxcbiAgICBzbGljZTogW10uc2xpY2UsXG4gICAgaW5kZXhPZjogW10uaW5kZXhPZixcbiAgICBmb3JFYWNoOiBbXS5mb3JFYWNoLFxuICAgIHVuc2hpZnQ6IFtdLnVuc2hpZnQsXG4gICAgY29uY2F0OiBbXS5jb25jYXQsXG4gICAgam9pbjogW10uam9pbixcbiAgICBldmVyeTogW10uZXZlcnksXG4gICAgc29tZTogW10uc29tZSxcbiAgICBmaWx0ZXI6IFtdLmZpbHRlcixcbiAgICBtYXA6IFtdLm1hcCxcbiAgICByZWR1Y2U6IFtdLnJlZHVjZSxcbiAgICByZWR1Y2VSaWdodDogW10ucmVkdWNlUmlnaHQsXG4gICAgbGVuZ3RoOiAwXG59O1xuXG5mbi5jb25zdHJ1Y3RvciA9IGpCb25lO1xuXG5mbi5pbml0LnByb3RvdHlwZSA9IGZuO1xuXG5qQm9uZS5zZXRJZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGppZCA9IGVsLmppZDtcblxuICAgIGlmIChlbCA9PT0gd2luKSB7XG4gICAgICAgIGppZCA9IFwid2luZG93XCI7XG4gICAgfSBlbHNlIGlmIChlbC5qaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbC5qaWQgPSBqaWQgPSArK2pCb25lLl9jYWNoZS5qaWQ7XG4gICAgfVxuXG4gICAgaWYgKCFqQm9uZS5fY2FjaGUuZXZlbnRzW2ppZF0pIHtcbiAgICAgICAgakJvbmUuX2NhY2hlLmV2ZW50c1tqaWRdID0ge307XG4gICAgfVxufTtcblxuakJvbmUuZ2V0RGF0YSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgZWwgPSBlbCBpbnN0YW5jZW9mIGpCb25lID8gZWxbMF0gOiBlbDtcblxuICAgIHZhciBqaWQgPSBlbCA9PT0gd2luID8gXCJ3aW5kb3dcIiA6IGVsLmppZDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGppZDogamlkLFxuICAgICAgICBldmVudHM6IGpCb25lLl9jYWNoZS5ldmVudHNbamlkXVxuICAgIH07XG59O1xuXG5qQm9uZS5pc0VsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBlbCAmJiBlbCBpbnN0YW5jZW9mIGpCb25lIHx8IGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgaXNTdHJpbmcoZWwpO1xufTtcblxuakJvbmUuX2NhY2hlID0ge1xuICAgIGV2ZW50czoge30sXG4gICAgamlkOiAwXG59O1xuXG5mdW5jdGlvbiBpc0FycmF5bGlrZShvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aCxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBvYmo7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0eXBlKSB8fCBvYmogPT09IHdpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQXJyYXkodHlwZSkgfHwgbGVuZ3RoID09PSAwIHx8XG4gICAgICAgIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqO1xufVxuXG5mbi5wdXNoU3RhY2sgPSBmdW5jdGlvbihlbGVtcykge1xuICAgIHZhciByZXQgPSBqQm9uZS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zKTtcblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5qQm9uZS5tZXJnZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICB2YXIgbCA9IHNlY29uZC5sZW5ndGgsXG4gICAgICAgIGkgPSBmaXJzdC5sZW5ndGgsXG4gICAgICAgIGogPSAwO1xuXG4gICAgd2hpbGUgKGogPCBsKSB7XG4gICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbaisrXTtcbiAgICB9XG5cbiAgICBmaXJzdC5sZW5ndGggPSBpO1xuXG4gICAgcmV0dXJuIGZpcnN0O1xufTtcblxuakJvbmUuY29udGFpbnMgPSBmdW5jdGlvbihjb250YWluZXIsIGNvbnRhaW5lZCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBjb250YWluZXIucmV2ZXJzZSgpLnNvbWUoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsLmNvbnRhaW5zKGNvbnRhaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBlbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmpCb25lLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciB0ZztcblxuICAgIHNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdGcgPSB0YXJnZXQ7IC8vY2FjaGluZyB0YXJnZXQgZm9yIHBlcmYgaW1wcm92ZW1lbnRcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRnW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuakJvbmUubWFrZUFycmF5ID0gZnVuY3Rpb24oYXJyLCByZXN1bHRzKSB7XG4gICAgdmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cbiAgICBpZiAoYXJyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0FycmF5bGlrZShhcnIpKSB7XG4gICAgICAgICAgICBqQm9uZS5tZXJnZShyZXQsIGlzU3RyaW5nKGFycikgPyBbYXJyXSA6IGFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQucHVzaChhcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmpCb25lLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gQm9uZUV2ZW50KGUsIGRhdGEpIHtcbiAgICB2YXIga2V5LCBzZXR0ZXI7XG5cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlO1xuXG4gICAgc2V0dGVyID0gZnVuY3Rpb24oa2V5LCBlKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwicHJldmVudERlZmF1bHRcIikge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZVtrZXldKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIikge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBlW2tleV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihlW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZVtrZXldKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZVtrZXldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoa2V5IGluIGUpIHtcbiAgICAgICAgaWYgKGVba2V5XSB8fCB0eXBlb2YgZVtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNldHRlci5jYWxsKHRoaXMsIGtleSwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqQm9uZS5leHRlbmQodGhpcywgZGF0YSwge1xuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5qQm9uZS5FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIG5hbWVzcGFjZSwgZXZlbnRUeXBlO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgJiYgIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGV2ZW50O1xuICAgICAgICBldmVudCA9IGV2ZW50LnR5cGU7XG4gICAgfVxuXG4gICAgbmFtZXNwYWNlID0gZXZlbnQuc3BsaXQoXCIuXCIpLnNwbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICBldmVudFR5cGUgPSBldmVudC5zcGxpdChcIi5cIilbMF07XG5cbiAgICBldmVudCA9IGRvYy5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuXG4gICAgcmV0dXJuIGpCb25lLmV4dGVuZChldmVudCwge1xuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgfSwgZGF0YSk7XG59O1xuXG5qQm9uZS5ldmVudCA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uKGVsLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpCb25lLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGVsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2ZW50cywgZXZlbnRUeXBlLCB0LCBldmVudDtcblxuICAgICAgICBqQm9uZS5zZXRJZChlbCk7XG4gICAgICAgIGV2ZW50cyA9IGpCb25lLmdldERhdGEoZWwpLmV2ZW50cztcblxuICAgICAgICB0eXBlcyA9IHR5cGVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgICAgZXZlbnQgPSB0eXBlc1t0XTtcblxuICAgICAgICAgICAgZXZlbnRUeXBlID0gZXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50VHlwZV0gPSBldmVudHNbZXZlbnRUeXBlXSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCFldmVudHNbZXZlbnRUeXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50VHlwZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldmVudC5zcGxpdChcIi5cIikuc3BsaWNlKDEpLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIGZuOiBldmVudEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgb3JpZ2luZm46IGhhbmRsZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGVsID0gdGhpcyxcbiAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IGpCb25lLmdldERhdGEoZWwpLmV2ZW50c1tlLnR5cGVdLFxuICAgICAgICAgICAgbGVuZ3RoID0gaGFuZGxlclF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgIGV4cGVjdGVkVGFyZ2V0LFxuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgZXZlbnRPcHRpb25zO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV2ZW50T3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJRdWV1ZVtpXTtcbiAgICAgICAgICAgIGhhbmRsZXIuZGF0YSAmJiAoZXZlbnRPcHRpb25zLmRhdGEgPSBoYW5kbGVyLmRhdGEpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQm9uZUV2ZW50KGUsIGV2ZW50T3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShlLm5hbWVzcGFjZSAmJiBlLm5hbWVzcGFjZSAhPT0gaGFuZGxlci5uYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub3JpZ2luZm4uY2FsbChlbCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAofmpCb25lKGVsKS5maW5kKGhhbmRsZXIuc2VsZWN0b3IpLmluZGV4T2YoZS50YXJnZXQpIHx8IChleHBlY3RlZFRhcmdldCA9IGpCb25lLmNvbnRhaW5zKGpCb25lKGVsKS5maW5kKGhhbmRsZXIuc2VsZWN0b3IpLCBlLnRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRUYXJnZXQgPSBleHBlY3RlZFRhcmdldCB8fCBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBldmVudE9wdGlvbnMuY3VycmVudFRhcmdldCA9IGV4cGVjdGVkVGFyZ2V0O1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEJvbmVFdmVudChlLCBldmVudE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UgIT09IGhhbmRsZXIubmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm9yaWdpbmZuLmNhbGwoZXhwZWN0ZWRUYXJnZXQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mbi5vbiA9IGZ1bmN0aW9uKHR5cGVzKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgaGFuZGxlciA9IHNsaWNlLmNhbGwoYXJncywgLTEpWzBdLFxuICAgICAgICBzZWxlY3RvciwgZGF0YTtcblxuICAgIC8vIC5vbignY2xpY2snLCAnLnNlbGVjdG9yJywgZnVuY3Rpb24oKSB7fSlcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgaXNTdHJpbmcoYXJnc1sxXSkpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBhcmdzWzFdO1xuICAgIH1cbiAgICAvLyAub24oJ2NsaWNrJywgeyBrZXk6IHZhbHVlIH0sIGZ1bmN0aW9uKCkge30pXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgaXNPYmplY3QoYXJnc1sxXSkpIHtcbiAgICAgICAgZGF0YSA9IGFyZ3NbMV07XG4gICAgfVxuICAgIC8vIC5vbignY2xpY2snLCAnLnNlbGVjdG9yJywgeyBrZXk6IHZhbHVlIH0sIGZ1bmN0aW9uKCkge30pXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBhcmdzWzFdO1xuICAgICAgICBkYXRhID0gYXJnc1syXTtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGpCb25lLmV2ZW50LmFkZCh0aGlzW2ldLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4ub25lID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBvbmVBcmdzID0gc2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpLFxuICAgICAgICBjYWxsYmFjayA9IHNsaWNlLmNhbGwoYXJncywgLTEpWzBdLFxuICAgICAgICBhZGRMaXN0ZW5lcjtcblxuICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyICRlbCA9ICBqQm9uZShlbCk7XG5cbiAgICAgICAgZXZlbnQuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAkZWwub2ZmKGV2ZW50LCBmbik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbCwgZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkZWwub24uYXBwbHkoJGVsLCBbZXZlbnRdLmNvbmNhdChvbmVBcmdzLCBmbikpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhZGRMaXN0ZW5lcih0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnRyaWdnZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBldmVudHMgPSBbXSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBkaXNwYXRjaEV2ZW50cztcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKGV2ZW50KSkge1xuICAgICAgICBldmVudHMgPSBldmVudC5zcGxpdChcIiBcIikubWFwKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gakJvbmUuRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IGV2ZW50IGluc3RhbmNlb2YgRXZlbnQgPyBldmVudCA6IGpCb25lLkV2ZW50KGV2ZW50KTtcbiAgICAgICAgZXZlbnRzID0gW2V2ZW50XTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaEV2ZW50cyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQgJiYgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpc3BhdGNoRXZlbnRzKHRoaXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4ub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudHMsIGV2ZW50VHlwZSwgaW5kZXgsIGVsLCBlKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIGdldCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKChmbiAmJiBlLm9yaWdpbmZuID09PSBmbikgfHwgIWZuKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlLmZuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnRzW2V2ZW50VHlwZV1baW5kZXhdLmZuID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaGFuZGxlciBmcm9tIGNhY2hlXG4gICAgICAgICAgICAgICAgakJvbmUuX2NhY2hlLmV2ZW50c1tqQm9uZS5nZXREYXRhKGVsKS5qaWRdW2V2ZW50VHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzLCBuYW1lc3BhY2UsIHJlbW92ZUxpc3RlbmVycywgZXZlbnRUeXBlO1xuXG4gICAgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGwsIGV2ZW50c0J5VHlwZSwgZTtcblxuICAgICAgICBldmVudHMgPSBqQm9uZS5nZXREYXRhKGVsKS5ldmVudHM7XG5cbiAgICAgICAgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzXG4gICAgICAgIGlmICghZXZlbnQgJiYgZXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24oZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzQnlUeXBlID0gZXZlbnRzW2V2ZW50VHlwZV07XG4gICAgICAgICAgICAgICAgbCA9IGV2ZW50c0J5VHlwZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZShsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBldmVudFR5cGUsIGwsIGVsLCBldmVudHNCeVR5cGVbbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IGV2ZW50LnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IGV2ZW50LnNwbGl0KFwiLlwiKS5zcGxpY2UoMSkuam9pbihcIi5cIik7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBuYW1lZCBldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudHNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIGV2ZW50c0J5VHlwZSA9IGV2ZW50c1tldmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIGwgPSBldmVudHNCeVR5cGUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUobC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBldmVudHNCeVR5cGVbbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZXNwYWNlIHx8IChuYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgZXZlbnRUeXBlLCBsLCBlbCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIG5hbWVzcGFjZWQgZXZlbnRzXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBrZXlzKGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbihldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzQnlUeXBlID0gZXZlbnRzW2V2ZW50VHlwZV07XG4gICAgICAgICAgICAgICAgICAgIGwgPSBldmVudHNCeVR5cGUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGwtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGV2ZW50c0J5VHlwZVtsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZS5zcGxpdChcIi5cIilbMF0gPT09IG5hbWVzcGFjZS5zcGxpdChcIi5cIilbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihldmVudHMsIGV2ZW50VHlwZSwgbCwgZWwsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgZmluZGVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGVsLnF1ZXJ5U2VsZWN0b3JBbGwpKSB7XG4gICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBmaW5kZXIodGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpCb25lKHJlc3VsdHMpO1xufTtcblxuZm4uZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggIT0gbnVsbCA/XG5cbiAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAgICAoaW5kZXggPCAwID8gdGhpc1tpbmRleCArIHRoaXMubGVuZ3RoXSA6IHRoaXNbaW5kZXhdKSA6XG5cbiAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuICAgICAgICBzbGljZS5jYWxsKHRoaXMpO1xufTtcblxuZm4uZXEgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiBqQm9uZSh0aGlzW2luZGV4XSk7XG59O1xuXG5mbi5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF+cmVzdWx0cy5pbmRleE9mKHBhcmVudCA9IHRoaXNbaV0ucGFyZW50RWxlbWVudCkgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqQm9uZShyZXN1bHRzKTtcbn07XG5cbmZuLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbCh0aGlzKTtcbn07XG5cbmZuLmlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGFyZ3NbMF07XG4gICAgfSk7XG59O1xuXG5mbi5oYXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoYXJnc1swXSkubGVuZ3RoO1xuICAgIH0pO1xufTtcblxuZm4uYWRkID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgIGpCb25lLnVuaXF1ZShcbiAgICAgICAgICAgIGpCb25lLm1lcmdlKHRoaXMuZ2V0KCksIGpCb25lKHNlbGVjdG9yLCBjb250ZXh0KSlcbiAgICAgICAgKVxuICAgICk7XG59O1xuXG5mbi5hdHRyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIHNldHRlcjtcblxuICAgIGlmIChpc1N0cmluZyhrZXkpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdICYmIHRoaXNbMF0uZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBrZXlzKGtleSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNldHRlcih0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnJlbW92ZUF0dHIgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4udmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgdGhpc1swXS52YWx1ZTtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLmNzcyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBzZXR0ZXI7XG5cbiAgICAvLyBHZXQgYXR0cmlidXRlXG4gICAgaWYgKGlzU3RyaW5nKGtleSkgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgd2luLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSlba2V5XTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYXR0cmlidXRlc1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgZWwuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAga2V5cyhrZXkpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZXR0ZXIodGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mbi5kYXRhID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLCBkYXRhID0ge30sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgc2V0dGVyLFxuICAgICAgICBzZXRWYWx1ZSA9IGZ1bmN0aW9uKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZWwuamRhdGEgPSBlbC5qZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICBlbC5qZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmRhdGFzZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIEdldCBhbGwgZGF0YVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzWzBdLmpkYXRhICYmIChkYXRhID0gdGhpc1swXS5qZGF0YSk7XG5cbiAgICAgICAga2V5cyh0aGlzWzBdLmRhdGFzZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSBnZXRWYWx1ZSh0aGlzWzBdLmRhdGFzZXRba2V5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvLyBHZXQgZGF0YSBieSBuYW1lXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgZ2V0VmFsdWUodGhpc1swXS5kYXRhc2V0W2tleV0gfHwgdGhpc1swXS5qZGF0YSAmJiB0aGlzWzBdLmpkYXRhW2tleV0pO1xuICAgIH1cblxuICAgIC8vIFNldCBkYXRhXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGtleXMoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShlbCwgbmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlKGVsLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNldHRlcih0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnJlbW92ZURhdGEgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBqZGF0YSwgZGF0YXNldDtcblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgamRhdGEgPSB0aGlzW2ldLmpkYXRhO1xuICAgICAgICBkYXRhc2V0ID0gdGhpc1tpXS5kYXRhc2V0O1xuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGpkYXRhICYmIGpkYXRhW2tleV0gJiYgZGVsZXRlIGpkYXRhW2tleV07XG4gICAgICAgICAgICBkZWxldGUgZGF0YXNldFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gamRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgamRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZGF0YXNldCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhc2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLmFkZENsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGogPSAwO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGogPSAwO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBmb3JjZSkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIG1ldGhvZCA9IFwidG9nZ2xlXCI7XG5cbiAgICBmb3JjZSA9PT0gdHJ1ZSAmJiAobWV0aG9kID0gXCJhZGRcIikgfHwgZm9yY2UgPT09IGZhbHNlICYmIChtZXRob2QgPSBcInJlbW92ZVwiKTtcblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXS5jbGFzc0xpc3RbbWV0aG9kXShjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4uaGFzQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mbi5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgZWw7XG5cbiAgICAvLyBhZGQgSFRNTCBpbnRvIGVsZW1lbnRzXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICAvLyBnZXQgSFRNTCBmcm9tIGVsZW1lbnRcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCAmJiAoZWwgPSB0aGlzWzBdKSkge1xuICAgICAgICByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4uYXBwZW5kID0gZnVuY3Rpb24oYXBwZW5kZWQpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBzZXR0ZXI7XG5cbiAgICAvLyBjcmVhdGUgakJvbmUgb2JqZWN0IGFuZCB0aGVuIGFwcGVuZFxuICAgIGlmIChpc1N0cmluZyhhcHBlbmRlZCkgJiYgcnF1aWNrRXhwci5leGVjKGFwcGVuZGVkKSkge1xuICAgICAgICBhcHBlbmRlZCA9IGpCb25lKGFwcGVuZGVkKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHRleHQgbm9kZSBmb3IgaW5zZXJ0aW5nXG4gICAgZWxzZSBpZiAoIWlzT2JqZWN0KGFwcGVuZGVkKSkge1xuICAgICAgICBhcHBlbmRlZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFwcGVuZGVkKTtcbiAgICB9XG5cbiAgICBhcHBlbmRlZCA9IGFwcGVuZGVkIGluc3RhbmNlb2YgakJvbmUgPyBhcHBlbmRlZCA6IGpCb25lKGFwcGVuZGVkKTtcblxuICAgIHNldHRlciA9IGZ1bmN0aW9uKGVsLCBpKSB7XG4gICAgICAgIGFwcGVuZGVkLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZXR0ZXIodGhpc1tpXSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mbi5hcHBlbmRUbyA9IGZ1bmN0aW9uKHRvKSB7XG4gICAgakJvbmUodG8pLmFwcGVuZCh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZm4uZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBlbDtcblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWwgPSB0aGlzW2ldO1xuXG4gICAgICAgIHdoaWxlIChlbC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZuLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGVsO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBsaXN0bmVyc1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsID0gdGhpc1tpXTtcblxuICAgICAgICAvLyByZW1vdmUgZGF0YSBhbmQgbm9kZXNcbiAgICAgICAgZGVsZXRlIGVsLmpkYXRhO1xuICAgICAgICBlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIC8vIEV4cG9zZSBqQm9uZSBhcyBtb2R1bGUuZXhwb3J0cyBpbiBsb2FkZXJzIHRoYXQgaW1wbGVtZW50IHRoZSBOb2RlXG4gICAgLy8gbW9kdWxlIHBhdHRlcm4gKGluY2x1ZGluZyBicm93c2VyaWZ5KS4gRG8gbm90IGNyZWF0ZSB0aGUgZ2xvYmFsLCBzaW5jZVxuICAgIC8vIHRoZSB1c2VyIHdpbGwgYmUgc3RvcmluZyBpdCB0aGVtc2VsdmVzIGxvY2FsbHksIGFuZCBnbG9iYWxzIGFyZSBmcm93bmVkXG4gICAgLy8gdXBvbiBpbiB0aGUgTm9kZSBtb2R1bGUgd29ybGQuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqQm9uZTtcbn1cbi8vIFJlZ2lzdGVyIGFzIGEgQU1EIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBqQm9uZTtcbiAgICB9KTtcblxuICAgIHdpbi5qQm9uZSA9IHdpbi4kID0gakJvbmU7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW4gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHdpbi5kb2N1bWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIHdpbi5qQm9uZSA9IHdpbi4kID0gakJvbmU7XG59XG5cbn0od2luZG93KSk7XG4iLCJ2YXIga29hbGFqcyA9IHt9O1xuXG4vLyBwYXNzIGFuIGFsdGVybmF0aXZlIGRlZmF1bHQgdmFsdWVcbmtvYWxhanMuZCA9IGtvYWxhanMuZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gZGVmYXVsdFZhbHVlKG9iaiwgZGVmVmFsdWUpIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGRlZlZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLy8gYWxpYXMgZm9yIGdldEVsZW1lbnRCeUlkXG5rb2FsYWpzLmlkID0gZnVuY3Rpb24gbWsoZWwpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKTtcbn07XG5cbi8vIGFsaWFzIGZvciBjcmVhdGVFbGVtZW50XG5rb2FsYWpzLm1rID0gZnVuY3Rpb24gbWsoZWwpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwpO1xufTtcblxuaWYgKG1vZHVsZSAhPT0gdW5kZWZpbmVkICYmIG1vZHVsZS5leHBvcnRzICE9PSB1bmRlZmluZWQpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBrb2FsYWpzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvbWVudWJ1aWxkZXJcIik7XG4iLCJ2YXIgTWVudUJ1aWxkZXIsIGpib25lLCB2aWV3O1xuXG5qYm9uZSA9IHJlcXVpcmUoXCJqYm9uZVwiKTtcbnZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtdmlld2pcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVudUJ1aWxkZXIgPSB2aWV3LmV4dGVuZCh7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMubmFtZSA9IG9wdHMubmFtZSB8fCBcIlwiO1xuICAgIHRoaXMuZWwuY2xhc3NOYW1lICs9IFwic21lbnViYXJcIjtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIHJlbW92ZSBhbGwgY2hpbGRzXG4gICAgdmFyIGZjID0gdGhpcy5lbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChmYykge1xuICAgICAgdGhpcy5lbC5yZW1vdmVDaGlsZChmYyk7XG4gICAgICBmYyA9IHRoaXMuZWwuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIGNoaWxkXG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkRE9NKCkpO1xuICB9LFxuICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfSxcbiAgYWRkTm9kZTogZnVuY3Rpb24obGFiZWwsIGNhbGxiYWNrLCBvcHRzKSB7XG4gICAgdmFyIHN0eWxlO1xuICAgIGlmIChvcHRzICE9IG51bGwpIHtcbiAgICAgIHN0eWxlID0gb3B0cy5zdHlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25vZGVzID09IG51bGwpIHtcbiAgICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuX25vZGVzLnB1c2goe1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0Tm9kZTogZnVuY3Rpb24obGFiZWwpIHtcbiAgICB2YXIgck5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgaWYgKGVsLmxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICByTm9kZSA9IGVsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByTm9kZTtcbiAgfSxcblxuICBtb2RpZnlOb2RlOiBmdW5jdGlvbihsYWJlbCwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShsYWJlbCk7XG4gICAgbm9kZS5jYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vZGUuY2FsbGJhY2s7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgbm9kZS5zdHlsZSA9IG9wdHMuc3R5bGUgfHwgbm9kZS5zdHlsZTtcbiAgfSxcblxuICByZW5hbWVOb2RlOiBmdW5jdGlvbihsYWJlbCwgbmV3TGFiZWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShsYWJlbCk7XG4gICAgbm9kZS5sYWJlbCA9IG5ld0xhYmVsIHx8IG5vZGUubGFiZWw7XG4gIH0sXG5cbiAgcmVtb3ZlTm9kZTogZnVuY3Rpb24obGFiZWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShsYWJlbCk7XG4gICAgdGhpcy5fbm9kZXMuc3BsaWNlKHRoaXMuX25vZGVzLmluZGV4T2Yobm9kZSksIDEpO1xuICB9LFxuXG4gIHJlbW92ZUFsbE5vZGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICB9LFxuXG4gIGJ1aWxkRE9NOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5fYnVpbGRNKHtcbiAgICAgIG5vZGVzOiB0aGlzLl9ub2RlcyxcbiAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3BhbjtcbiAgfSxcbiAgX2J1aWxkTTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBkaXNwbGF5ZWRCdXR0b24sIGZyYWcsIGtleSwgbGksIG5vZGUsIHN0eWxlLCBfcmVmO1xuICAgIHZhciBub2RlcyA9IGRhdGEubm9kZXM7XG4gICAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdmFyIG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG1lbnUuY2xhc3NOYW1lID0gXCJzbWVudS1kcm9wZG93biBzbWVudS1kcm9wZG93bi10aXBcIjtcbiAgICBtZW51LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIHZhciBtZW51VWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgbWVudVVsLmNsYXNzTmFtZSA9IFwic21lbnUtZHJvcGRvd24tbWVudVwiO1xuXG4gICAgLy8gY3VycmVudGx5IHdlIHN1cHBvcnQgb25lLWxldmVsXG4gICAgZm9yICh2YXIgaSA9IDAsIF9sZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgbGkudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xuICAgICAgX3JlZiA9IG5vZGUuc3R5bGU7XG4gICAgICBmb3IgKGtleSBpbiBfcmVmKSB7XG4gICAgICAgIHN0eWxlID0gX3JlZltrZXldO1xuICAgICAgICBsaS5zdHlsZVtrZXldID0gc3R5bGU7XG4gICAgICB9XG4gICAgICBsaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbm9kZS5jYWxsYmFjayk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJuZXc6bm9kZVwiLCBsaSk7XG4gICAgICBtZW51VWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoXCJuZXc6bWVudVwiLCBtZW51VWwpO1xuICAgIG1lbnUuYXBwZW5kQ2hpbGQobWVudVVsKTtcblxuICAgIGRpc3BsYXllZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGRpc3BsYXllZEJ1dHRvbi50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgZGlzcGxheWVkQnV0dG9uLmNsYXNzTmFtZSA9IFwic21lbnViYXJfYWxpbmtcIjtcbiAgICB0aGlzLnRyaWdnZXIoXCJuZXc6YnV0dG9uXCIsIGRpc3BsYXllZEJ1dHRvbik7XG5cbiAgICAvLyBIQUNLIHRvIGJlIGFibGUgdG8gaGlkZSB0aGUgc3VibWVudVxuICAgIC8vIGxpc3RlbnMgZ2xvYmFsbHkgZm9yIGNsaWNrIGV2ZW50c1xuICAgIGpib25lKGRpc3BsYXllZEJ1dHRvbikub24oXCJjbGlja1wiLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIF90aGlzLl9zaG93TWVudShlLCBtZW51LCBkaXNwbGF5ZWRCdXR0b24pO1xuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpib25lKGRvY3VtZW50LmJvZHkpLm9uZShcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW51LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNSk7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKTtcblxuICAgIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChtZW51KTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKGRpc3BsYXllZEJ1dHRvbik7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGRpc3BsYXkgdGhlIGxvd2VyIG1lbnUgb24gYSBjbGlja1xuICBfc2hvd01lbnU6IGZ1bmN0aW9uKGUsIG1lbnUsIHRhcmdldCkge1xuICAgIHZhciByZWN0O1xuICAgIG1lbnUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBtZW51LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbWVudS5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgIG1lbnUuc3R5bGUudG9wID0gKHJlY3QudG9wICsgdGFyZ2V0Lm9mZnNldEhlaWdodCkgKyBcInB4XCI7XG4gIH1cbn0pO1xuIiwidmFyIE1vdXNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlID0ge1xuICByZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbW91c2VYLCBtb3VzZVksIHJlY3QsIHRhcmdldDtcbiAgICBtb3VzZVggPSBlLm9mZnNldFg7XG4gICAgbW91c2VZID0gZS5vZmZzZXRZO1xuICAgIGlmIChtb3VzZVggPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgaWYgKG1vdXNlWCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW91c2VYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICBtb3VzZVkgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZVggPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1vdXNlWCA9IGUucGFnZVggLSB0YXJnZXQub2Zmc2V0TGVmdDtcbiAgICAgICAgbW91c2VZID0gZS5wYWdlWSAtIHRhcmdldC5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VYID09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhlLCBcIm5vIG1vdXNlIGV2ZW50IGRlZmluZWQuIHlvdXIgYnJvd3NlciBzdWNrc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21vdXNlWCwgbW91c2VZXTtcbiAgfSxcbiAgYWJzOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlWCwgbW91c2VZO1xuICAgIG1vdXNlWCA9IGUucGFnZVg7XG4gICAgbW91c2VZID0gZS5wYWdlWTtcbiAgICBpZiAobW91c2VYID09IHVuZGVmaW5lZCkge1xuICAgICAgbW91c2VYID0gZS5sYXllclg7XG4gICAgICBtb3VzZVkgPSBlLmxheWVyWTtcbiAgICB9XG4gICAgaWYgKG1vdXNlWCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IGUuY2xpZW50WTtcbiAgICB9XG4gICAgaWYgKG1vdXNlWCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vdXNlWCA9IGUueDtcbiAgICAgIG1vdXNlWSA9IGUueTtcbiAgICB9XG4gICAgcmV0dXJuIFttb3VzZVgsIG1vdXNlWV07XG4gIH0sXG4gIHdoZWVsRGVsdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZGVsdGE7XG4gICAgZGVsdGEgPSBbZS5kZWx0YVgsIGUuZGVsdGFZXTtcbiAgICBpZiAoZGVsdGFbMF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIGEgbW9yZSBkZXRhaWxlZCBzY3JvbGwgc2Vuc29yIC0gdXNlIGl0XG4gICAgICBpZiAoZS5tb3pNb3ZlbWVudFgpIHtcbiAgICAgICAgZGVsdGEgPSBbMCwgZS5tb3pNb3ZlbWVudFhdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzYWZldHkgZmlyc3RcbiAgICBpZiAoaXNOYU4oZGVsdGFbMF0pKSB7XG4gICAgICBkZWx0YVswXSA9IDA7XG4gICAgfVxuICAgIGlmIChpc05hTihkZWx0YVsxXSkpIHtcbiAgICAgIGRlbHRhWzFdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEE6IFwiIzAwYTM1Y1wiLFxuICBSOiBcIiMwMGZjMDNcIixcbiAgTjogXCIjMDBlYjE0XCIsXG4gIEQ6IFwiIzAwZWIxNFwiLFxuICBDOiBcIiMwMDAwZmZcIixcbiAgUTogXCIjMDBmMTBlXCIsXG4gIEU6IFwiIzAwZjEwZVwiLFxuICBHOiBcIiMwMDlkNjJcIixcbiAgSDogXCIjMDBkNTJhXCIsXG4gIEk6IFwiIzAwNTRhYlwiLFxuICBMOiBcIiMwMDdiODRcIixcbiAgSzogXCIjMDBmZjAwXCIsXG4gIE06IFwiIzAwOTc2OFwiLFxuICBGOiBcIiMwMDg3NzhcIixcbiAgUDogXCIjMDBlMDFmXCIsXG4gIFM6IFwiIzAwZDUyYVwiLFxuICBUOiBcIiMwMGRiMjRcIixcbiAgVzogXCIjMDBhODU3XCIsXG4gIFk6IFwiIzAwZTYxOVwiLFxuICBWOiBcIiMwMDVmYTBcIixcbiAgQjogXCIjMDBlYjE0XCIsXG4gIFg6IFwiIzAwYjY0OVwiLFxuICBaOiBcIiMwMGYxMGVcIlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiNCQkJCQkJcIixcbiAgQjogXCJncmV5XCIsXG4gIEM6IFwieWVsbG93XCIsXG4gIEQ6IFwicmVkXCIsXG4gIEU6IFwicmVkXCIsXG4gIEY6IFwibWFnZW50YVwiLFxuICBHOiBcImJyb3duXCIsXG4gIEg6IFwiIzAwRkZGRlwiLFxuICBJOiBcIiNCQkJCQkJcIixcbiAgSjogXCIjZmZmXCIsXG4gIEs6IFwiIzAwRkZGRlwiLFxuICBMOiBcIiNCQkJCQkJcIixcbiAgTTogXCIjQkJCQkJCXCIsXG4gIE46IFwiZ3JlZW5cIixcbiAgTzogXCIjZmZmXCIsXG4gIFA6IFwiYnJvd25cIixcbiAgUTogXCJncmVlblwiLFxuICBSOiBcIiMwMEZGRkZcIixcbiAgUzogXCJncmVlblwiLFxuICBUOiBcImdyZWVuXCIsXG4gIFU6IFwiI2ZmZlwiLFxuICBWOiBcIiNCQkJCQkJcIixcbiAgVzogXCJtYWdlbnRhXCIsXG4gIFg6IFwiZ3JleVwiLFxuICBZOiBcIm1hZ2VudGFcIixcbiAgWjogXCJncmV5XCIsXG4gIEdhcDogXCJncmV5XCJcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQTogXCJvcmFuZ2VcIixcbiAgQjogXCIjZmZmXCIsXG4gIEM6IFwiZ3JlZW5cIixcbiAgRDogXCJyZWRcIixcbiAgRTogXCJyZWRcIixcbiAgRjogXCJibHVlXCIsXG4gIEc6IFwib3JhbmdlXCIsXG4gIEg6IFwicmVkXCIsXG4gIEk6IFwiZ3JlZW5cIixcbiAgSjogXCIjZmZmXCIsXG4gIEs6IFwicmVkXCIsXG4gIEw6IFwiZ3JlZW5cIixcbiAgTTogXCJncmVlblwiLFxuICBOOiBcIiNmZmZcIixcbiAgTzogXCIjZmZmXCIsXG4gIFA6IFwib3JhbmdlXCIsXG4gIFE6IFwiI2ZmZlwiLFxuICBSOiBcInJlZFwiLFxuICBTOiBcIm9yYW5nZVwiLFxuICBUOiBcIm9yYW5nZVwiLFxuICBVOiBcIiNmZmZcIixcbiAgVjogXCJncmVlblwiLFxuICBXOiBcImJsdWVcIixcbiAgWDogXCIjZmZmXCIsXG4gIFk6IFwiYmx1ZVwiLFxuICBaOiBcIiNmZmZcIixcbiAgR2FwOiBcIiNmZmZcIlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiM4MGEwZjBcIixcbiAgUjogXCIjZjAxNTA1XCIsXG4gIE46IFwiIzAwZmYwMFwiLFxuICBEOiBcIiNjMDQ4YzBcIixcbiAgQzogXCIjZjA4MDgwXCIsXG4gIFE6IFwiIzAwZmYwMFwiLFxuICBFOiBcIiNjMDQ4YzBcIixcbiAgRzogXCIjZjA5MDQ4XCIsXG4gIEg6IFwiIzE1YTRhNFwiLFxuICBJOiBcIiM4MGEwZjBcIixcbiAgTDogXCIjODBhMGYwXCIsXG4gIEs6IFwiI2YwMTUwNVwiLFxuICBNOiBcIiM4MGEwZjBcIixcbiAgRjogXCIjODBhMGYwXCIsXG4gIFA6IFwiI2ZmZmYwMFwiLFxuICBTOiBcIiMwMGZmMDBcIixcbiAgVDogXCIjMDBmZjAwXCIsXG4gIFc6IFwiIzgwYTBmMFwiLFxuICBZOiBcIiMxNWE0YTRcIixcbiAgVjogXCIjODBhMGYwXCIsXG4gIEI6IFwiI2ZmZlwiLFxuICBYOiBcIiNmZmZcIixcbiAgWjogXCIjZmZmXCJcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQTogXCIjZTcxOGU3XCIsXG4gIFI6IFwiIzZmOTA2ZlwiLFxuICBOOiBcIiMxYmU0MWJcIixcbiAgRDogXCIjNzc4ODc3XCIsXG4gIEM6IFwiIzIzZGMyM1wiLFxuICBROiBcIiM5MjZkOTJcIixcbiAgRTogXCIjZmYwMGZmXCIsXG4gIEc6IFwiIzAwZmYwMFwiLFxuICBIOiBcIiM3NThhNzVcIixcbiAgSTogXCIjOGE3NThhXCIsXG4gIEw6IFwiI2FlNTFhZVwiLFxuICBLOiBcIiNhMDVmYTBcIixcbiAgTTogXCIjZWYxMGVmXCIsXG4gIEY6IFwiIzk4Njc5OFwiLFxuICBQOiBcIiMwMGZmMDBcIixcbiAgUzogXCIjMzZjOTM2XCIsXG4gIFQ6IFwiIzQ3Yjg0N1wiLFxuICBXOiBcIiM4YTc1OGFcIixcbiAgWTogXCIjMjFkZTIxXCIsXG4gIFY6IFwiIzg1N2E4NVwiLFxuICBCOiBcIiM0OWI2NDlcIixcbiAgWDogXCIjNzU4YTc1XCIsXG4gIFo6IFwiI2M5MzZjOVwiXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEE6IFwiI2FkMDA1MlwiLFxuICBCOiBcIiMwYzAwZjNcIixcbiAgQzogXCIjYzIwMDNkXCIsXG4gIEQ6IFwiIzBjMDBmM1wiLFxuICBFOiBcIiMwYzAwZjNcIixcbiAgRjogXCIjY2IwMDM0XCIsXG4gIEc6IFwiIzZhMDA5NVwiLFxuICBIOiBcIiMxNTAwZWFcIixcbiAgSTogXCIjZmYwMDAwXCIsXG4gIEo6IFwiI2ZmZlwiLFxuICBLOiBcIiMwMDAwZmZcIixcbiAgTDogXCIjZWEwMDE1XCIsXG4gIE06IFwiI2IwMDA0ZlwiLFxuICBOOiBcIiMwYzAwZjNcIixcbiAgTzogXCIjZmZmXCIsXG4gIFA6IFwiIzQ2MDBiOVwiLFxuICBROiBcIiMwYzAwZjNcIixcbiAgUjogXCIjMDAwMGZmXCIsXG4gIFM6IFwiIzVlMDBhMVwiLFxuICBUOiBcIiM2MTAwOWVcIixcbiAgVTogXCIjZmZmXCIsXG4gIFY6IFwiI2Y2MDAwOVwiLFxuICBXOiBcIiM1YjAwYTRcIixcbiAgWDogXCIjNjgwMDk3XCIsXG4gIFk6IFwiIzRmMDBiMFwiLFxuICBaOiBcIiMwYzAwZjNcIlxufTtcbiIsInZhciBzY2hlbWVzID0gcmVxdWlyZShcIi4vc2NoZW1lY2xhc3NcIik7XG52YXIgU3RhdGljU2NoZW1lQ2xhc3MgPSBzY2hlbWVzLnN0YXQ7XG52YXIgRHluU2NoZW1lQ2xhc3MgPSBzY2hlbWVzLmR5bjtcblxudmFyIEJ1cmllZCA9IHJlcXVpcmUoXCIuL2J1cmllZFwiKTtcbnZhciBDaW5lbWEgPSByZXF1aXJlKFwiLi9jaW5lbWFcIik7XG52YXIgQ2x1c3RhbCA9IHJlcXVpcmUoXCIuL2NsdXN0YWxcIik7XG52YXIgQ2x1c3RhbDIgPSByZXF1aXJlKFwiLi9jbHVzdGFsMlwiKTtcbnZhciBIZWxpeCA9IHJlcXVpcmUoXCIuL2hlbGl4XCIpO1xudmFyIEh5ZHJvID0gcmVxdWlyZShcIi4vaHlkcm9waG9iaWNpdHlcIik7XG52YXIgTGVzayA9IHJlcXVpcmUoXCIuL2xlc2tcIik7XG52YXIgTWFlID0gcmVxdWlyZShcIi4vbWFlXCIpO1xudmFyIE51Y2xlb3RpZGUgPSByZXF1aXJlKFwiLi9udWNsZW90aWRlXCIpO1xudmFyIFB1cmluZSA9IHJlcXVpcmUoXCIuL3B1cmluZVwiKTtcbnZhciBTdHJhbmQgPSByZXF1aXJlKFwiLi9zdHJhbmRcIik7XG52YXIgVGF5bG9yID0gcmVxdWlyZShcIi4vdGF5bG9yXCIpO1xudmFyIFR1cm4gPSByZXF1aXJlKFwiLi90dXJuXCIpO1xudmFyIFphcHBvID0gcmVxdWlyZShcIi4vemFwcG9cIik7XG5cbnZhciBzdGF0aWNTY2hlbWVzID0ge1xuICBidXJpZWQ6IEJ1cmllZCxcbiAgYnVyaWVkX2luZGV4OiBCdXJpZWQsXG4gIGNpbmVtYTogQ2luZW1hLFxuICBjbHVzdGFsMjogQ2x1c3RhbDIsXG4gIGNsdXN0YWw6IENsdXN0YWwsXG4gIGhlbGl4OiBIZWxpeCxcbiAgaGVsaXhfcHJvcGVuc2l0eTogSGVsaXgsXG4gIGh5ZHJvOiBIeWRybyxcbiAgbGVzazogTGVzayxcbiAgbWFlOiBNYWUsXG4gIG51Y2xlb3RpZGU6IE51Y2xlb3RpZGUsXG4gIHB1cmluZTogUHVyaW5lLFxuICBwdXJpbmVfcHlyaW1pZGluZTogUHVyaW5lLFxuICBzdHJhbmQ6IFN0cmFuZCxcbiAgc3RyYW5kX3Byb3BlbnNpdHk6IFN0cmFuZCxcbiAgdGF5bG9yOiBUYXlsb3IsXG4gIHR1cm46IFR1cm4sXG4gIHR1cm5fcHJvcGVuc2l0eTogVHVybixcbiAgemFwcG86IFphcHBvXG59O1xuXG52YXIgcGlkID0gcmVxdWlyZShcIi4vcGlkX2NvbG9ycy5qc1wiKTtcblxudmFyIGR5blNjaGVtZXMgPSB7XG4gIHBpZDogcGlkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9ycyA9IGZ1bmN0aW9uKG9wdCl7XG4gIHRoaXMubWFwcyA9IGNsb25lKHN0YXRpY1NjaGVtZXMpOyAgXG4gIHRoaXMuZHluID0gY2xvbmUoZHluU2NoZW1lcyk7XG4gIHRoaXMub3B0ID0gb3B0O1xufVxuQ29sb3JzLmdldFNjaGVtZSA9IGZ1bmN0aW9uKHNjaGVtZSl7XG4gIHJldHVybiBzdGF0aWNTY2hlbWVzW3NjaGVtZV07XG59XG5Db2xvcnMucHJvdG90eXBlLmdldFNjaGVtZSA9IGZ1bmN0aW9uKHNjaGVtZSkge1xuICB2YXIgY29sb3IgPSB0aGlzLm1hcHNbc2NoZW1lXTtcbiAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICBjb2xvciA9IHt9O1xuICAgIGlmKHRoaXMuZHluW3NjaGVtZV0gIT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBuZXcgRHluU2NoZW1lQ2xhc3ModGhpcy5keW5bc2NoZW1lXSx0aGlzLm9wdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgU3RhdGljU2NoZW1lQ2xhc3MoY29sb3IpO1xufTtcblxuQ29sb3JzLnByb3RvdHlwZS5hZGRTdGF0aWNTY2hlbWUgPSBmdW5jdGlvbihuYW1lLHNjaGVtZSkge1xuICB0aGlzLm1hcHNbbmFtZV0gPSBzY2hlbWU7XG59XG5cbkNvbG9ycy5wcm90b3R5cGUuYWRkRHluU2NoZW1lID0gZnVuY3Rpb24obmFtZSxzY2hlbWUpIHtcbiAgdGhpcy5keW5bbmFtZV0gPSBzY2hlbWU7XG59XG5cbi8vIHNtYWxsIGhlbHBlciB0byBjbG9uZSBhbiBvYmplY3RcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuICB2YXIgY29weSA9IG9iai5jb25zdHJ1Y3RvcigpO1xuICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoYXR0cikpIGNvcHlbYXR0cl0gPSBvYmpbYXR0cl07XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQTogXCIgb3JhbmdlXCIsXG4gIEI6IFwiICNmZmZcIixcbiAgQzogXCIgZ3JlZW5cIixcbiAgRDogXCIgcmVkXCIsXG4gIEU6IFwiIHJlZFwiLFxuICBGOiBcIiBncmVlblwiLFxuICBHOiBcIiBvcmFuZ2VcIixcbiAgSDogXCIgbWFnZW50YVwiLFxuICBJOiBcIiBncmVlblwiLFxuICBKOiBcIiAjZmZmXCIsXG4gIEs6IFwiIHJlZFwiLFxuICBMOiBcIiBncmVlblwiLFxuICBNOiBcIiBncmVlblwiLFxuICBOOiBcIiBtYWdlbnRhXCIsXG4gIE86IFwiICNmZmZcIixcbiAgUDogXCIgZ3JlZW5cIixcbiAgUTogXCIgbWFnZW50YVwiLFxuICBSOiBcIiByZWRcIixcbiAgUzogXCIgb3JhbmdlXCIsXG4gIFQ6IFwiIG9yYW5nZVwiLFxuICBVOiBcIiAjZmZmXCIsXG4gIFY6IFwiIGdyZWVuXCIsXG4gIFc6IFwiIGdyZWVuXCIsXG4gIFg6IFwiICNmZmZcIixcbiAgWTogXCIgZ3JlZW5cIixcbiAgWjogXCIgI2ZmZlwiLFxuICBHYXA6IFwiICNmZmZcIlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiAjNzdkZDg4XCIsXG4gIEI6IFwiICNmZmZcIixcbiAgQzogXCIgIzk5ZWU2NlwiLFxuICBEOiBcIiAjNTViYjMzXCIsXG4gIEU6IFwiICM1NWJiMzNcIixcbiAgRjogXCIgIzk5OTlmZlwiLFxuICBHOiBcIiAjNzdkZDg4XCIsXG4gIEg6IFwiICM1NTU1ZmZcIixcbiAgSTogXCIgIzY2YmJmZlwiLFxuICBKOiBcIiAjZmZmXCIsXG4gIEs6IFwiICNmZmNjNzdcIixcbiAgTDogXCIgIzY2YmJmZlwiLFxuICBNOiBcIiAjNjZiYmZmXCIsXG4gIE46IFwiICM1NWJiMzNcIixcbiAgTzogXCIgI2ZmZlwiLFxuICBQOiBcIiAjZWVhYWFhXCIsXG4gIFE6IFwiICM1NWJiMzNcIixcbiAgUjogXCIgI2ZmY2M3N1wiLFxuICBTOiBcIiAjZmY0NDU1XCIsXG4gIFQ6IFwiICNmZjQ0NTVcIixcbiAgVTogXCIgI2ZmZlwiLFxuICBWOiBcIiAjNjZiYmZmXCIsXG4gIFc6IFwiICM5OTk5ZmZcIixcbiAgWDogXCIgI2ZmZlwiLFxuICBZOiBcIiAjOTk5OWZmXCIsXG4gIFo6IFwiICNmZmZcIixcbiAgR2FwOiBcIiAjZmZmXCJcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQTogXCIgIzY0RjczRlwiLFxuICBDOiBcIiAjRkZCMzQwXCIsXG4gIEc6IFwiICNFQjQxM0NcIixcbiAgVDogXCIgIzNDODhFRVwiLFxuICBVOiBcIiAjM0M4OEVFXCJcbn07XG4iLCJ2YXIgcGlkO1xubW9kdWxlLmV4cG9ydHMgPSBwaWQgPSB7fTtcblxuLy8gY2FsY3VsYXRpbmcgdGhlIGNvbnNlcnZhdGlvbiBpcyBleHBlbnNpdmUgXG4vLyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgb25jZVxucGlkLmluaXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbnMgPSB0aGlzLm9wdC5jb25zZXJ2YXRpb24oKTtcbn1cblxucGlkLnJ1biA9IGZ1bmN0aW9uKGxldHRlcixvcHRzKXtcbiAgdmFyIGNvbnMgPSB0aGlzLmNvbnNbb3B0cy5wb3NdO1xuICBpZihjb25zID4gMC44KXtcbiAgICByZXR1cm4gXCIjNjQ2NGZmXCI7XG4gIH1lbHNlIGlmKGNvbnMgPiAwLjYpe1xuICAgIHJldHVybiBcIiM5ZGE1ZmZcIjtcbiAgfWVsc2UgaWYoY29ucyA+IDAuNCl7XG4gICAgcmV0dXJuIFwiI2NjY2NjY1wiO1xuICB9ZWxzZXtcbiAgICByZXR1cm4gXCIjZmZmZmZmXCI7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiAjRkY4M0ZBXCIsXG4gIEM6IFwiICM0MEUwRDBcIixcbiAgRzogXCIgI0ZGODNGQVwiLFxuICBSOiBcIiAjRkY4M0ZBXCIsXG4gIFQ6IFwiICM0MEUwRDBcIixcbiAgVTogXCIgIzQwRTBEMFwiLFxuICBZOiBcIiAjNDBFMEQwXCJcbn07XG4iLCJ2YXIgU3RhdGljU2NoZW1lQ2xhc3MgPSBmdW5jdGlvbihtYXApe1xuICB0aGlzLmRlZmF1bHRDb2xvciA9IFwiI2ZmZmZmZlwiO1xuICB0aGlzLnR5cGUgPSBcInN0YXRpY1wiO1xuICB0aGlzLm1hcCA9IG1hcDtcbiAgdGhpcy5nZXRDb2xvciA9IGZ1bmN0aW9uKGxldHRlcil7XG4gICAgaWYodGhpcy5tYXBbbGV0dGVyXSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiB0aGlzLm1hcFtsZXR0ZXJdOyBcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDb2xvcjtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgRHluU2NoZW1lQ2xhc3MgPSBmdW5jdGlvbihmdW4sb3B0KXtcbiAgdGhpcy50eXBlID0gXCJkeW5cIjtcbiAgdGhpcy5vcHQgPSBvcHQ7XG4gIC8vIGluaXRcbiAgaWYoZnVuLmluaXQgIT09IHVuZGVmaW5lZCl7XG4gICAgZnVuLmluaXQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmdldENvbG9yID0gZnVuLnJ1bjtcbiAgICB0aGlzLnJlc2V0ID0gZnVuLmluaXQ7XG4gIH1lbHNle1xuICAgIHRoaXMuZ2V0Q29sb3IgPSBmdW47XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cy5zdGF0ID0gU3RhdGljU2NoZW1lQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cy5keW4gPSBEeW5TY2hlbWVDbGFzcztcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiM1ODU4YTdcIixcbiAgUjogXCIjNmI2Yjk0XCIsXG4gIE46IFwiIzY0NjQ5YlwiLFxuICBEOiBcIiMyMTIxZGVcIixcbiAgQzogXCIjOWQ5ZDYyXCIsXG4gIFE6IFwiIzhjOGM3M1wiLFxuICBFOiBcIiMwMDAwZmZcIixcbiAgRzogXCIjNDk0OWI2XCIsXG4gIEg6IFwiIzYwNjA5ZlwiLFxuICBJOiBcIiNlY2VjMTNcIixcbiAgTDogXCIjYjJiMjRkXCIsXG4gIEs6IFwiIzQ3NDdiOFwiLFxuICBNOiBcIiM4MjgyN2RcIixcbiAgRjogXCIjYzJjMjNkXCIsXG4gIFA6IFwiIzIzMjNkY1wiLFxuICBTOiBcIiM0OTQ5YjZcIixcbiAgVDogXCIjOWQ5ZDYyXCIsXG4gIFc6IFwiI2MwYzAzZlwiLFxuICBZOiBcIiNkM2QzMmNcIixcbiAgVjogXCIjZmZmZjAwXCIsXG4gIEI6IFwiIzQzNDNiY1wiLFxuICBYOiBcIiM3OTc5ODZcIixcbiAgWjogXCIjNDc0N2I4XCJcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQTogXCIjY2NmZjAwXCIsXG4gIFI6IFwiIzAwMDBmZlwiLFxuICBOOiBcIiNjYzAwZmZcIixcbiAgRDogXCIjZmYwMDAwXCIsXG4gIEM6IFwiI2ZmZmYwMFwiLFxuICBROiBcIiNmZjAwY2NcIixcbiAgRTogXCIjZmYwMDY2XCIsXG4gIEc6IFwiI2ZmOTkwMFwiLFxuICBIOiBcIiMwMDY2ZmZcIixcbiAgSTogXCIjNjZmZjAwXCIsXG4gIEw6IFwiIzMzZmYwMFwiLFxuICBLOiBcIiM2NjAwZmZcIixcbiAgTTogXCIjMDBmZjAwXCIsXG4gIEY6IFwiIzAwZmY2NlwiLFxuICBQOiBcIiNmZmNjMDBcIixcbiAgUzogXCIjZmYzMzAwXCIsXG4gIFQ6IFwiI2ZmNjYwMFwiLFxuICBXOiBcIiMwMGNjZmZcIixcbiAgWTogXCIjMDBmZmNjXCIsXG4gIFY6IFwiIzk5ZmYwMFwiLFxuICBCOiBcIiNmZmZcIixcbiAgWDogXCIjZmZmXCIsXG4gIFo6IFwiI2ZmZlwiXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEE6IFwiIzJjZDNkM1wiLFxuICBSOiBcIiM3MDhmOGZcIixcbiAgTjogXCIjZmYwMDAwXCIsXG4gIEQ6IFwiI2U4MTcxN1wiLFxuICBDOiBcIiNhODU3NTdcIixcbiAgUTogXCIjM2ZjMGMwXCIsXG4gIEU6IFwiIzc3ODg4OFwiLFxuICBHOiBcIiNmZjAwMDBcIixcbiAgSDogXCIjNzA4ZjhmXCIsXG4gIEk6IFwiIzAwZmZmZlwiLFxuICBMOiBcIiMxY2UzZTNcIixcbiAgSzogXCIjN2U4MTgxXCIsXG4gIE06IFwiIzFlZTFlMVwiLFxuICBGOiBcIiMxZWUxZTFcIixcbiAgUDogXCIjZjYwOTA5XCIsXG4gIFM6IFwiI2UxMWUxZVwiLFxuICBUOiBcIiM3MzhjOGNcIixcbiAgVzogXCIjNzM4YzhjXCIsXG4gIFk6IFwiIzlkNjI2MlwiLFxuICBWOiBcIiMwN2Y4ZjhcIixcbiAgQjogXCIjZjMwYzBjXCIsXG4gIFg6IFwiIzdjODM4M1wiLFxuICBaOiBcIiM1YmE0YTRcIlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBOiBcIiNmZmFmYWZcIixcbiAgUjogXCIjNjQ2NGZmXCIsXG4gIE46IFwiIzAwZmYwMFwiLFxuICBEOiBcIiNmZjAwMDBcIixcbiAgQzogXCIjZmZmZjAwXCIsXG4gIFE6IFwiIzAwZmYwMFwiLFxuICBFOiBcIiNmZjAwMDBcIixcbiAgRzogXCIjZmYwMGZmXCIsXG4gIEg6IFwiIzY0NjRmZlwiLFxuICBJOiBcIiNmZmFmYWZcIixcbiAgTDogXCIjZmZhZmFmXCIsXG4gIEs6IFwiIzY0NjRmZlwiLFxuICBNOiBcIiNmZmFmYWZcIixcbiAgRjogXCIjZmZjODAwXCIsXG4gIFA6IFwiI2ZmMDBmZlwiLFxuICBTOiBcIiMwMGZmMDBcIixcbiAgVDogXCIjMDBmZjAwXCIsXG4gIFc6IFwiI2ZmYzgwMFwiLFxuICBZOiBcIiNmZmM4MDBcIixcbiAgVjogXCIjZmZhZmFmXCIsXG4gIEI6IFwiI2ZmZlwiLFxuICBYOiBcIiNmZmZcIixcbiAgWjogXCIjZmZmXCJcbn07XG4iLCIvKlxuICogbXNhLXNlcXRvb2xzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5pZnkvbXNhLXNlcXRvb2xzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IGdyZWVuaWZ5XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxudmFyIHN0ID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IHN0O1xuXG4vLyBleHRyYWN0IElEcyBhbmQgcHVzaCB0aGVtIHRvIHRoZSBtZXRhIGRpY3RcbnN0LmdldE1ldGEgPSBmdW5jdGlvbihsYWJlbCkge1xuICBpZiAoc3QuY29udGFpbnMobGFiZWwsIFwifFwiKSkge1xuICAgIHZhciBpZGVudGlmaWVycyA9IGxhYmVsLnNwbGl0KFwifFwiKTtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIGRhdGFiYXNlLCBkYXRhYmFzZUlEO1xuICAgIHZhciBtZXRhID0ge307XG4gICAgd2hpbGUgKGsgPCBpZGVudGlmaWVycy5sZW5ndGggLSAxKSB7XG4gICAgICBkYXRhYmFzZSA9IGlkZW50aWZpZXJzW2tdO1xuICAgICAgZGF0YWJhc2VJRCA9IGlkZW50aWZpZXJzW2sgKyAxXTtcbiAgICAgIG1ldGFbZGF0YWJhc2VdID0gZGF0YWJhc2VJRDtcbiAgICAgIGsgKz0gMjtcbiAgICB9XG4gICAgLy8gYXNzdW1lIHRoZSBsYXN0IGVudHJ5IGlzIHRoZSBsYWJlbFxuICAgIHZhciBuYW1lID0gaWRlbnRpZmllcnNbaWRlbnRpZmllcnMubGVuZ3RoIC0gMV07XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGVyZSBpcyBhIHVuaXByb3QgaWRcbiAgICBpZiAobmFtZS5pbmRleE9mKFwiPVwiKSA+PSAwICYmIG5hbWUuaW5kZXhPZihcIk9TXCIpID49IDApIHtcbiAgICAgIHZhciBkcyA9IHt9O1xuICAgICAgdmFyIGRldGFpbHMgPSBuYW1lLnNwbGl0KFwiIFwiKTtcbiAgICAgIGRzLmVuID0gZGV0YWlsc1swXTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLnNwbGljZSgxKTtcbiAgICAgIHZhciBuYW1lTGVuZ3RoID0gZmluZFNlcEluQXJyKGRldGFpbHMsIFwiPVwiKTtcbiAgICAgIHZhciBkZXRhaWxzVG1wID0gZGV0YWlscy5zcGxpY2UobmFtZUxlbmd0aCAtIDEpO1xuICAgICAgbmFtZSA9IGRldGFpbHMuam9pbihcIiBcIik7XG4gICAgICBkZXRhaWxzID0gZGV0YWlsc1RtcDtcbiAgICAgIGsgPSAwO1xuICAgICAgdmFyIGJsb2NrID0gW107XG4gICAgICBkZXRhaWxzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBibG9jay5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoaXRlbS5pbmRleE9mKFwiPVwiKSA+PSAwKSB7XG4gICAgICAgICAgc3RyVG9EaWN0KGJsb2NrLmpvaW4oXCIgXCIpLCBcIj1cIiwgZHMpO1xuICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaWRzOiBtZXRhLFxuICAgICAgICBkZXRhaWxzOiBkc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpZHM6IG1ldGFcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogbGFiZWxcbiAgfTtcbn07XG5cbnZhciBmaW5kU2VwSW5BcnIgPSBmdW5jdGlvbihhcnIsIHNlcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5naHQ7IGkrKykge1xuICAgIGlmIChhcnJbaV0uaW5kZXhPZihpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnIubGVuZ3RoIC0gMTtcbn07XG5cbnZhciBzdHJUb0RpY3QgPSBmdW5jdGlvbihzdHIsIHNlcCwgdG9Kb2luKSB7XG4gIHRvSm9pbiA9IHRvSm9pbiB8fCB7fTtcbiAgdmFyIGVudHJpZXMgPSBzdHIuc3BsaXQoc2VwKTtcbiAgdG9Kb2luW2VudHJpZXNbMF0udG9Mb3dlckNhc2UoKV0gPSBlbnRyaWVzWzFdO1xuICByZXR1cm4gdG9Kb2luO1xufTtcblxudmFyIGlkZW50REIgPSB7XG4gIFwic3BcIjoge1xuICAgIGxpbms6IFwiaHR0cDovL3d3dy51bmlwcm90Lm9yZy8lc1wiLFxuICAgIG5hbWU6IFwiVW5pcHJvdFwiXG4gIH0sXG4gIFwidHJcIjoge1xuICAgIGxpbms6IFwiaHR0cDovL3d3dy51bmlwcm90Lm9yZy8lc1wiLFxuICAgIG5hbWU6IFwiVHJlbWJsXCJcbiAgfSxcbiAgXCJnYlwiOiB7XG4gICAgbGluazogXCJodHRwOi8vd3d3Lm5jYmkubmxtLm5paC5nb3YvbnVjY29yZS8lc1wiLFxuICAgIG5hbWU6IFwiR2VuYmFua1wiXG4gIH0sXG4gIFwicGRiXCI6IHtcbiAgICBsaW5rOiBcImh0dHA6Ly93d3cucmNzYi5vcmcvcGRiL2V4cGxvcmUvZXhwbG9yZS5kbz9zdHJ1Y3R1cmVJZD0lc1wiLFxuICAgIG5hbWU6IFwiUERCXCJcbiAgfVxufTtcblxuc3QuYnVpbGRMaW5rcyA9IGZ1bmN0aW9uKG1ldGEpIHtcbiAgdmFyIGxpbmtzID0ge307XG4gIG1ldGEgPSBtZXRhIHx8IHt9O1xuICBPYmplY3Qua2V5cyhtZXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYgKGlkIGluIGlkZW50REIpIHtcbiAgICAgIHZhciBlbnRyeSA9IGlkZW50REJbaWRdO1xuICAgICAgdmFyIGxpbmsgPSBlbnRyeS5saW5rLnJlcGxhY2UoXCIlc1wiLCBtZXRhW2lkXSk7XG4gICAgICBsaW5rc1tlbnRyeS5uYW1lXSA9IGxpbms7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxpbmtzO1xufTtcblxuXG4vLyBzZWFyY2ggZm9yIGEgdGV4dFxuc3QuY29udGFpbnMgPSBmdW5jdGlvbih0ZXh0LCBzZWFyY2gpIHtcbiAgcmV0dXJuICcnLmluZGV4T2YuY2FsbCh0ZXh0LCBzZWFyY2gsIDApICE9PSAtMTtcbn07XG5cbi8vIHNwbGl0IGFmdGVyIGUuZy4gODAgY2hhcnNcbnN0LnNwbGl0TkNoYXJzID0gZnVuY3Rpb24odHh0LCBudW0pIHtcbiAgdmFyIGksIF9yZWY7XG4gIG51bSA9IG51bSB8fCA4MDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKGkgPSAwLCBfcmVmID0gdHh0Lmxlbmd0aCAtIDE7IGkgPD0gX3JlZjsgaSArPSBudW0pIHtcbiAgICByZXN1bHQucHVzaCh0eHQuc3Vic3RyKGksIG51bSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5zdC5tb2RlbCA9IGZ1bmN0aW9uIFNlcShzZXEsIG5hbWUsIGlkKSB7XG4gIHRoaXMuc2VxID0gc2VxO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuaWRzID0ge307XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblxudmFyIHN0YXQgPSBmdW5jdGlvbihzZXFzKSB7XG4gIC8vIGlmIHNvbWVvbmUgZm9yZ2V0cyBuZXdcbiAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IHN0YXQpIHtcbiAgICByZXR1cm4gbmV3IHN0YXQoc2Vxcyk7XG4gIH1cbiAgaWYgKHNlcXMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2VxcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ5b3UgbmVlZCB0byBnaXZlIHRoZSBzZXEgc3RhdCBhbiBhcnJheVwiKTtcbiAgfVxuICAvL2lmKHNlcXMubGVuZ3RoID09IDApe1xuICAvL3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ5b3UgbmVlZCB0byBnaXZlIHRoZSBzZXEgc3RhdCBhIHJlYWwgYXJyYXlcIik7XG4gIC8vfVxuICB0aGlzLnJlc2V0U2VxcyhzZXFzKTtcbiAgdGhpcy5hbHBoYWJldFNpemUgPSA0O1xuICB0aGlzLl91c2VCYWNrZ3JvdW5kID0gZmFsc2U7XG4gIHRoaXMuaWdub3JlZENoYXJzID0gW1wiLVwiLCBcIipcIl07XG59O1xuXG5zdGF0LnByb3RvdHlwZS5hZGRTZXEgPSBmdW5jdGlvbiBhZGRTZXEoc2VxKSB7XG4gIHRoaXMuc2Vxcy5wdXNoKHNlcSk7XG4gIHRoaXMuX3Jlc2V0KCk7XG59O1xuXG5zdGF0LnByb3RvdHlwZS5yZW1vdmVTZXEgPSBmdW5jdGlvbiBhZGRTZXEoc2VxKSB7XG4gIC8vIGNoZWNrIGZvciBpbnQgb3Igc3RyaW5nXG4gIGlmICh0eXBlb2Ygc2VxID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuc2Vxcy5zcGxpY2Uoc2VxLCAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZGVudGlmeSBtYXRjaGVzICh3ZSBjb3VsZCBoYXZlIG11bHRpcGxlKVxuICAgIF8uZWFjaCh0aGlzLnNlcXMsIGZ1bmN0aW9uKHMsIGkpIHtcbiAgICAgIGlmIChzZXEgPT09IHMpIHtcbiAgICAgICAgdGhpcy5zZXFzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG4gIHRoaXMuX3Jlc2V0KCk7XG59O1xuXG5zdGF0LnByb3RvdHlwZS5hZGRTZXFzID0gZnVuY3Rpb24gYWRkU2VxcyhzZXFzKSB7XG4gIHNlcXMuZm9yRWFjaChmdW5jdGlvbihzZXEpIHtcbiAgICB0aGlzLmFkZFNlcShzZXEpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuc3RhdC5wcm90b3R5cGUucmVzZXRTZXFzID0gZnVuY3Rpb24gcmVzZXQoc2Vxcykge1xuICB0aGlzLnNlcXMgPSBbXTtcblxuICAvLyBzdXBwb3J0IHNlcXVlbmNlIG1vZGVsc1xuICBpZiAoIShzZXFzIGluc3RhbmNlb2YgQXJyYXkpKXtcbiAgICB0aGlzLm1zZXFzID0gc2VxcztcbiAgICB2YXIgbVNlcXNQbHVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlcUFyciA9IHRoaXMubXNlcXMucGx1Y2soXCJzZXFcIik7XG4gICAgICB0aGlzLnJlc2V0U2VxcyhzZXFBcnIpO1xuICAgIH07XG4gICAgc2Vxcy5vbihcImFkZCBjaGFuZ2UgcmVzZXQgXCIsIG1TZXFzUGx1Y2ssIHRoaXMpO1xuICAgIG1TZXFzUGx1Y2suY2FsbCh0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZFNlcXMoc2Vxcyk7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJyZXNldFwiKTtcbiAgfVxufTtcblxudmFyIGNhbGNWYWx1ZXMgPSBbXCJjb25zZW5zdXNcIiwgXCJmcmVxdWVuY3lcIiwgXCJtYXhMZW5ndGhcIiwgXCJpY1wiLCBcImdhcHNcIl07XG5cbnN0YXQucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxjVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tcIl9cIiArIGNhbGNWYWx1ZXNbaV1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHRoaXMuX2lkZW50aXR5ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJFR0lOOiBzZXR0ZXIvZ2V0dGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5zdGF0LnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24gc2V0QmFja2dyb3VuZChiKSB7XG4gIHRoaXMuX3VzZUJhY2tncm91bmQgPSBiO1xuICB0aGlzLl9yZXNldCgpO1xufTtcblxuc3RhdC5wcm90b3R5cGUudXNlQmFja2dyb3VuZCA9IGZ1bmN0aW9uIHVzZUJhY2tncm91bmQoKSB7XG4gIHRoaXMuc2V0QmFja2dyb3VuZCh0cnVlKTtcbn07XG5cbnN0YXQucHJvdG90eXBlLnNldEROQSA9IGZ1bmN0aW9uIHNldE51Y2xlb3RpZGUoKSB7XG4gIHRoaXMuYWxwaGFiZXRTaXplID0gNDtcbn07XG5cbnN0YXQucHJvdG90eXBlLnNldFByb3RlaW4gPSBmdW5jdGlvbiBzZXRETkEoKSB7XG4gIHRoaXMuYWxwaGFiZXRTaXplID0gMjA7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQkVHSU46IGF1dG8gd3JhcHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIG5lYXQgYXV0by13cmFwcGVyc1xuY2FsY1ZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICBzdGF0LnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXNbXCJfXCIgKyBrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXNba2V5ICsgXCJDYWxjXCJdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW1wiX1wiICsga2V5XTtcbiAgfTtcbn0pO1xuXG5zdGF0LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXRpeShzZXEpIHtcbiAgLy8gZG8gbm90IGNhY2hlIGlmIGl0cyBjYWxsZWQgd2l0aCBhIHNwZWNpYWwgY29tcGFyZSBzZXFcbiAgdmFyIGlkZW50O1xuICBpZiAodGhpcy5faWRlbnRpdHkgPT09IHVuZGVmaW5lZCB8fCBzZXEpIHtcbiAgICBpZGVudCA9IHRoaXMuaWRlbnRpdHlDYWxjKHNlcSk7XG4gICAgdGhpcy5faWRlbnRpdHkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2lkZW50aXR5IHx8IGlkZW50O1xufTtcblxuLy8gc2V0IHlvdXIgb3duIGJhY2tncm91bmQgd2l0aCBvYmouYmdcbnN0YXQucHJvdG90eXBlLmJhY2tncm91bmQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kKCkge1xuICBpZiAodGhpcy5iZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYmc7XG4gIH1cbiAgaWYgKHRoaXMuX2JhY2tncm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYmFja2dyb3VuZENhbGMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZDtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJFR0lOOiBjYWxjIHRvb2xzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBjYWxjdWxhdGVzIHRoZSByZWxhdGl2ZSBmcmVxdWVuY3kgb2YgYSBiYXNlIGF0IGEgZ2l2ZW4gcG9zaXRpb25cbi8vIHRoaXMgaXMgbmVlZGVkIGUuZy4gZm9yIHRoZSBlbnRyb3B5IGNhbGN1bGF0aW9uXG4vLyBzZXFzOiBhcnJheSBvZiBzZXF1ZW5jZXMgKHN0cmluZ3MpXG4vLyBvcHRzOlxuLy8gICAgYWxsOiBib29sZWFuICh1c2UgdG8gc2hvdyB0aGUgZnJlcXVlbmNpZXMgZm9yIGFsbCBsZXR0ZXJzIFtpbmNsdWRpbmcgdGhlIGlnbm9yZWQgb25lc11cbi8vICAgIChkZWZhdWx0IGZhbHNlKVxuLy8gQHJldHVybnMgYXJyYXkgb2YgYWxsIHBvc2l0aW9ucyB3aXRoIGEgZGljdGlvbmFyeSBvZiBhbGwgYmFzZXMgd2l0aCB0aGVpciByZWxhdGl2ZSBmcmVxdWVuY3lcbnN0YXQucHJvdG90eXBlLmZyZXF1ZW5jeUNhbGMgPSBmdW5jdGlvbiBmcmVxdWVuY3lDYWxjKG9wdHMpIHtcbiAgdmFyIG9jY3MsIHRvdGFsUGVyUG9zO1xuICBvY2NzID0gbmV3IEFycmF5KHRoaXMubWF4TGVuZ3RoKCkpO1xuICB0b3RhbFBlclBvcyA9IG5ldyBBcnJheSh0aGlzLnNlcXMubGVuZ3RoKTtcbiAgdmFyIGlnbm9yZWRDaGFycyA9IHRoaXMuaWdub3JlZENoYXJzO1xuICBpZihvcHRzICE9PSB1bmRlZmluZWQgJiYgb3B0cy5hbGwpe1xuICAgIGlnbm9yZWRDaGFycyA9IFtdOyBcbiAgfVxuXG4gIC8vIGNvdW50IHRoZSBvY2N1cnJlbmNlcyBvZiB0aGUgY2hhcnMgYXQgYSBwb3NpdGlvblxuICBfLmVhY2godGhpcy5zZXFzLCBmdW5jdGlvbihlbCkge1xuICAgIF8uZWFjaChlbCwgZnVuY3Rpb24oYywgcG9zKSB7XG4gICAgICBpZiAoaWdub3JlZENoYXJzLmluZGV4T2YoYykgPj0gMCkgcmV0dXJuO1xuICAgICAgaWYgKG9jY3NbcG9zXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9jY3NbcG9zXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG9jY3NbcG9zXVtjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9jY3NbcG9zXVtjXSA9IDA7XG4gICAgICB9XG4gICAgICBvY2NzW3Bvc11bY10gKys7XG4gICAgICBpZiAodG90YWxQZXJQb3NbcG9zXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRvdGFsUGVyUG9zW3Bvc10gPSAwO1xuICAgICAgfVxuICAgICAgdG90YWxQZXJQb3NbcG9zXSArKztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gbm9ybWFsaXplIHRvIDFcbiAgXy5lYWNoKG9jY3MsIGZ1bmN0aW9uKGVsLCBwb3MpIHtcbiAgICByZXR1cm4gXy5lYWNoKGVsLCBmdW5jdGlvbih2YWwsIGMpIHtcbiAgICAgIHJldHVybiAob2Njc1twb3NdW2NdID0gdmFsIC8gdG90YWxQZXJQb3NbcG9zXSk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9mcmVxdWVuY3kgPSBvY2NzO1xuICByZXR1cm4gb2Njcztcbn07XG5cbi8vIHNlcXM6IGFycmF5IG9mIHNlcXVlbmNlcyAoc3RyaW5ncylcbnN0YXQucHJvdG90eXBlLmJhY2tncm91bmRDYWxjID0gZnVuY3Rpb24gYmFja2dyb3VuZENhbGMoKSB7XG4gIHZhciBvY2MgPSB7fTtcbiAgdmFyIHRvdGFsID0gMDtcblxuICAvLyBjb3VudCB0aGUgb2NjdXJlbmNlcyBvZiB0aGUgY2hhcnMgb2YgYSBwb3NpdGlvblxuICBfLmVhY2godGhpcy5zZXFzLCBmdW5jdGlvbihlbCkge1xuICAgIF8uZWFjaChlbCwgZnVuY3Rpb24oYykge1xuICAgICAgaWYgKG9jY1tjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9jY1tjXSA9IDA7XG4gICAgICB9XG4gICAgICBvY2NbY10gKys7XG4gICAgICByZXR1cm4gdG90YWwrKztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gbm9ybWFsaXplIHRvIDFcbiAgb2NjID0gXy5tYXBWYWx1ZXMob2NjLCBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsIC8gdG90YWw7XG4gIH0pO1xuICB0aGlzLl9iYWNrZ3JvdW5kID0gb2NjO1xuICByZXR1cm4gb2NjO1xufTtcblxuXG4vLyBpbmZvcm1hdGlvbiBjb250ZW50IGFmdGVyIFNoYW5ub25cbi8vICogZ2FwcyBhcmUgZXhjbHVkZWRcbnN0YXQucHJvdG90eXBlLmljQ2FsYyA9IGZ1bmN0aW9uIGljQ2FsYygpIHtcbiAgdmFyIGYgPSB0aGlzLmZyZXF1ZW5jeSgpO1xuICBpZiAodGhpcy5fdXNlQmFja2dyb3VuZCkge1xuICAgIHZhciBiID0gdGhpcy5iYWNrZ3JvdW5kKCk7XG4gIH1cbiAgdmFyIGlnbm9yZWRDaGFycyA9IHRoaXMuaWdub3JlZENoYXJzO1xuICB2YXIgdXNlQmFja2dyb3VuZCA9IHRoaXMuX3VzZUJhY2tncm91bmQ7XG4gIHZhciBpYyA9IF8ubWFwKGYsIGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGVsLCBmdW5jdGlvbihtZW1vLCB2YWwsIGMpIHtcbiAgICAgIGlmIChpZ25vcmVkQ2hhcnMuaW5kZXhPZihjKSA+PSAwKSByZXR1cm4gbWVtbztcbiAgICAgIGlmICh1c2VCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHZhbCA9IHZhbCAvIGJbY107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbyAtIHZhbCAqIChNYXRoLmxvZyh2YWwpIC8gTWF0aC5sb2coMikpO1xuICAgIH0sIDApO1xuICB9KTtcbiAgdGhpcy5faWMgPSBpYztcbiAgcmV0dXJuIGljO1xufTtcblxuLy8gc2VxdWVuY2UgY29uc2VydmF0aW9uIGFmdGVyIFNjaG5laWRlciBhbmQgU3RlcGhlbnMgKDE5OTApXG4vLyBAY2l0ZSBTY2huZWlkZXIsIFQuRC4gYW5kIFN0ZXBoZW5zLCBSLk0uIDE5OTAuIFNlcXVlbmNlIGxvZ29zOiBBIG5ldyB3YXkgdG9cbi8vIGRpc3BsYXkgY29uc2Vuc3VzIHNlcXVlbmNlcy4gTnVjbGVpYyBBY2lkcyBSZXMuIDE4OiA2MDk34oCTNjEwMC5cbnN0YXQucHJvdG90eXBlLmNvbnNlcnZhdGlvbiA9IGZ1bmN0aW9uIGNvbnNlcnZhdGlvbihhbHBoYWJldFNpemUpIHtcbiAgdmFyIGljID0gdGhpcy5pYygpO1xuICBhbHBoYWJldFNpemUgPSBhbHBoYWJldFNpemUgfHwgdGhpcy5hbHBoYWJldFNpemU7XG4gIHZhciBpY01heCA9IE1hdGgubG9nKGFscGhhYmV0U2l6ZSkgLyBNYXRoLmxvZygyKTtcbiAgdmFyIGNvbnNlcnYgPSBfLm1hcChpYywgZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gaWNNYXggLSBlbDtcbiAgfSk7XG4gIHJldHVybiBjb25zZXJ2O1xufTtcblxuLy8gc2VxdWVuY2UgY29uc2VydmF0aW9uIGFmdGVyIFNjaG5laWRlciBhbmQgU3RlcGhlbnMgKDE5OTApXG4vLyBjb25zZXJ2YXRpb24gZm9yIGVhY2ggYW1pbm8gYWNpZFxuLy8gKiBnYXBzIGFyZSBleGNsdWRlZFxuc3RhdC5wcm90b3R5cGUuY29uc2VydlJlc2lkdWUgPSBmdW5jdGlvbiBjb25zZXJ2YXRpb24oaW5wdXQpIHtcbiAgdmFyIGFscGhhYmV0U2l6ZSA9IGlucHV0ID8gaW5wdXQuYWxwaGFiZXRTaXplIDogdW5kZWZpbmVkO1xuICB2YXIgaWM7XG4gIHZhciBpZ25vcmVkQ2hhcnMgPSB0aGlzLmlnbm9yZWRDaGFycztcbiAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQuc2NhbGVkKSB7XG4gICAgaWMgPSB0aGlzLnNjYWxlKHRoaXMuY29uc2VydmF0aW9uKGFscGhhYmV0U2l6ZSkpO1xuICB9IGVsc2Uge1xuICAgIGljID0gdGhpcy5jb25zZXJ2YXRpb24oYWxwaGFiZXRTaXplKTtcbiAgfVxuICB2YXIgZiA9IHRoaXMuZnJlcXVlbmN5KCk7XG4gIHZhciBrZXlzO1xuICB2YXIgY29uc2VydiA9IF8ubWFwKGYsIGZ1bmN0aW9uKGVsLCBpKSB7XG4gICAga2V5cyA9IF8ucmVqZWN0KF8ua2V5cyhlbCksIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBpZ25vcmVkQ2hhcnMuaW5kZXhPZihjKSA+PSAwO1xuICAgIH0pO1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBfLmVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IGVsW2tleV0gKiBpY1tpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9KTtcbiAgcmV0dXJuIGNvbnNlcnY7XG59O1xuXG4vLyB0eXBlIDIgc2VxdWVuY2UgbG9nbyBtZXRob2Rcbi8vIHNjYWxlcyByZWxhdGl2ZSB0byBiYWNrZ3JvdW5kXG5zdGF0LnByb3RvdHlwZS5jb25zZXJ2UmVzaWR1ZTIgPSBmdW5jdGlvbiBjb25zZXJ2YXRpb24oYWxwaGFiZXRTaXplKSB7XG4gIHZhciBmID0gdGhpcy5mcmVxdWVuY3koKTtcbiAgdmFyIGljID0gdGhpcy5jb25zZXJ2YXRpb24oYWxwaGFiZXRTaXplKTtcbiAgdmFyIGIgPSB0aGlzLmJhY2tncm91bmQoKTtcbiAgdmFyIGNvbnNlcnYgPSBfLm1hcChmLCBmdW5jdGlvbihlbCwgaSkge1xuICAgIHJldHVybiBfLm1hcChlbCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgc3VtID0gXy5yZWR1Y2UoZltpXSwgZnVuY3Rpb24obWVtbywgZSkge1xuICAgICAgICByZXR1cm4gbWVtbyArIGUgLyBiW2ldO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gKCh2YWwgLyBiW2ldKSAvIHN1bSkgKiBpY1tpXTtcbiAgICB9LCAwKTtcbiAgfSk7XG4gIHJldHVybiBjb25zZXJ2O1xufTtcblxuLy8gc2NhbGUgaW5mb3JtYXRpb24gY29udGVudCBvciBjb25zZXJ2YXRpb24gdG8gMVxuc3RhdC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBjb25zZXJ2YXRpb24oaWMsIGFscGhhYmV0U2l6ZSkge1xuICBhbHBoYWJldFNpemUgPSBhbHBoYWJldFNpemUgfHwgdGhpcy5hbHBoYWJldFNpemU7XG4gIHZhciBpY01heCA9IE1hdGgubG9nKGFscGhhYmV0U2l6ZSkgLyBNYXRoLmxvZygyKTtcbiAgdmFyIGNvbnNlcnYgPSBfLm1hcChpYywgZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwgLyBpY01heDtcbiAgfSk7XG4gIHJldHVybiBjb25zZXJ2O1xufTtcblxuc3RhdC5wcm90b3R5cGUubWF4TGVuZ3RoQ2FsYyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tYXhMZW5ndGggPSBfLm1heCh0aGlzLnNlcXMsIGZ1bmN0aW9uKHNlcSkge1xuICAgIHJldHVybiBzZXEubGVuZ3RoO1xuICB9KS5sZW5ndGg7XG59O1xuXG4vLyBzZXFzOiBhcnJheSBvZiBzZXF1ZW5jZXMgKHN0cmluZ3MpXG4vLyBAcmV0dXJucyBjb25zZW51cyBzZXF1ZW5jZVxuc3RhdC5wcm90b3R5cGUuY29uc2Vuc3VzQ2FsYyA9IGZ1bmN0aW9uIGNvbnNlbnN1c0NhbCgpIHtcbiAgdmFyIG9jY3MgPSBuZXcgQXJyYXkodGhpcy5tYXhMZW5ndGgoKSk7XG5cbiAgLy8gY291bnQgdGhlIG9jY3VycmVuY2VzIG9mIHRoZSBjaGFycyBvZiBhIHBvc2l0aW9uXG4gIF8uZWFjaCh0aGlzLnNlcXMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgXy5lYWNoKGVsLCBmdW5jdGlvbihjLCBwb3MpIHtcbiAgICAgIGlmIChvY2NzW3Bvc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvY2NzW3Bvc10gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChvY2NzW3Bvc11bY10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvY2NzW3Bvc11bY10gPSAwO1xuICAgICAgfVxuICAgICAgb2Njc1twb3NdW2NdICsrO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBub3cgcGljayB0aGUgY2hhciB3aXRoIG1vc3Qgb2NjdXJyZW5jZXNcbiAgdGhpcy5fY29uc2Vuc3VzID0gXy5yZWR1Y2Uob2NjcywgZnVuY3Rpb24obWVtbywgb2NjKSB7XG4gICAgdmFyIGtleXM7XG4gICAga2V5cyA9IF8ua2V5cyhvY2MpO1xuICAgIHJldHVybiBtZW1vICs9IF8ubWF4KGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9jY1trZXldO1xuICAgIH0pO1xuICB9LCBcIlwiKTtcblxuICByZXR1cm4gdGhpcy5fY29uc2Vuc3VzO1xufTtcblxuLy8gc2VxczogYXJyYXkgb2Ygc2VxdWVuY2VzIChzdHJpbmdzKVxuLy8gY29uc2Vuc3VzOiBjYWxjdWxhdGVkIGNvbnNlbnN1cyBzZXFcbi8vIGNhbGN1bGF0ZXMgZm9yIGVhY2ggc2VxdWVuY2Vcbi8vICogbWF0Y2hlcyB3aXRoIHRoZSBjb25zZW5zdXMgc2VxXG4vLyAqIGlkZW50aXR5ID0gbWF0Y2hlZENoYXJzIC8gdG90YWxDaGFycyAoZXhjbHVkaW5nIGdhcHMpXG4vLyBAcmV0dXJuczogYXJyYXkgb2YgbGVuZ3RoIG9mIHRoZSBzZXFzIHdpdGggdGhlIGlkZW50aXR5IHRvIHRoZSBjb25zZW5zdXMgKGRvdWJsZSlcbnN0YXQucHJvdG90eXBlLmlkZW50aXR5Q2FsYyA9IGZ1bmN0aW9uIGlkZW50aXRpeUNhbGMoY29tcGFyZVNlcSkge1xuICB2YXIgY29uc2Vuc3VzID0gY29tcGFyZVNlcSB8fCB0aGlzLmNvbnNlbnN1cygpO1xuICB0aGlzLl9pZGVudGl0eSA9IHRoaXMuc2Vxcy5tYXAoZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZXFbaV0gIT09IFwiLVwiICYmIGNvbnNlbnN1c1tpXSAhPT0gXCItXCIpIHtcbiAgICAgICAgdG90YWwrKztcbiAgICAgICAgaWYgKHNlcVtpXSA9PT0gY29uc2Vuc3VzW2ldKSB7XG4gICAgICAgICAgbWF0Y2hlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzIC8gdG90YWw7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG59O1xuXG4vLyBwZXJjZW50YWdlIG9mIGdhcHMgcGVyIGNvbHVtblxuc3RhdC5wcm90b3R5cGUuZ2Fwc0NhbGMgPSBmdW5jdGlvbiBnYXBzQ291bnQoKSB7XG4gIHZhciBvY2NzID0gbmV3IEFycmF5KHRoaXMubWF4TGVuZ3RoKCkpO1xuICAvLyBjb3VudCB0aGUgb2NjdXJyZW5jZXMgb2YgdGhlIGNoYXJzIG9mIGEgcG9zaXRpb25cbiAgXy5lYWNoKHRoaXMuc2VxcywgZnVuY3Rpb24oZWwpIHtcbiAgICBfLmVhY2goZWwsIGZ1bmN0aW9uKGMsIHBvcykge1xuICAgICAgaWYgKG9jY3NbcG9zXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9jY3NbcG9zXSA9IHtcbiAgICAgICAgICBnOiAwLFxuICAgICAgICAgIHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGMgPSBjID09PSBcIi1cIiA/IFwiZ1wiIDogXCJ0XCI7XG4gICAgICBvY2NzW3Bvc11bY10gKys7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIG5vdyBwaWNrIHRoZSBjaGFyIHdpdGggbW9zdCBvY2N1cnJlbmNlc1xuICB0aGlzLl9nYXBzID0gXy5tYXAob2NjcywgZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwuZyAvIChlbC5nICsgZWwudCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5fZ2Fwcztcbn07XG5cbl8ubWl4aW4oe1xuICBtYXBWYWx1ZXM6IGZ1bmN0aW9uKG9iaiwgZl92YWwpIHtcbiAgICByZXR1cm4gXy5vYmplY3QoXy5rZXlzKG9iaiksIF8ubWFwKG9iaiwgZl92YWwpKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoXCJiaW9qcy1ldmVudHNcIikubWl4aW4oc3RhdC5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXQ7XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguMlxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4yJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0LCB0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInICYmIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gaW5wdXQgJiYgaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCAnbGVuZ3RoJykubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QgJiYgbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcbiAgICB9IGVsc2UgaWYgKGlzU29ydGVkICYmIGxlbmd0aCkge1xuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIGkpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRMYXN0SW5kZXgoc2xpY2UuY2FsbChhcnJheSwgMCwgaWR4KSwgXy5pc05hTik7XG4gICAgfVxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSAhPSBudWxsICYmIGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICBcbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcbiAgXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJDb2xvcnMgPSByZXF1aXJlKFwibXNhLWNvbG9yc2NoZW1lc1wiKVxuXG5Nb2RlbCA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLk1vZGVsXG5cbiMgdGhpcyBpcyBhbiBleGFtcGxlIG9mIGhvdyBvbmUgY291bGQgY29sb3IgdGhlIE1TQVxuIyBmZWVsIGZyZWUgdG8gY3JlYXRlIHlvdXIgb3duIGNvbG9yIHNjaGVtZSBpbiB0aGUgL2Nzcy9zY2hlbWVzIGZvbGRlclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcnNjaGVtZSA9IE1vZGVsLmV4dGVuZFxuXG4gIGRlZmF1bHRzOlxuICAgIHNjaGVtZTogXCJ0YXlsb3JcIiAjIG5hbWUgb2YgeW91ciBjb2xvciBzY2hlbWVcbiAgICBjb2xvckJhY2tncm91bmQ6IHRydWUgIyBvdGhlcndpc2Ugb25seSB0aGUgdGV4dCB3aWxsIGJlIGNvbG9yZWRcbiAgICBzaG93TG93ZXJDYXNlOiB0cnVlICMgdXNlZCB0byBoaWRlIGFuZCBzaG93IGxvd2VyY2FzZSBjaGFycyBpbiB0aGUgb3ZlcnZpZXdib3hcbiAgICBvcGFjaXR5OiAwLjYgIyBvcGFjaXR5IGZvciB0aGUgcmVzaWR1ZXNcblxuICBpbml0aWFsaXplOiAoZGF0YSxzZXFzLCBzdGF0KSAtPlxuICAgIEBjb2xvcnMgPSBuZXcgQ29sb3JzKFxuICAgICAgc2Vxczogc2Vxc1xuICAgICAgY29uc2VydmF0aW9uOiAtPlxuICAgICAgICBzdGF0LnNjYWxlKHN0YXQuY29uc2VydmF0aW9uKCkpXG4gICAgKVxuICAgICMgdGhlIHN0YXRzIG1vZHVsZSBzZW5kcyBhbiBldmVudCBldmVyeSB0aW1lIGl0IGlzIHJlZnJlc2hlZFxuICAgIHN0YXQub24gXCJyZXNldFwiLCAtPlxuICAgICAgaWYgQGdldFNlbGVjdGVkU2NoZW1lKCkudHlwZSBpcyBcImR5blwiXG4gICAgICAgIEBnZXRTZWxlY3RlZFNjaGVtZSgpLnJlc2V0KClcbiAgICAsQFxuXG4gICMgWW91IGNhbiBlbnRlciB5b3VyIG93biBjb2xvciBzY2hlbWUgaGVyZVxuICBhZGRTdGF0aWNTY2hlbWU6IChuYW1lLCBkaWN0KSAtPlxuICAgIEBjb2xvcnMuYWRkU3RhdGljU2NoZW1lIG5hbWUsZGljdFxuXG4gIGFkZER5blNjaGVtZTogKG5hbWUsIGZ1bikgLT5cbiAgICBAY29sb3JzLmFkZER5blNjaGVtZSBuYW1lLGZ1blxuXG4gIGdldFNjaGVtZTogKG5hbWUpIC0+XG4gICAgQGNvbG9ycy5nZXRTY2hlbWUgbmFtZVxuXG4gIGdldFNlbGVjdGVkU2NoZW1lOiAtPlxuICAgIEBjb2xvcnMuZ2V0U2NoZW1lIEBnZXQoXCJzY2hlbWVcIilcbiIsIk1vZGVsID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuTW9kZWxcbl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbiMgbW9kZWwgZm9yIGNvbHVtbiBwcm9wZXJ0aWVzIChsaWtlIHRoZWlyIGhpZGRlbiBzdGF0ZSlcbm1vZHVsZS5leHBvcnRzID0gQ29sdW1ucyA9IE1vZGVsLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChvLHN0YXQpIC0+XG4gICAgIyBoaWRkZW4gY29sdW1uc1xuICAgIEAuc2V0IFwiaGlkZGVuXCIsIFtdIHVubGVzcyBALmdldChcImhpZGRlblwiKT9cbiAgICBAc3RhdHMgPSBzdGF0XG5cbiAgIyBhc3N1bWVzIGhpZGRlbiBjb2x1bW5zIGFyZSBzb3J0ZWRcbiAgIyBAcmV0dXJucyBuIFtpbnRdIG51bWJlciBvZiBoaWRkZW4gY29sdW1ucyB1bnRpbCBuXG4gIGNhbGNIaWRkZW5Db2x1bW5zOiAobikgLT5cbiAgICBoaWRkZW4gPSBAZ2V0IFwiaGlkZGVuXCJcbiAgICBuZXdYID0gblxuICAgIGZvciBpIGluIGhpZGRlblxuICAgICAgaWYgaSA8PSBuZXdYXG4gICAgICAgIG5ld1grK1xuICAgIG5ld1ggLSBuXG4iLCJNb2RlbCA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLk1vZGVsXG5cbiMgc2ltcGxlIHVzZXIgY29uZmlnXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZyA9IE1vZGVsLmV4dGVuZFxuXG4gIGRlZmF1bHRzOlxuICAgIHJlZ2lzdGVyTW91c2VIb3ZlcjogZmFsc2UsXG4gICAgcmVnaXN0ZXJNb3VzZUNsaWNrczogdHJ1ZSxcbiAgICBpbXBvcnRQcm94eTogXCJodHRwczovL2NvcnMtYW55d2hlcmUuaGVyb2t1YXBwLmNvbS9cIlxuICAgIGV2ZW50QnVzOiB0cnVlXG4gICAgYWxwaGFiZXRTaXplOiAyMFxuICAgIGRyb3BJbXBvcnQ6IGZhbHNlXG4gICAgZGVidWc6IGZhbHNlXG4gICAgaGFzUmVmOiBmYWxzZSAjIGhhc1JlZmVyZW5jZVxuIiwiTG9hZGVyID0gcmVxdWlyZSBcIi4uL3V0aWxzL2xvYWRlclwiXG5Nb2RlbCA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLk1vZGVsXG5cbm1vZHVsZS5leHBvcnRzID0gUGFja2FnZSA9IE1vZGVsLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChnKSAtPlxuICAgIEBnID0gZ1xuXG4gIGRldmVsb3BtZW50OlxuICAgIFwibXNhLXRudFwiOiBcIi9ub2RlX21vZHVsZXMvbXNhLXRudC9idWlsZC9idW5kbGUuanNcIlxuICAgIFwiYmlvanMtaW8tbmV3aWNrXCI6IFwiL25vZGVfbW9kdWxlcy9iaW9qcy1pby1uZXdpY2svYnVpbGQvYmlvanMtaW8tbmV3aWNrLm1pbi5qc1wiXG5cbiAgIyBsb2FkcyBhIHBhY2thZ2UgaW50byB0aGUgTVNBIGNvbXBvbmVudCAoaWYgaXQgaXMgbm90IGF2YWlsYWJsZSB5ZXQpXG4gIGxvYWRQYWNrYWdlOiAocGtnLCBjYikgLT5cbiAgICB0cnlcbiAgICAgIHAgPSByZXF1aXJlIHBrZ1xuICAgICAgY2IgcFxuICAgIGNhdGNoXG4gICAgICBMb2FkZXIubG9hZFNjcmlwdCBAX3BrZ1VSTChwa2cpLCBjYlxuXG4gICMgbG9hZHMgbXVsdGlwbGUgcGFja2FnZXMgYW5kIGNhbGxzIHRoZSBjYiBpZiBhbGwgcGFja2FnZXMgYXJlIGxvYWRlZFxuICBsb2FkUGFja2FnZXM6IChwa2dzLCBjYikgLT5cbiAgICAgIGNicyA9IExvYWRlci5qb2luQ2IgLT5cbiAgICAgICAgY2IoKVxuICAgICAgLCBwa2dzLmxlbmd0aFxuICAgICAgcGtncy5mb3JFYWNoIChwa2cpID0+XG4gICAgICAgIEBsb2FkUGFja2FnZSBwa2csIGNic1xuXG4gICMgaW50ZXJuYWwgbWV0aG9kIHRvIGdldCB0aGUgVVJMIGZvciBhIHBhY2thZ2VcbiAgX3BrZ1VSTDogKHBrZykgLT5cblxuICAgIGlmIEBnLmNvbmZpZy5nZXQoXCJkZWJ1Z1wiKVxuICAgICAgdXJsID0gQGRldmVsb3BtZW50W3BrZ11cbiAgICBlbHNlXG4gICAgICB1cmwgPSBcImh0dHA6Ly93enJkLmluL2J1bmRsZS8je3BrZ31AbGF0ZXN0XCJcblxuICAgIHVybFxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbk1vZGVsID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuTW9kZWxcblxuIyBob2xkcyB0aGUgY3VycmVudCB1c2VyIHNlbGVjdGlvblxuU2VsZWN0aW9uID0gTW9kZWwuZXh0ZW5kXG4gIGRlZmF1bHRzOlxuICAgIHR5cGU6IFwic3VwZXJcIlxuXG5Sb3dTZWxlY3Rpb24gPSBTZWxlY3Rpb24uZXh0ZW5kXG4gIGRlZmF1bHRzOiBfLmV4dGVuZCB7fSwgU2VsZWN0aW9uOjouZGVmYXVsdHMsXG4gICAgdHlwZTogXCJyb3dcIlxuICAgIHNlcUlkOiBcIlwiXG5cbiAgaW5Sb3c6IChzZXFJZCkgLT5cbiAgICBzZXFJZCBpcyBALmdldCBcInNlcUlkXCJcblxuICBpbkNvbHVtbjogKHJvd1BvcykgLT5cbiAgICB0cnVlXG5cbiAgZ2V0TGVuZ3RoOiAtPlxuICAgIDFcblxuQ29sdW1uU2VsZWN0aW9uID0gU2VsZWN0aW9uLmV4dGVuZFxuICBkZWZhdWx0czogXy5leHRlbmQge30sIFNlbGVjdGlvbjo6LmRlZmF1bHRzLFxuICAgIHR5cGU6IFwiY29sdW1uXCJcbiAgICB4U3RhcnQ6IC0xXG4gICAgeEVuZDogLTFcblxuICBpblJvdzogKCkgLT5cbiAgICB0cnVlXG5cbiAgaW5Db2x1bW46IChyb3dQb3MpIC0+XG4gICAgeFN0YXJ0IDw9IHJvd1BvcyAmJiByb3dQb3MgPD0geEVuZFxuXG4gIGdldExlbmd0aDogLT5cbiAgICB4RW5kIC0geFN0YXJ0XG5cbiMgcG9zIGlzIGEgbWl4aW4gb2YgY29sdW1uIGFuZCByb3dcbiMgc3RhcnQgd2l0aCBSb3cgYW5kIG9ubHkgb3ZlcndyaXRlIFwiaW5Db2x1bW5cIiBmcm9tIENvbHVtblxuUG9zU2VsZWN0aW9uID0gUm93U2VsZWN0aW9uLmV4dGVuZCBfLmV4dGVuZCB7fSxfLnBpY2soQ29sdW1uU2VsZWN0aW9uLFwiaW5Db2x1bW5cIiksXG4gIF8ucGljayhDb2x1bW5TZWxlY3Rpb24sXCJnZXRMZW5ndGhcIilcblxuICAjIG1lcmdlIGJvdGggZGVmYXVsdHNcbiAgZGVmYXVsdHM6IF8uZXh0ZW5kIHt9LCBDb2x1bW5TZWxlY3Rpb246Oi5kZWZhdWx0cywgUm93U2VsZWN0aW9uOjouZGVmYXVsdHMsXG4gICAgdHlwZTogXCJwb3NcIlxuXG5tb2R1bGUuZXhwb3J0cy5zZWwgPSBTZWxlY3Rpb25cbm1vZHVsZS5leHBvcnRzLnBvc3NlbCA9IFBvc1NlbGVjdGlvblxubW9kdWxlLmV4cG9ydHMucm93c2VsID0gUm93U2VsZWN0aW9uXG5tb2R1bGUuZXhwb3J0cy5jb2x1bW5zZWwgPSBDb2x1bW5TZWxlY3Rpb25cbiIsInNlbCA9IHJlcXVpcmUgXCIuL1NlbGVjdGlvblwiXG5fID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLkNvbGxlY3Rpb25cblxuIyBob2xkcyB0aGUgY3VycmVudCB1c2VyIHNlbGVjdGlvblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Rpb25NYW5hZ2VyID0gQ29sbGVjdGlvbi5leHRlbmRcblxuICBtb2RlbDogc2VsLnNlbFxuXG4gIGluaXRpYWxpemU6IChkYXRhLCBvcHRzKSAtPlxuICAgIGlmIG9wdHM/XG4gICAgICBAZyA9IG9wdHMuZ1xuXG4gICAgICBAbGlzdGVuVG8gQGcsIFwicmVzaWR1ZTpjbGlja1wiLCAoZSkgLT5cbiAgICAgICAgQF9oYW5kbGVFIGUuZXZ0LCBuZXcgc2VsLnBvc3NlbFxuICAgICAgICAgIHhTdGFydDogZS5yb3dQb3NcbiAgICAgICAgICB4RW5kOiBlLnJvd1Bvc1xuICAgICAgICAgIHNlcUlkOiBlLnNlcUlkXG5cbiAgICAgIEBsaXN0ZW5UbyBAZywgXCJyb3c6Y2xpY2tcIiwgKGUpIC0+XG4gICAgICAgIEBfaGFuZGxlRSBlLmV2dCwgbmV3IHNlbC5yb3dzZWxcbiAgICAgICAgICBzZXFJZDogZS5zZXFJZFxuXG4gICAgICBAbGlzdGVuVG8gQGcsIFwiY29sdW1uOmNsaWNrXCIsIChlKSAtPlxuICAgICAgICBAX2hhbmRsZUUgZS5ldnQsIG5ldyBzZWwuY29sdW1uc2VsXG4gICAgICAgICAgeFN0YXJ0OiBlLnJvd1Bvc1xuICAgICAgICAgIHhFbmQ6IGUucm93UG9zICsgZS5zdGVwU2l6ZSAtIDFcblxuICAgICNAbGlzdGVuVG8gQCwgXCJhZGQgcmVzZXRcIiwgKGUpIC0+XG4gICAgICAjQF9yZWR1Y2VDb2x1bW5zKClcblxuICBnZXRTZWxGb3JSb3c6IChzZXFJZCkgLT5cbiAgICBAZmlsdGVyIChlbCkgLT4gZWwuaW5Sb3cgc2VxSWRcblxuICBnZXRTZWxGb3JDb2x1bW5zOiAocm93UG9zKSAtPlxuICAgIEBmaWx0ZXIgKGVsKSAtPiBlbC5pbkNvbHVtbiByb3dQb3NcblxuICBhZGRKU09OOiAobW9kZWwpIC0+XG4gICAgQGFkZCBAX2Zyb21KU09OIG1vZGVsXG5cbiAgX2Zyb21KU09OOiAobW9kZWwpIC0+XG4gICBzd2l0Y2ggbW9kZWwudHlwZVxuICAgICB3aGVuIFwiY29sdW1uXCIgdGhlbiAgbmV3IHNlbC5jb2x1bW5zZWwgbW9kZWxcbiAgICAgd2hlbiBcInJvd1wiIHRoZW4gIG5ldyBzZWwucm93c2VsIG1vZGVsXG4gICAgIHdoZW4gXCJwb3NcIiB0aGVuICBuZXcgc2VsLnBvc3NlbCBtb2RlbFxuXG4gICMgYWxsb3dzIG5vcm1hbCBKU09OIGlucHV0XG4gIHJlc2V0SlNPTjogKGFycikgLT5cbiAgICBhcnIgPSBfLm1hcCBhcnIsIEBfZnJvbUpTT05cbiAgICBAcmVzZXQgYXJyXG5cbiAgIyBAcmV0dXJucyBhcnJheSBvZiBhbGwgc2VsZWN0ZWQgcmVzaWR1ZXMgZm9yIGEgcm93XG4gIGdldEJsb2Nrc0ZvclJvdzogKHNlcUlkLCBtYXhMZW4pIC0+XG4gICAgc2VsaXMgPSBAZmlsdGVyIChlbCkgLT4gZWwuaW5Sb3cgc2VxSWRcbiAgICBibG9ja3MgPSBbXVxuICAgIGZvciBzZWxpIGluIHNlbGlzXG4gICAgICBpZiBzZWxpLmF0dHJpYnV0ZXMudHlwZSBpcyBcInJvd1wiXG4gICAgICAgIGJsb2NrcyA9IFswLi5tYXhMZW5dXG4gICAgICAgIGJyZWFrXG4gICAgICBlbHNlXG4gICAgICAgIGJsb2NrcyA9IGJsb2Nrcy5jb25jYXQgW3NlbGkuYXR0cmlidXRlcy54U3RhcnQgLi4gc2VsaS5hdHRyaWJ1dGVzLnhFbmRdXG4gICAgYmxvY2tzXG5cbiAgIyBAcmV0dXJucyBhcnJheSB3aXRoIGFsbCBjb2x1bW5zIGJlaW5nIHNlbGVjdGVkXG4gICMgZXhhbXBsZTogMC00Li4uIDEyLTE0IHNlbGVjdGVkIC0+IFswLDEsMiwzLDQsMTIsMTMsMTRdXG4gIGdldEFsbENvbHVtbkJsb2NrczogKGNvbmYpIC0+XG4gICAgbWF4TGVuID0gY29uZi5tYXhMZW5cbiAgICB3aXRoUG9zID0gY29uZi53aXRoUG9zXG4gICAgYmxvY2tzID0gW11cbiAgICBpZiBjb25mLndpdGhQb3NcbiAgICAgIGZpbHRlcmVkID0gKEBmaWx0ZXIgKGVsKSAtPiBlbC5nZXQoJ3hTdGFydCcpPyApXG4gICAgZWxzZVxuICAgICAgZmlsdGVyZWQgPSAoQGZpbHRlciAoZWwpIC0+IGVsLmdldCgndHlwZScpIGlzIFwiY29sdW1uXCIpXG4gICAgZm9yIHNlbGkgaW4gZmlsdGVyZWRcbiAgICAgIGJsb2NrcyA9IGJsb2Nrcy5jb25jYXQgW3NlbGkuYXR0cmlidXRlcy54U3RhcnQuLnNlbGkuYXR0cmlidXRlcy54RW5kXVxuICAgIGJsb2NrcyA9IF8udW5pcSBibG9ja3NcbiAgICByZXR1cm4gYmxvY2tzXG5cbiAgIyBpbnZlcnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmb3IgY29sdW1uc1xuICAjIEBwYXJhbSByb3dzIFtBcnJheV0gYWxsIGF2YWlsYWJsZSBzZXFJZFxuICBpbnZlcnRSb3c6IChyb3dzKSAtPlxuICAgIHNlbFJvd3MgPSBAd2hlcmUodHlwZTpcInJvd1wiKVxuICAgIHNlbFJvd3MgPSBfLm1hcCBzZWxSb3dzLCAoZWwpIC0+IGVsLmF0dHJpYnV0ZXMuc2VxSWRcbiAgICBpbnZlcnRlZCA9IF8uZmlsdGVyIHJvd3MsIChlbCkgLT5cbiAgICAgIHJldHVybiBmYWxzZSBpZiBzZWxSb3dzLmluZGV4T2YoZWwpID49IDAgIyBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgIHRydWVcbiAgICAjIG1hc3MgaW5zZXJ0XG4gICAgcyA9IFtdXG4gICAgZm9yIGVsIGluIGludmVydGVkXG4gICAgICBzLnB1c2ggbmV3IHNlbC5yb3dzZWwoc2VxSWQ6ZWwpXG4gICAgQHJlc2V0IHNcblxuICAjIGludmVydHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGZvciByb3dzXG4gICMgQHBhcmFtIHJvd3MgW0FycmF5XSBhbGwgYXZhaWxhYmxlIHJvd3MgKDAuLm1heC5sZW5ndGgpXG4gIGludmVydENvbDogKGNvbHVtbnMpIC0+XG4gICAgc2VsQ29sdW1ucyA9IEB3aGVyZSh0eXBlOlwiY29sdW1uXCIpXG4gICAgc2VsQ29sdW1ucyA9IF8ucmVkdWNlIHNlbENvbHVtbnMsIChtZW1vLGVsKSAtPlxuICAgICAgbWVtby5jb25jYXQgW2VsLmF0dHJpYnV0ZXMueFN0YXJ0IC4uIGVsLmF0dHJpYnV0ZXMueEVuZF1cbiAgICAsIFtdXG4gICAgaW52ZXJ0ZWQgPSBfLmZpbHRlciBjb2x1bW5zLCAoZWwpIC0+XG4gICAgICBpZiBzZWxDb2x1bW5zLmluZGV4T2YoZWwpID49IDBcbiAgICAgICAgIyBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB0cnVlXG4gICAgIyBtYXNzIGluc2VydFxuICAgIHJldHVybiBpZiBpbnZlcnRlZC5sZW5ndGggPT0gMFxuICAgIHMgPSBbXVxuICAgIHhTdGFydCA9IHhFbmQgPSBpbnZlcnRlZFswXVxuICAgIGZvciBlbCBpbiBpbnZlcnRlZFxuICAgICAgaWYgeEVuZCArIDEgaXMgZWxcbiAgICAgICAgIyBjb250aWd1b3VzXG4gICAgICAgIHhFbmQgPSBlbFxuICAgICAgZWxzZVxuICAgICAgICAjIGdhcCBiZXR3ZWVuXG4gICAgICAgIHMucHVzaCBuZXcgc2VsLmNvbHVtbnNlbCh4U3RhcnQ6eFN0YXJ0LCB4RW5kOiB4RW5kKVxuICAgICAgICB4U3RhcnQgPSB4RW5kID0gZWxcbiAgICAjIGNoZWNrIGZvciBsYXN0IGdhcFxuICAgIHMucHVzaCBuZXcgc2VsLmNvbHVtbnNlbCh4U3RhcnQ6eFN0YXJ0LCB4RW5kOiBpbnZlcnRlZFtpbnZlcnRlZC5sZW5ndGggLSAxXSkgaWYgeFN0YXJ0IGlzbnQgeEVuZFxuICAgIEByZXNldCBzXG5cbiAgIyBtZXRob2QgdG8gZGVjaWRlIHdoZXRoZXIgdG8gc3RhcnQgYSBuZXcgc2VsZWN0aW9uXG4gICMgb3IgYXBwZW5kIHRvIHRoZSBvbGQgb25lIChkZXBlbmRpbmcgd2hldGhlciBDVFJMIHdhcyBwcmVzc2VkKVxuICBfaGFuZGxlRTogKGUsIHNlbGVjdGlvbikgLT5cbiAgICBpZiBlLmN0cmxLZXkgb3IgZS5tZXRhS2V5XG4gICAgICBAYWRkIHNlbGVjdGlvblxuICAgIGVsc2VcbiAgICAgIEByZXNldCBbc2VsZWN0aW9uXVxuXG4gICMgZXhwZXJpbWVudGFsIHJlZHVjZSBtZXRob2QgZm9yIGNvbHVtbnNcbiAgX3JlZHVjZUNvbHVtbnM6IC0+XG4gICAgQGVhY2ggKGVsLCBpbmRleCwgYXJyKSAtPlxuICAgICAgY29scyA9IF8uZmlsdGVyIGFyciwgKGVsKSAtPiBlbC5nZXQoJ3R5cGUnKSBpcyAnY29sdW1uJ1xuICAgICAgeFN0YXJ0ID0gZWwuZ2V0KCd4U3RhcnQnKVxuICAgICAgeEVuZCA9IGVsLmdldCgneEVuZCcpXG5cbiAgICAgIGxlZnRzID0gXy5maWx0ZXIgY29scywgKGVsKSAtPiBlbC5nZXQoJ3hFbmQnKSBpcyAoeFN0YXJ0IC0gMSlcbiAgICAgIGZvciBsZWZ0IGluIGxlZnRzXG4gICAgICAgIGxlZnQuc2V0ICd4RW5kJywgeFN0YXJ0XG5cbiAgICAgIHJpZ2h0cyA9IF8uZmlsdGVyIGNvbHMsIChlbCkgLT4gZWwuZ2V0KCd4U3RhcnQnKSBpcyAoeEVuZCArIDEpXG4gICAgICBmb3IgcmlnaHQgaW4gcmlnaHRzXG4gICAgICAgIHJpZ2h0LnNldCAneFN0YXJ0JywgeEVuZFxuXG4gICAgICBpZiBsZWZ0cy5sZW5ndGggPiAwIG9yIHJpZ2h0cy5sZW5ndGggPiAwXG4gICAgICAgIGNvbnNvbGUubG9nIFwicmVtb3ZlZCBlbFwiXG4gICAgICAgIGVsLmNvbGxlY3Rpb24ucmVtb3ZlIGVsXG4iLCJNb2RlbCA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLk1vZGVsXG5cbiMgc2ltcGxlIHVzZXIgY29uZmlnXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZyA9IE1vZGVsLmV4dGVuZFxuXG4gIGRlZmF1bHRzOlxuICAgIHNlYXJjaFRleHQ6IFwiXCJcbiIsIk1vZGVsID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuTW9kZWxcblxuIyB2aXNpYmxlIGFyZWFzXG5tb2R1bGUuZXhwb3J0cyA9IFZpc2liaWxpdHkgPSBNb2RlbC5leHRlbmRcblxuICBkZWZhdWx0czpcblxuICAgICMgZm9yIHRoZSBTdGFnZVxuICAgIHNlYXJjaEJveDogLTEwXG4gICAgb3ZlcnZpZXdCb3g6IDMwXG4gICAgaGVhZGVyQm94OiAtMVxuICAgIGFsaWdubWVudEJvZHk6IDBcbiIsIk1vZGVsID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuTW9kZWxcblxuIyB2aXNpYmxlIGFyZWFzXG5tb2R1bGUuZXhwb3J0cyA9IFZpc2liaWxpdHkgPSBNb2RlbC5leHRlbmRcblxuICBkZWZhdWx0czpcbiAgICBzZXF1ZW5jZXM6IHRydWVcbiAgICBtYXJrZXJzOiB0cnVlXG4gICAgbWV0YWNlbGw6IGZhbHNlXG4gICAgY29uc2VydjogZmFsc2VcbiAgICBvdmVydmlld2JveDogZmFsc2VcbiAgICBzZXFsb2dvOiBmYWxzZVxuICAgIGdhcEhlYWRlcjogZmFsc2VcbiAgICBsZWZ0SGVhZGVyOiB0cnVlXG5cbiAgICAjIGFib3V0IHRoZSBsYWJlbHNcbiAgICBsYWJlbHM6IHRydWVcbiAgICBsYWJlbE5hbWU6IHRydWVcbiAgICBsYWJlbElkOiB0cnVlXG4gICAgbGFiZWxQYXJ0aXRpb246IGZhbHNlXG4gICAgbGFiZWxDaGVja2JveDogZmFsc2VcblxuICAgICMgbWV0YSBzdHVmZlxuICAgIG1ldGFHYXBzOiB0cnVlXG4gICAgbWV0YUlkZW50aXR5OiB0cnVlXG4gICAgbWV0YUxpbmtzOiB0cnVlXG5cbiAgY29uc3RydWN0b3I6IChhdHRyaWJ1dGVzLG9wdGlvbnMpIC0+XG4gICAgQGNhbGNEZWZhdWx0cyBvcHRpb25zLm1vZGVsXG4gICAgTW9kZWwuYXBwbHkgQCwgYXJndW1lbnRzXG5cbiAgaW5pdGlhbGl6ZTogLT5cblxuICAgIEBsaXN0ZW5UbyBALCBcImNoYW5nZTptZXRhTGlua3MgY2hhbmdlOm1ldGFJZGVudGl0eSBjaGFuZ2U6bWV0YUdhcHNcIiwgLT5cbiAgICAgIEB0cmlnZ2VyIFwiY2hhbmdlOm1ldGFjZWxsXCJcbiAgICAsIEBcblxuICAgIEBsaXN0ZW5UbyBALCBcImNoYW5nZTpsYWJlbE5hbWUgY2hhbmdlOmxhYmVsSWQgY2hhbmdlOmxhYmVsUGFydGl0aW9uIGNoYW5nZTpsYWJlbENoZWNrYm94XCIsIC0+XG4gICAgICBAdHJpZ2dlciBcImNoYW5nZTpsYWJlbHNcIlxuICAgICwgQFxuXG4gICAgQGxpc3RlblRvIEAsXCJjaGFuZ2U6bWFya2VycyBjaGFuZ2U6Y29uc2VydiBjaGFuZ2U6c2VxbG9nbyBjaGFuZ2U6Z2FwSGVhZGVyXCIsIC0+XG4gICAgICBAdHJpZ2dlciBcImNoYW5nZTpoZWFkZXJcIlxuICAgICwgQFxuXG4gIGNhbGNEZWZhdWx0czogKHNlcXMpIC0+XG4gICAgaWYgc2Vxcy5sZW5ndGggPiAwXG4gICAgICBzZXEgPSBzZXFzLmF0KDApXG4gICAgICBpZHMgPSBzZXEuZ2V0IFwiaWRzXCJcbiAgICAgIGlmIGlkcyBpc250IHVuZGVmaW5lZCBhbmQgT2JqZWN0LmtleXMoaWRzKS5sZW5ndGggaXMgMFxuICAgICAgICBAZGVmYXVsdHMubWV0YUxpbmtzID0gZmFsc2VcbiIsIk1vZGVsID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuTW9kZWxcbiMgcGl4ZWwgcHJvcGVydGllcyBmb3Igc29tZSBjb21wb25lbnRzXG5tb2R1bGUuZXhwb3J0cyA9IFpvb21lciA9IE1vZGVsLmV4dGVuZFxuXG4gIGNvbnN0cnVjdG9yOiAoYXR0cmlidXRlcyxvcHRpb25zKSAtPlxuICAgIEBjYWxjRGVmYXVsdHMgb3B0aW9ucy5tb2RlbFxuICAgIE1vZGVsLmFwcGx5IEAsIGFyZ3VtZW50c1xuICAgIEBnID0gb3B0aW9ucy5nXG5cbiAgICAjIGV2ZW50c1xuICAgIEBsaXN0ZW5UbyBALCBcImNoYW5nZTpsYWJlbElkTGVuZ3RoIGNoYW5nZTpsYWJlbE5hbWVMZW5ndGggY2hhbmdlOmxhYmVsUGFydExlbmd0aCBjaGFuZ2U6bGFiZWxDaGVja0xlbmd0aFwiLCAtPlxuICAgICAgQHRyaWdnZXIgXCJjaGFuZ2U6bGFiZWxXaWR0aFwiLCBAZ2V0TGFiZWxXaWR0aCgpXG4gICAgLCBAXG4gICAgQGxpc3RlblRvIEAsIFwiY2hhbmdlOm1ldGFMaW5rc1dpZHRoIGNoYW5nZTptZXRhSWRlbnRXaWR0aCBjaGFuZ2U6bWV0YUdhcFdpZHRoXCIsIC0+XG4gICAgICBAdHJpZ2dlciBcImNoYW5nZTptZXRhV2lkdGhcIiwgQGdldE1ldGFXaWR0aCgpXG4gICAgLCBAXG5cbiAgICBAXG5cbiAgZGVmYXVsdHM6XG5cbiAgICAjIGdlbmVyYWxcbiAgICBhbGlnbm1lbnRXaWR0aDogXCJhdXRvXCJcbiAgICBhbGlnbm1lbnRIZWlnaHQ6IDIyNVxuICAgIGNvbHVtbldpZHRoOiAxNVxuICAgIHJvd0hlaWdodDogMTVcbiAgICBhdXRvUmVzaXplOiB0cnVlICMgb25seSBmb3IgdGhlIHdpZHRoXG5cbiAgICAjIGxhYmVsc1xuICAgIHRleHRWaXNpYmxlOiB0cnVlXG4gICAgbGFiZWxJZExlbmd0aDogNTBcbiAgICBsYWJlbE5hbWVMZW5ndGg6IDEwMFxuICAgIGxhYmVsUGFydExlbmd0aDogMTVcbiAgICBsYWJlbENoZWNrTGVuZ3RoOiAxNVxuICAgIGxhYmVsRm9udHNpemU6IDEzXG4gICAgbGFiZWxMaW5lSGVpZ2h0OiBcIjEzcHhcIlxuXG4gICAgIyBtYXJrZXJcbiAgICBtYXJrZXJGb250c2l6ZTogXCIxMHB4XCJcbiAgICBzdGVwU2l6ZTogMVxuICAgIG1hcmtlclN0ZXBTaXplOiAyXG4gICAgbWFya2VySGVpZ2h0OiAyMFxuXG4gICAgIyBjYW52YXNcbiAgICByZXNpZHVlRm9udDogXCIxM1wiICMgaW4gcHhcbiAgICBjYW52YXNFdmVudFNjYWxlOiAxXG5cbiAgICAjIG92ZXJ2aWV3IGJveFxuICAgIGJveFJlY3RIZWlnaHQ6IDJcbiAgICBib3hSZWN0V2lkdGg6IDJcbiAgICBvdmVydmlld2JveFBhZGRpbmdUb3A6IDEwXG5cbiAgICAjIG1lbnVcbiAgICBtZW51Rm9udHNpemU6IFwiMTRweFwiXG4gICAgbWVudUl0ZW1Gb250c2l6ZTogXCIxNHB4XCJcbiAgICBtZW51SXRlbUxpbmVIZWlnaHQ6IFwiMTRweFwiXG4gICAgbWVudU1hcmdpbkxlZnQ6IFwiM3B4XCJcbiAgICBtZW51UGFkZGluZzogXCIzcHggNHB4IDNweCA0cHhcIlxuXG4gICAgIyBtZXRhIGNlbGxcbiAgICBtZXRhR2FwV2lkdGg6IDM1XG4gICAgbWV0YUlkZW50V2lkdGg6IDQwXG4gICAgbWV0YUxpbmtzV2lkdGg6IDI1XG5cbiAgICAjIGludGVybmFsIHByb3BzXG4gICAgX2FsaWdubWVudFNjcm9sbExlZnQ6IDBcbiAgICBfYWxpZ25tZW50U2Nyb2xsVG9wOiAwXG5cbiAgIyBzZXRzIHNvbWUgZGVmYXVsdHMsIGRlcGVuZGluZyBvbiB0aGUgbW9kZWxcbiAgY2FsY0RlZmF1bHRzOiAobW9kZWwpIC0+XG4gICAgbWF4TGVuID0gbW9kZWwuZ2V0TWF4TGVuZ3RoKClcbiAgICBpZiBtYXhMZW4gPCAyMDAgYW5kIG1vZGVsLmxlbmd0aCA8IDMwXG4gICAgICBAZGVmYXVsdHMuYm94UmVjdFdpZHRoID0gQGRlZmF1bHRzLmJveFJlY3RIZWlnaHQgPSA1XG5cbiAgIyBAcGFyYW0gbiBbaW50XSBtYXhMZW5ndGggb2YgYWxsIHNlcXNcbiAgZ2V0QWxpZ25tZW50V2lkdGg6IChuKSAtPlxuICAgIGlmIEBnZXQoXCJhdXRvUmVzaXplXCIpIGFuZCBuIGlzbnQgdW5kZWZpbmVkXG4gICAgICByZXR1cm4gQGdldChcImNvbHVtbldpZHRoXCIpICogblxuICAgIGlmIEBnZXQoXCJhbGlnbm1lbnRXaWR0aFwiKSBpcyB1bmRlZmluZWQgb3IgQGdldChcImFsaWdubWVudFdpZHRoXCIpIGlzIFwiYXV0b1wiIG9yIEBnZXQoXCJhbGlnbm1lbnRXaWR0aFwiKSBpcyAwXG4gICAgICBAX2FkanVzdFdpZHRoKClcbiAgICBlbHNlXG4gICAgICBAZ2V0IFwiYWxpZ25tZW50V2lkdGhcIlxuXG4gICMgQHBhcmFtIG4gW2ludF0gbnVtYmVyIG9mIHJlc2lkdWVzIHRvIHNjcm9sbCB0byB0aGUgcmlnaHRcbiAgc2V0TGVmdE9mZnNldDogKG4pIC0+XG4gICAgdmFsID0gKG4pXG4gICAgdmFsID0gTWF0aC5tYXggMCwgdmFsXG4gICAgdmFsIC09IEBnLmNvbHVtbnMuY2FsY0hpZGRlbkNvbHVtbnMgdmFsXG4gICAgQHNldCBcIl9hbGlnbm1lbnRTY3JvbGxMZWZ0XCIsIHZhbCAqIEBnZXQoJ2NvbHVtbldpZHRoJylcblxuICAjIEBwYXJhbSBuIFtpbnRdIHJvdyB0aGF0IHNob3VsZCBiZSBvbiB0b3BcbiAgc2V0VG9wT2Zmc2V0OiAobikgLT5cbiAgICB2YWwgPSBNYXRoLm1heCAwLCAobiAtIDEpXG4gICAgaGVpZ2h0ID0gMFxuICAgIGZvciBpIGluIFswLi52YWxdIGJ5IDFcbiAgICAgIHNlcSA9IEBtb2RlbC5hdCBpXG4gICAgICBoZWlnaHQgKz0gc2VxLmF0dHJpYnV0ZXMuaGVpZ2h0IHx8IDFcbiAgICBAc2V0IFwiX2FsaWdubWVudFNjcm9sbFRvcFwiLGhlaWdodCAqIEBnZXQoXCJyb3dIZWlnaHRcIilcblxuICAjIGxlbmd0aCBvZiBhbGwgZWxlbWVudHMgbGVmdCB0byB0aGUgbWFpbiBzZXF1ZW5jZSBib2R5OiBsYWJlbHMsIG1ldGFjZWxsLCAuLlxuICBnZXRMZWZ0QmxvY2tXaWR0aDogLT5cbiAgICAgcGFkZGluZ0xlZnQgPSAwXG4gICAgIHBhZGRpbmdMZWZ0ICs9IEBnZXRMYWJlbFdpZHRoKCkgaWYgQGcudmlzLmdldCBcImxhYmVsc1wiXG4gICAgIHBhZGRpbmdMZWZ0ICs9IEBnZXRNZXRhV2lkdGgoKSBpZiBAZy52aXMuZ2V0IFwibWV0YWNlbGxcIlxuICAgICAjcGFkZGluZ0xlZnQgKz0gMTUgIyBzY3JvbGwgYmFyXG4gICAgIHJldHVybiBwYWRkaW5nTGVmdFxuXG4gIGdldE1ldGFXaWR0aDogLT5cbiAgICAgdmFsID0gMFxuICAgICB2YWwgKz0gQGdldCBcIm1ldGFHYXBXaWR0aFwiIGlmIEBnLnZpcy5nZXQgXCJtZXRhR2Fwc1wiXG4gICAgIHZhbCArPSBAZ2V0IFwibWV0YUlkZW50V2lkdGhcIiBpZiBAZy52aXMuZ2V0IFwibWV0YUlkZW50aXR5XCJcbiAgICAgdmFsICs9IEBnZXQgXCJtZXRhTGlua3NXaWR0aFwiIGlmIEBnLnZpcy5nZXQgXCJtZXRhTGlua3NcIlxuICAgICB2YWxcblxuICBnZXRMYWJlbFdpZHRoOiAtPlxuICAgICB2YWwgPSAwXG4gICAgIHZhbCArPSBAZ2V0IFwibGFiZWxOYW1lTGVuZ3RoXCIgaWYgQGcudmlzLmdldCBcImxhYmVsTmFtZVwiXG4gICAgIHZhbCArPSBAZ2V0IFwibGFiZWxJZExlbmd0aFwiIGlmIEBnLnZpcy5nZXQgXCJsYWJlbElkXCJcbiAgICAgdmFsICs9IEBnZXQgXCJsYWJlbFBhcnRMZW5ndGhcIiBpZiBAZy52aXMuZ2V0IFwibGFiZWxQYXJ0aXRpb25cIlxuICAgICB2YWwgKz0gQGdldCBcImxhYmVsQ2hlY2tMZW5ndGhcIiBpZiBAZy52aXMuZ2V0IFwibGFiZWxDaGVja2JveFwiXG4gICAgIHZhbFxuXG4gIF9hZGp1c3RXaWR0aDogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBlbCBpc250IHVuZGVmaW5lZCBhbmQgQG1vZGVsIGlzbnQgdW5kZWZpbmVkXG4gICAgaWYgQGVsLnBhcmVudE5vZGU/IGFuZCBAZWwucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCBpc250IDBcbiAgICAgIHBhcmVudFdpZHRoID0gQGVsLnBhcmVudE5vZGUub2Zmc2V0V2lkdGhcbiAgICBlbHNlXG4gICAgICBwYXJlbnRXaWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggLSAzNVxuXG4gICAgIyBUT0RPOiBkaXJ0eSBoYWNrXG4gICAgbWF4V2lkdGggPSBwYXJlbnRXaWR0aCAtIEBnZXRMZWZ0QmxvY2tXaWR0aCgpXG4gICAgY2FsY1dpZHRoID0gQGdldEFsaWdubWVudFdpZHRoKCBAbW9kZWwuZ2V0TWF4TGVuZ3RoKCkgLSBAZy5jb2x1bW5zLmdldCgnaGlkZGVuJykubGVuZ3RoKVxuICAgIHZhbCA9IE1hdGgubWluKG1heFdpZHRoLGNhbGNXaWR0aClcbiAgICAjIHJvdW5kIHRvIGEgdmFsaWQgQUEgYm94XG4gICAgdmFsID0gTWF0aC5mbG9vciggdmFsIC8gQGdldChcImNvbHVtbldpZHRoXCIpKSAqIEBnZXQoXCJjb2x1bW5XaWR0aFwiKVxuXG4gICAgI0BzZXQgXCJhbGlnbm1lbnRXaWR0aFwiLCB2YWxcbiAgICBALmF0dHJpYnV0ZXMuYWxpZ25tZW50V2lkdGggPSB2YWxcblxuICBhdXRvUmVzaXplOiAgLT5cbiAgICBpZiBAZ2V0IFwiYXV0b1Jlc2l6ZVwiXG4gICAgICBAX2FkanVzdFdpZHRoIEBlbCwgQG1vZGVsXG5cbiAgIyBtYXggaXMgdGhlIG1heGltYWwgYWxsb3dlZCBoZWlnaHRcbiAgYXV0b0hlaWdodDogKG1heCkgLT5cbiAgICAjIFRPRE8hXG4gICAgIyBtYWtlIHNlcWxvZ28gaGVpZ2h0IGNvbmZpZ3VyYWJsZVxuICAgIHZhbCA9IEBnZXRNYXhBbGlnbm1lbnRIZWlnaHQoKVxuICAgIGlmIG1heCAhPSB1bmRlZmluZWQgYW5kIG1heCA+IDBcbiAgICAgIHZhbCA9IE1hdGgubWluIHZhbCwgbWF4XG5cbiAgICBAc2V0IFwiYWxpZ25tZW50SGVpZ2h0XCIsIHZhbFxuXG4gIHNldEVsOiAoZWwsIG1vZGVsKSAtPlxuICAgIEBlbCA9IGVsXG4gICAgQG1vZGVsID0gbW9kZWxcblxuICAjIHVwZGF0ZXMgYm90aCBzY3JvbGwgcHJvcGVydGllcyAoaWYgbmVlZGVkKVxuICBfY2hlY2tTY3JvbGxpbmc6IChzY3JvbGxPYmosIG9wdHMpIC0+XG4gICAgeFNjcm9sbCA9IHNjcm9sbE9ialswXVxuICAgIHlTY3JvbGwgPSBzY3JvbGxPYmpbMV1cblxuICAgIEBzZXQgXCJfYWxpZ25tZW50U2Nyb2xsTGVmdFwiLCB4U2Nyb2xsLCBvcHRzXG4gICAgQHNldCBcIl9hbGlnbm1lbnRTY3JvbGxUb3BcIiwgeVNjcm9sbCwgb3B0c1xuXG4gIGdldE1heEFsaWdubWVudEhlaWdodDogLT5cbiAgICBoZWlnaHQgPSAwXG4gICAgQG1vZGVsLmVhY2ggKHNlcSkgLT5cbiAgICAgIGhlaWdodCArPSBzZXEuYXR0cmlidXRlcy5oZWlnaHQgfHwgMVxuXG4gICAgcmV0dXJuIChoZWlnaHQgKiBAZ2V0KFwicm93SGVpZ2h0XCIpKVxuXG4gIGdldE1heEFsaWdubWVudFdpZHRoOiAtPlxuICAgIHJldHVybiBAbW9kZWwuZ2V0TWF4TGVuZ3RoKCkgKiBAZ2V0KFwiY29sdW1uV2lkdGhcIilcblxuIiwiTVNBID0gcmVxdWlyZShcIi4vbXNhXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cbiAgbXNhID0gKGFyZ3MpIC0+XG4gICAgTVNBLmFwcGx5IEAsIGFyZ3NcbiAgbXNhOjogPSBNU0E6OlxuICBuZXcgbXNhIGFyZ3VtZW50c1xuXG5tb2R1bGUuZXhwb3J0cy5tc2EgPSBNU0FcblxuIyBtb2RlbHNcbm1vZHVsZS5leHBvcnRzLm1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWxcIilcblxuIyBleHRyYSBwbHVnaW5zLCBleHRlbnNpb25zXG5tb2R1bGUuZXhwb3J0cy5tZW51ID0gcmVxdWlyZShcIi4vbWVudVwiKVxubW9kdWxlLmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKVxuXG4jIHByb2JhYmx5IG5lZWRlZCBtb3JlIG9mdGVuXG5tb2R1bGUuZXhwb3J0cy5zZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9nL3NlbGVjdGlvbi9TZWxlY3Rpb25cIilcbm1vZHVsZS5leHBvcnRzLnNlbGNvbCA9IHJlcXVpcmUoXCIuL2cvc2VsZWN0aW9uL1NlbGVjdGlvbkNvbFwiKVxubW9kdWxlLmV4cG9ydHMudmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS12aWV3alwiKVxubW9kdWxlLmV4cG9ydHMuYm9uZVZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtY2hpbGRzXCIpXG5cbiMgY29udmVuaWVuY2Vcbm1vZHVsZS5leHBvcnRzLl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xubW9kdWxlLmV4cG9ydHMuJCA9IHJlcXVpcmUgJ2pib25lJ1xuXG4jIHBhcnNlciAoYXJlIGN1cnJlbnRseSBidW5kbGVkIC0gc28gd2UgY2FuIGFsc28gZXhwb3NlIHRoZW0pXG5tb2R1bGUuZXhwb3J0cy5pbyA9IHt9XG5tb2R1bGUuZXhwb3J0cy5pby54aHIgPSByZXF1aXJlICd4aHInXG5tb2R1bGUuZXhwb3J0cy5pby5mYXN0YSA9IHJlcXVpcmUgJ2Jpb2pzLWlvLWZhc3RhJ1xubW9kdWxlLmV4cG9ydHMuaW8uY2x1c3RhbCA9IHJlcXVpcmUgJ2Jpb2pzLWlvLWNsdXN0YWwnXG5tb2R1bGUuZXhwb3J0cy5pby5nZmYgPSByZXF1aXJlICdiaW9qcy1pby1nZmYnXG5cbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSBcIjAuMi4wXCJcbiIsImJvbmVWaWV3ID0gcmVxdWlyZShcImJhY2tib25lLWNoaWxkc1wiKVxuXG4jIG1lbnUgdmlld3NcbkltcG9ydE1lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9JbXBvcnRNZW51XCJcbkZpbHRlck1lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9GaWx0ZXJNZW51XCJcblNlbGVjdGlvbk1lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9TZWxlY3Rpb25NZW51XCJcblZpc01lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9WaXNNZW51XCJcbkNvbG9yTWVudSA9IHJlcXVpcmUgXCIuL3ZpZXdzL0NvbG9yTWVudVwiXG5PcmRlcmluZ01lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9PcmRlcmluZ01lbnVcIlxuRXh0cmFNZW51ID0gcmVxdWlyZSBcIi4vdmlld3MvRXh0cmFNZW51XCJcbkV4cG9ydE1lbnUgPSByZXF1aXJlIFwiLi92aWV3cy9FeHBvcnRNZW51XCJcbkhlbHBNZW51ID0gcmVxdWlyZSBcIi4vdmlld3MvSGVscE1lbnVcIlxuRGVidWdNZW51ID0gcmVxdWlyZSBcIi4vdmlld3MvRGVidWdNZW51XCJcblxuIyB0aGlzIHZlcnkgYmFzaWMgbWVudSBkZW1vbnN0cmF0ZXMgY2FsbHMgdG8gdGhlIE1TQSBjb21wb25lbnRcbm1vZHVsZS5leHBvcnRzID0gTWVudVZpZXcgPSBib25lVmlldy5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAbXNhID0gZGF0YS5tc2FcblxuICAgIEBhZGRWaWV3ICBcIjEwX2ltcG9ydFwiLCBuZXcgSW1wb3J0TWVudSBtb2RlbDogQG1zYS5zZXFzLCBnOkBtc2EuZywgbXNhOiBAbXNhXG4gICAgQGFkZFZpZXcgIFwiMjBfZmlsdGVyXCIsIG5ldyBGaWx0ZXJNZW51IG1vZGVsOiBAbXNhLnNlcXMsIGc6QG1zYS5nXG4gICAgQGFkZFZpZXcgIFwiMzBfc2VsZWN0aW9uXCIsIG5ldyBTZWxlY3Rpb25NZW51IG1vZGVsOiBAbXNhLnNlcXMsIGc6QG1zYS5nXG4gICAgQGFkZFZpZXcgIFwiNDBfdmlzXCIsIG5ldyBWaXNNZW51IG1vZGVsOiBAbXNhLnNlcXMsIGc6QG1zYS5nXG4gICAgQGFkZFZpZXcgIFwiNTBfY29sb3JcIiwgbmV3IENvbG9yTWVudSBtb2RlbDogQG1zYS5zZXFzLCBnOkBtc2EuZ1xuICAgIEBhZGRWaWV3ICBcIjYwX29yZGVyaW5nXCIsIG5ldyBPcmRlcmluZ01lbnUgbW9kZWw6IEBtc2Euc2VxcywgZzpAbXNhLmdcbiAgICBAYWRkVmlldyAgXCI3MF9leHRyYVwiLCBuZXcgRXh0cmFNZW51IG1vZGVsOiBAbXNhLnNlcXMsIGc6QG1zYS5nLCBtc2E6IEBtc2FcbiAgICBAYWRkVmlldyAgXCI4MF9leHBvcnRcIiwgbmV3IEV4cG9ydE1lbnUgbW9kZWw6IEBtc2Euc2VxcywgZzpAbXNhLmcsIG1zYTpAbXNhXG4gICAgQGFkZFZpZXcgIFwiOTBfaGVscFwiLCBuZXcgSGVscE1lbnUgIGc6QG1zYS5nXG4gICAgaWYgQG1zYS5nLmNvbmZpZy5nZXQoXCJkZWJ1Z1wiKVxuICAgICAgQGFkZFZpZXcgIFwiOTVfZGVidWdcIiwgbmV3IERlYnVnTWVudSAgZzpAbXNhLmdcblxuICByZW5kZXI6IC0+XG4gICAgQHJlbmRlclN1YnZpZXdzKClcbiAgICAjIG90aGVyXG4gICAgQGVsLnNldEF0dHJpYnV0ZSBcImNsYXNzXCIsIFwic21lbnViYXJcIlxuICAgIEBlbC5hcHBlbmRDaGlsZCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKVxuIiwibW9kdWxlLmV4cG9ydHMuZGVmYXVsdG1lbnUgPSByZXF1aXJlKFwiLi9kZWZhdWx0bWVudVwiKVxubW9kdWxlLmV4cG9ydHMubWVudWJ1aWxkZXIgPSByZXF1aXJlKFwiLi9tZW51YnVpbGRlclwiKVxuIiwiYnVpbGRlciA9IHJlcXVpcmUgXCJtZW51LWJ1aWxkZXJcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbnVCdWlsZGVyID0gYnVpbGRlci5leHRlbmRcblxuICAgIGJ1aWxkRE9NOiAtPlxuICAgICAgQC5vbiBcIm5ldzpub2RlXCIsIEBidWlsZE5vZGVcbiAgICAgIEAub24gXCJuZXc6YnV0dG9uXCIsIEBidWlsZEJ1dHRvblxuICAgICAgQC5vbiBcIm5ldzptZW51XCIsIEBidWlsZE1lbnVcbiAgICAgIHJldHVybiBidWlsZGVyOjpidWlsZERPTS5jYWxsIEBcblxuICAgIGJ1aWxkTm9kZTogKGxpKSAtPlxuICAgICAgaWYgQGc/XG4gICAgICAgIGxpLnN0eWxlLmxpbmVIZWlnaHQgPSBAZy56b29tZXIuZ2V0IFwibWVudUl0ZW1MaW5lSGVpZ2h0XCJcblxuICAgIGJ1aWxkQnV0dG9uOiAoYnRuKSAtPlxuICAgICAgaWYgQGc/XG4gICAgICAgIGJ0bi5zdHlsZS5mb250U2l6ZSA9IEBnLnpvb21lci5nZXQgXCJtZW51Rm9udHNpemVcIlxuICAgICAgICBidG4uc3R5bGUubWFyZ2luTGVmdCA9IEBnLnpvb21lci5nZXQgXCJtZW51TWFyZ2luTGVmdFwiXG4gICAgICAgIGJ0bi5zdHlsZS5wYWRkaW5nID0gQGcuem9vbWVyLmdldCBcIm1lbnVQYWRkaW5nXCJcblxuICAgIGJ1aWxkTWVudTogKG1lbnUpIC0+XG4gICAgICBpZiBAZz9cbiAgICAgICAgbWVudS5zdHlsZS5mb250U2l6ZSA9IEBnLnpvb21lci5nZXQgXCJtZW51SXRlbUZvbnRzaXplXCJcbiIsIk1lbnVCdWlsZGVyID0gcmVxdWlyZSBcIi4uL21lbnVidWlsZGVyXCJcbl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5kb20gPSByZXF1aXJlIFwiZG9tLWhlbHBlclwiXG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3JNZW51ID0gTWVudUJ1aWxkZXIuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQGcgPSBkYXRhLmdcbiAgICBAZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICBAbGlzdGVuVG8gQGcuY29sb3JzY2hlbWUsIFwiY2hhbmdlXCIsIC0+XG4gICAgICBAcmVuZGVyKClcblxuICByZW5kZXI6IC0+XG4gICAgbWVudUNvbG9yID0gQHNldE5hbWUoXCJDb2xvciBzY2hlbWVcIilcbiAgICBAcmVtb3ZlQWxsTm9kZXMoKVxuXG4gICAgY29sb3JzY2hlbWVzID0gQGdldENvbG9yc2NoZW1lcygpXG4gICAgZm9yIHNjaGVtZSBpbiBjb2xvcnNjaGVtZXNcbiAgICAgIEBhZGRTY2hlbWUgbWVudUNvbG9yLCBzY2hlbWVcblxuICAgIHRleHQgPSBcIkJhY2tncm91bmRcIlxuICAgIGlmIEBnLmNvbG9yc2NoZW1lLmdldChcImNvbG9yQmFja2dyb3VuZFwiKVxuICAgICAgdGV4dCA9IFwiSGlkZSBcIiArIHRleHRcbiAgICBlbHNlXG4gICAgICB0ZXh0ID0gXCJTaG93IFwiICsgdGV4dFxuXG4gICAgQGFkZE5vZGUgdGV4dCwgPT5cbiAgICAgIEBnLmNvbG9yc2NoZW1lLnNldCBcImNvbG9yQmFja2dyb3VuZFwiLCAhQGcuY29sb3JzY2hlbWUuZ2V0KFwiY29sb3JCYWNrZ3JvdW5kXCIpXG5cbiAgICBAZ3JleSBtZW51Q29sb3JcblxuICAgICMgVE9ETzogbWFrZSBtb3JlIGVmZmljaWVudFxuICAgIGRvbS5yZW1vdmVBbGxDaGlsZHMgQGVsXG4gICAgQGVsLmFwcGVuZENoaWxkIEBidWlsZERPTSgpXG4gICAgQFxuXG4gIGFkZFNjaGVtZTogKG1lbnVDb2xvcixzY2hlbWUpIC0+XG4gICAgc3R5bGUgPSB7fVxuICAgIGN1cnJlbnQgPSBAZy5jb2xvcnNjaGVtZS5nZXQoXCJzY2hlbWVcIilcbiAgICBpZiBjdXJyZW50IGlzIHNjaGVtZS5pZFxuICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjNzdFRDgwXCJcblxuICAgIEBhZGROb2RlIHNjaGVtZS5uYW1lLCA9PlxuICAgICAgQGcuY29sb3JzY2hlbWUuc2V0IFwic2NoZW1lXCIsIHNjaGVtZS5pZFxuICAgICxcbiAgICAgIHN0eWxlOiBzdHlsZVxuXG4gIGdldENvbG9yc2NoZW1lczogLT5cbiAgICBzY2hlbWVzICA9IFtdXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiWmFwcG9cIiwgaWQ6IFwiemFwcG9cIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIlRheWxvclwiLCBpZDogXCJ0YXlsb3JcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIkh5ZHJvcGhvYmljaXR5XCIsIGlkOiBcImh5ZHJvXCJcbiAgICBzY2hlbWVzLnB1c2ggbmFtZTogXCJMZXNrXCIsIGlkOiBcImxlc2tcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIkNpbmVtYVwiLCBpZDogXCJjaW5lbWFcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIk1BRVwiLCBpZDogXCJtYWVcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIkNsdXN0YWxcIiwgaWQ6IFwiY2x1c3RhbFwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiQ2x1c3RhbDJcIiwgaWQ6IFwiY2x1c3RhbDJcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIlR1cm5cIiwgaWQ6IFwidHVyblwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiU3RyYW5kXCIsIGlkOiBcInN0cmFuZFwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiQnVyaWVkXCIsIGlkOiBcImJ1cmllZFwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiSGVsaXhcIiwgaWQ6IFwiaGVsaXhcIlxuICAgIHNjaGVtZXMucHVzaCBuYW1lOiBcIk51Y2xlb3RpZGVcIiwgaWQ6IFwibnVjbGVvdGlkZVwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiUHVyaW5lXCIsIGlkOiBcInB1cmluZVwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiUElEXCIsIGlkOiBcInBpZFwiXG4gICAgc2NoZW1lcy5wdXNoIG5hbWU6IFwiTm8gY29sb3JcIiwgaWQ6IFwiZm9vXCJcbiAgICBzY2hlbWVzXG5cbiAgZ3JleTogKG1lbnVDb2xvcikgLT5cbiAgICAjIGdyZXlzIGFsbCBsb3dlcmNhc2UgbGV0dGVyc1xuICAgIEBhZGROb2RlIFwiU2hhZGVcIiwgPT5cbiAgICAgIEBnLmNvbG9yc2NoZW1lLnNldCBcInNob3dMb3dlckNhc2VcIiwgZmFsc2VcbiAgICAgIEBtb2RlbC5lYWNoIChzZXEpIC0+XG4gICAgICAgIHJlc2lkdWVzID0gc2VxLmdldCBcInNlcVwiXG4gICAgICAgIGdyZXkgPSBbXVxuICAgICAgICBfLmVhY2ggcmVzaWR1ZXMsIChlbCwgaW5kZXgpIC0+XG4gICAgICAgICAgaWYgZWwgaXMgZWwudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgZ3JleS5wdXNoIGluZGV4XG4gICAgICAgIHNlcS5zZXQgXCJncmV5XCIsIGdyZXlcblxuICAgIEBhZGROb2RlIFwiU2hhZGUgYnkgdGhyZXNob2xkXCIsID0+XG4gICAgICB0aHJlc2hvbGQgPSBwcm9tcHQgXCJFbnRlciB0aHJlc2hvbGQgKGluIHBlcmNlbnQpXCIsIDIwXG4gICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAxMDBcbiAgICAgIG1heExlbiA9IEBtb2RlbC5nZXRNYXhMZW5ndGgoKVxuICAgICAgIyBUT0RPOiBjYWNoZVxuICAgICAgY29uc2VydiA9IEBnLnN0YXRzLnNjYWxlIEBnLnN0YXRzLmNvbnNlcnZhdGlvbigpXG4gICAgICBncmV5ID0gW11cbiAgICAgIGZvciBpIGluIFswLi4gbWF4TGVuIC0gMV1cbiAgICAgICAgaWYgY29uc2VydltpXSA8IHRocmVzaG9sZFxuICAgICAgICAgIGdyZXkucHVzaCBpXG4gICAgICBAbW9kZWwuZWFjaCAoc2VxKSAtPlxuICAgICAgICBzZXEuc2V0IFwiZ3JleVwiLCBncmV5XG5cbiAgICBAYWRkTm9kZSBcIlNoYWRlIHNlbGVjdGlvblwiLCA9PlxuICAgICAgbWF4TGVuID0gQG1vZGVsLmdldE1heExlbmd0aCgpXG4gICAgICBAbW9kZWwuZWFjaCAoc2VxKSA9PlxuICAgICAgICBibG9ja3MgPSBAZy5zZWxjb2wuZ2V0QmxvY2tzRm9yUm93KHNlcS5nZXQoXCJpZFwiKSxtYXhMZW4pXG4gICAgICAgIHNlcS5zZXQgXCJncmV5XCIsIGJsb2Nrc1xuXG4gICAgQGFkZE5vZGUgXCJSZXNldCBzaGFkZVwiLCA9PlxuICAgICAgQGcuY29sb3JzY2hlbWUuc2V0IFwic2hvd0xvd2VyQ2FzZVwiLCB0cnVlXG4gICAgICBAbW9kZWwuZWFjaCAoc2VxKSAtPlxuICAgICAgICBzZXEuc2V0IFwiZ3JleVwiLCBbXVxuIiwiTWVudUJ1aWxkZXIgPSByZXF1aXJlIFwiLi4vbWVudWJ1aWxkZXJcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnTWVudSA9IE1lbnVCdWlsZGVyLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG5cbiAgcmVuZGVyOiAtPlxuICAgIEBzZXROYW1lKFwiRGVidWdcIilcblxuICAgIEBhZGROb2RlIFwiR2V0IHRoZSBjb2RlXCIsID0+XG4gICAgICB3aW5kb3cub3BlbiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbmlmeS9tc2FcIlxuXG4gICAgQGFkZE5vZGUgXCJUb2dnbGUgbW91c2VvdmVyIGV2ZW50c1wiLCA9PlxuICAgICAgQGcuY29uZmlnLnNldCBcInJlZ2lzdGVyTW91c2VIb3ZlclwiLCAhQGcuY29uZmlnLmdldCBcInJlZ2lzdGVyTW91c2VIb3ZlclwiXG4gICAgICBAZy5vbkFsbCAtPlxuICAgICAgICBjb25zb2xlLmxvZyBhcmd1bWVudHNcblxuICAgIEBlbC5hcHBlbmRDaGlsZCBAYnVpbGRET00oKVxuICAgIEBcbiIsIk1lbnVCdWlsZGVyID0gcmVxdWlyZSBcIi4uL21lbnVidWlsZGVyXCJcbkZhc3RhRXhwb3J0ZXIgPSByZXF1aXJlKFwiYmlvanMtaW8tZmFzdGFcIikud3JpdGVyXG5fID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuRXhwb3J0ZXIgPSByZXF1aXJlIFwiLi4vLi4vdXRpbHMvZXhwb3J0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBFeHBvcnRNZW51ID0gTWVudUJ1aWxkZXIuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQGcgPSBkYXRhLmdcbiAgICBAbXNhID0gZGF0YS5tc2FcbiAgICBAZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcblxuICByZW5kZXI6IC0+XG4gICAgQHNldE5hbWUoXCJFeHBvcnRcIilcblxuICAgIEBhZGROb2RlIFwiVmlldyBpbiBKYWx2aWV3XCIsID0+XG4gICAgICB1cmwgPSBAZy5jb25maWcuZ2V0KCd1cmwnKVxuICAgICAgdW5sZXNzIHVybD9cbiAgICAgICAgYWxlcnQgXCJTZXF1ZW5jZSB3ZXJlbid0IGltcG9ydGVkIHZpYSBhbiBVUkxcIlxuICAgICAgZWxzZVxuICAgICAgICBpZiB1cmwuaW5kZXhPZiBcImxvY2FsaG9zdFwiIG9yIHVybCBpcyBcImRyYWdpbXBvcnRcIlxuICAgICAgICAgIEV4cG9ydGVyLnB1Ymxpc2hXZWIgQG1zYSwgKGxpbmspID0+XG4gICAgICAgICAgICBFeHBvcnRlci5vcGVuSW5KYWx2aWV3IGxpbmssIEBnLmNvbG9yc2NoZW1lLmdldCBcInNjaGVtZVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBFeHBvcnRlci5vcGVuSW5KYWx2aWV3IHVybCwgQGcuY29sb3JzY2hlbWUuZ2V0IFwic2NoZW1lXCJcblxuICAgIEBhZGROb2RlIFwiUHVibGlzaCB0byB0aGUgd2ViXCIsID0+XG4gICAgICBFeHBvcnRlci5wdWJsaXNoV2ViIEBtc2EsIChsaW5rKSAtPlxuICAgICAgICB3aW5kb3cub3BlbiBsaW5rLCAnX2JsYW5rJ1xuXG4gICAgQGFkZE5vZGUgXCJTaGFyZSBsaW5rXCIsID0+XG4gICAgICBFeHBvcnRlci5zaGFyZUxpbmsgQG1zYSwgKGxpbmspIC0+XG4gICAgICAgIHdpbmRvdy5vcGVuIGxpbmssICdfYmxhbmsnXG5cbiAgICBAYWRkTm9kZSBcIkV4cG9ydCBzZXF1ZW5jZXNcIiwgPT5cbiAgICAgIEV4cG9ydGVyLnNhdmVBc0ZpbGUgQG1zYSwgXCJhbGwuZmFzdGFcIlxuXG4gICAgQGFkZE5vZGUgXCJFeHBvcnQgc2VsZWN0aW9uXCIsID0+XG4gICAgICBFeHBvcnRlci5zYXZlU2VsZWN0aW9uIEBtc2EsIFwic2VsZWN0aW9uLmZhc3RhXCJcblxuICAgIEBhZGROb2RlIFwiRXhwb3J0IGZlYXR1cmVzXCIsID0+XG4gICAgICBFeHBvcnRlci5zYXZlQW5ub3RzIEBtc2EsIFwiZmVhdHVyZXMuZ2ZmM1wiXG5cbiAgICBAYWRkTm9kZSBcIkV4cG9ydCBpbWFnZVwiLCA9PlxuICAgICAgRXhwb3J0ZXIuc2F2ZUFzSW1nIEBtc2EsIFwiYmlvanMtbXNhLnBuZ1wiXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgQGJ1aWxkRE9NKClcbiAgICBAXG4iLCJNZW51QnVpbGRlciA9IHJlcXVpcmUgXCIuLi9tZW51YnVpbGRlclwiXG5TZXEgPSByZXF1aXJlIFwiLi4vLi4vbW9kZWwvU2VxdWVuY2VcIlxuTG9hZGVyID0gcmVxdWlyZSBcIi4uLy4uL3V0aWxzL2xvYWRlclwiXG54aHIgPSByZXF1aXJlIFwieGhyXCJcblxubW9kdWxlLmV4cG9ydHMgPSBFeHRyYU1lbnUgPSBNZW51QnVpbGRlci5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBlbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgIEBtc2EgPSBkYXRhLm1zYVxuXG4gIHJlbmRlcjogLT5cbiAgICBAc2V0TmFtZShcIkV4dHJhc1wiKVxuICAgIHN0YXRzID0gQGcuc3RhdHNcbiAgICBtc2EgPSBAbXNhXG4gICAgQGFkZE5vZGUgXCJBZGQgY29uc2Vuc3VzIHNlcVwiLCA9PlxuICAgICAgY29uID0gc3RhdHMuY29uc2Vuc3VzKClcbiAgICAgIHNlcSA9IG5ldyBTZXFcbiAgICAgICAgc2VxOiBjb25cbiAgICAgICAgaWQ6IFwiMGNcIlxuICAgICAgICBuYW1lOiBcImNvbnNlbnVzXCJcbiAgICAgIEBtb2RlbC5hZGQgc2VxXG4gICAgICBAbW9kZWwuc2V0UmVmIHNlcVxuICAgICAgQG1vZGVsLmNvbXBhcmF0b3IgPSAoc2VxKSAtPlxuICAgICAgICBub3Qgc2VxLmdldCBcInJlZlwiXG4gICAgICBAbW9kZWwuc29ydCgpXG5cbiAgICBAYWRkTm9kZSBcIkNhbGMgVHJlZVwiLCAtPlxuICAgICAgIyB0aGlzIGlzIGEgdmVyeSBleHBlcmltZW50YWwgZmVhdHVyZVxuICAgICAgIyBUT0RPOiBleGNsdWRlIG1zYSAmIHRudCBpbiB0aGUgYWRhcHRlciBwYWNrYWdlXG4gICAgICBuZXdpY2tTdHIgPSBcIlwiXG5cbiAgICAgIGNicyA9IExvYWRlci5qb2luQ2IgLT5cbiAgICAgICAgbXNhLnUudHJlZS5zaG93VHJlZSBud2tEYXRhXG4gICAgICAsIDIsIEBcblxuICAgICAgbXNhLnUudHJlZS5sb2FkVHJlZSBjYnNcbiAgICAgICMgbG9hZCBmYWtlIHRyZWVcbiAgICAgIG53a0RhdGEgPVxuICAgICAgICBuYW1lOiBcInJvb3RcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICBuYW1lOiBcImMxXCIsXG4gICAgICAgICAgYnJhbmNoX2xlbmd0aDogNFxuICAgICAgICAgIGNoaWxkcmVuOiBtc2Euc2Vxcy5maWx0ZXIgKGYsaSkgLT4gIGkgJSAyIGlzIDBcbiAgICAgICAgLFxuICAgICAgICAgIG5hbWU6IFwiYzJcIixcbiAgICAgICAgICBjaGlsZHJlbjogbXNhLnNlcXMuZmlsdGVyIChmLGkpIC0+ICBpICUgMiBpcyAxXG4gICAgICAgICAgYnJhbmNoX2xlbmd0aDogNFxuICAgICAgICBdXG4gICAgICBtc2Euc2Vxcy5lYWNoIChzKSAtPlxuICAgICAgICBzLnNldCBcImJyYW5jaF9sZW5ndGhcIiwgMlxuICAgICAgY2JzKClcblxuICAgIEBhZGROb2RlIFwiSW5jcmVhc2UgZm9udCBzaXplXCIsID0+XG4gICAgICBjb2x1bW5XaWR0aCA9ICBAZy56b29tZXIuZ2V0KFwiY29sdW1uV2lkdGhcIilcbiAgICAgIG5Db2x1bW5XaWR0aCA9IGNvbHVtbldpZHRoICsgNVxuICAgICAgQGcuem9vbWVyLnNldCBcImNvbHVtbldpZHRoXCIsICBuQ29sdW1uV2lkdGhcbiAgICAgIEBnLnpvb21lci5zZXQgXCJyb3dIZWlnaHRcIiwgbkNvbHVtbldpZHRoXG4gICAgICBuRm9udFNpemUgPSBuQ29sdW1uV2lkdGggKiAwLjdcbiAgICAgIEBnLnpvb21lci5zZXQgXCJyZXNpZHVlRm9udFwiLCBuRm9udFNpemVcbiAgICAgIEBnLnpvb21lci5zZXQgXCJsYWJlbEZvbnRTaXplXCIsICBuRm9udFNpemVcbiAgICBAYWRkTm9kZSBcIkRlY3JlYXNlIGZvbnQgc2l6ZVwiLCA9PlxuICAgICAgY29sdW1uV2lkdGggPSAgQGcuem9vbWVyLmdldChcImNvbHVtbldpZHRoXCIpXG4gICAgICBuQ29sdW1uV2lkdGggPSBjb2x1bW5XaWR0aCAtIDJcbiAgICAgIEBnLnpvb21lci5zZXQgXCJjb2x1bW5XaWR0aFwiLCAgbkNvbHVtbldpZHRoXG4gICAgICBAZy56b29tZXIuc2V0IFwicm93SGVpZ2h0XCIsIG5Db2x1bW5XaWR0aFxuICAgICAgbkZvbnRTaXplID0gbkNvbHVtbldpZHRoICogMC42XG4gICAgICBAZy56b29tZXIuc2V0IFwicmVzaWR1ZUZvbnRcIiwgbkZvbnRTaXplXG4gICAgICBAZy56b29tZXIuc2V0IFwibGFiZWxGb250U2l6ZVwiLCAgbkZvbnRTaXplXG5cbiAgICAgIGlmIEBnLnpvb21lci5nZXQoXCJjb2x1bW5XaWR0aFwiKSA8IDhcbiAgICAgICAgQGcuem9vbWVyLnNldCBcInRleHRWaXNpYmxlXCIsIGZhbHNlXG5cbiAgICBAYWRkTm9kZSBcIk1pbmltaXplZCB3aWR0aFwiLCA9PlxuICAgICAgQGcuem9vbWVyLnNldCBcImFsaWdubWVudFdpZHRoXCIsIDYwMFxuICAgIEBhZGROb2RlIFwiTWluaW1pemVkIGhlaWdodFwiLCA9PlxuICAgICAgQGcuem9vbWVyLnNldCBcImFsaWdubWVudEhlaWdodFwiLCAxMjBcblxuICAgIEBhZGROb2RlIFwiSnVtcCB0byBhIGNvbHVtblwiLCA9PlxuICAgICAgb2Zmc2V0ID0gcHJvbXB0IFwiQ29sdW1uXCIsIFwiMjBcIlxuICAgICAgaWYgb2Zmc2V0IDwgMCBvciBvZmZzZXQgPiBAbW9kZWwuZ2V0TWF4TGVuZ3RoKCkgb3IgaXNOYU4ob2Zmc2V0KVxuICAgICAgICBhbGVydCBcImludmFsaWQgY29sdW1uXCJcbiAgICAgICAgcmV0dXJuXG4gICAgICBAZy56b29tZXIuc2V0TGVmdE9mZnNldChvZmZzZXQpXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgQGJ1aWxkRE9NKClcbiAgICBAXG4iLCJNZW51QnVpbGRlciA9IHJlcXVpcmUgXCIuLi9tZW51YnVpbGRlclwiXG5fID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlck1lbnUgPSBNZW51QnVpbGRlci5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBlbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuXG4gIHJlbmRlcjogLT5cbiAgICBAc2V0TmFtZShcIkZpbHRlclwiKVxuICAgIEBhZGROb2RlIFwiSGlkZSBjb2x1bW5zIGJ5IHRocmVzaG9sZFwiLChlKSA9PlxuICAgICAgdGhyZXNob2xkID0gcHJvbXB0IFwiRW50ZXIgdGhyZXNob2xkIChpbiBwZXJjZW50KVwiLCAyMFxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIC8gMTAwXG4gICAgICBtYXhMZW4gPSBAbW9kZWwuZ2V0TWF4TGVuZ3RoKClcbiAgICAgIGhpZGRlbiA9IFtdXG4gICAgICAjIFRPRE86IGNhY2hlIHRoaXMgdmFsdWVcbiAgICAgIGNvbnNlcnYgPSBAZy5zdGF0cy5zY2FsZShAZy5zdGF0cy5jb25zZXJ2YXRpb24oKSlcbiAgICAgIGZvciBpIGluIFswLi4gbWF4TGVuIC0gMV1cbiAgICAgICAgaWYgY29uc2VydltpXSA8IHRocmVzaG9sZFxuICAgICAgICAgIGhpZGRlbi5wdXNoIGlcbiAgICAgIEBnLmNvbHVtbnMuc2V0IFwiaGlkZGVuXCIsIGhpZGRlblxuXG4gICAgQGFkZE5vZGUgXCJIaWRlIGNvbHVtbnMgYnkgc2VsZWN0aW9uXCIsID0+XG4gICAgICBoaWRkZW5PbGQgPSBAZy5jb2x1bW5zLmdldCBcImhpZGRlblwiXG4gICAgICBoaWRkZW4gPSBoaWRkZW5PbGQuY29uY2F0IEBnLnNlbGNvbC5nZXRBbGxDb2x1bW5CbG9ja3MgbWF4TGVuOiBAbW9kZWwuZ2V0TWF4TGVuZ3RoKCksIHdpdGhQb3M6IHRydWVcbiAgICAgIEBnLnNlbGNvbC5yZXNldCBbXVxuICAgICAgQGcuY29sdW1ucy5zZXQgXCJoaWRkZW5cIiwgaGlkZGVuXG5cbiAgICBAYWRkTm9kZSBcIkhpZGUgY29sdW1ucyBieSBnYXBzXCIsID0+XG4gICAgICB0aHJlc2hvbGQgPSBwcm9tcHQgXCJFbnRlciB0aHJlc2hvbGQgKGluIHBlcmNlbnQpXCIsIDIwXG4gICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAxMDBcbiAgICAgIG1heExlbiA9IEBtb2RlbC5nZXRNYXhMZW5ndGgoKVxuICAgICAgaGlkZGVuID0gW11cbiAgICAgIGZvciBpIGluIFswLi4gbWF4TGVuIC0gMV1cbiAgICAgICAgZ2FwcyA9IDBcbiAgICAgICAgdG90YWwgPSAwXG4gICAgICAgIEBtb2RlbC5lYWNoIChlbCkgLT5cbiAgICAgICAgICBnYXBzKysgaWYgZWwuZ2V0KCdzZXEnKVtpXSBpcyBcIi1cIlxuICAgICAgICAgIHRvdGFsKytcbiAgICAgICAgZ2FwQ29udGVudCA9IGdhcHMgLyB0b3RhbFxuICAgICAgICBpZiBnYXBDb250ZW50ID4gdGhyZXNob2xkXG4gICAgICAgICAgaGlkZGVuLnB1c2ggaVxuICAgICAgQGcuY29sdW1ucy5zZXQgXCJoaWRkZW5cIiwgaGlkZGVuXG5cbiAgICBAYWRkTm9kZSBcIkhpZGUgc2VxcyBieSBpZGVudGl0eVwiLCA9PlxuICAgICAgdGhyZXNob2xkID0gcHJvbXB0IFwiRW50ZXIgdGhyZXNob2xkIChpbiBwZXJjZW50KVwiLCAyMFxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIC8gMTAwXG4gICAgICBAbW9kZWwuZWFjaCAoZWwpIC0+XG4gICAgICAgIGlmIGVsLmdldCgnaWRlbnRpdHknKSA8IHRocmVzaG9sZFxuICAgICAgICAgIGVsLnNldCgnaGlkZGVuJywgdHJ1ZSlcblxuICAgIEBhZGROb2RlIFwiSGlkZSBzZXFzIGJ5IHNlbGVjdGlvblwiLCA9PlxuICAgICAgaGlkZGVuID0gQGcuc2VsY29sLndoZXJlIHR5cGU6IFwicm93XCJcbiAgICAgIGlkcyA9IF8ubWFwIGhpZGRlbiwgKGVsKSAtPiBlbC5nZXQoJ3NlcUlkJylcbiAgICAgIEBnLnNlbGNvbC5yZXNldCBbXVxuICAgICAgQG1vZGVsLmVhY2ggKGVsKSAtPlxuICAgICAgICBpZiBpZHMuaW5kZXhPZihlbC5nZXQoJ2lkJykpID49IDBcbiAgICAgICAgICBlbC5zZXQoJ2hpZGRlbicsIHRydWUpXG5cbiAgICBAYWRkTm9kZSBcIkhpZGUgc2VxcyBieSBnYXBzXCIsID0+XG4gICAgICB0aHJlc2hvbGQgPSBwcm9tcHQgXCJFbnRlciB0aHJlc2hvbGQgKGluIHBlcmNlbnQpXCIsIDQwXG4gICAgICBAbW9kZWwuZWFjaCAoZWwsaSkgLT5cbiAgICAgICAgc2VxID0gZWwuZ2V0KCdzZXEnKVxuICAgICAgICBnYXBzID0gXy5yZWR1Y2Ugc2VxLCAoKG1lbW8sIGMpIC0+IG1lbW8rKyBpZiBjIGlzICctJzttZW1vKSwwXG4gICAgICAgIGlmIGdhcHMgPiAgdGhyZXNob2xkXG4gICAgICAgICAgZWwuc2V0KCdoaWRkZW4nLCB0cnVlKVxuXG4gICAgQGFkZE5vZGUgXCJSZXNldFwiLCA9PlxuICAgICAgQGcuY29sdW1ucy5zZXQgXCJoaWRkZW5cIiwgW11cbiAgICAgIEBtb2RlbC5lYWNoIChlbCkgLT5cbiAgICAgICAgaWYgZWwuZ2V0KCdoaWRkZW4nKVxuICAgICAgICAgIGVsLnNldCgnaGlkZGVuJywgZmFsc2UpXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgQGJ1aWxkRE9NKClcbiAgICBAXG4iLCJNZW51QnVpbGRlciA9IHJlcXVpcmUgXCIuLi9tZW51YnVpbGRlclwiXG5cbm1vZHVsZS5leHBvcnRzID0gSGVscE1lbnUgPSBNZW51QnVpbGRlci5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuXG4gIHJlbmRlcjogLT5cbiAgICBAc2V0TmFtZShcIkhlbHBcIilcbiAgICBAYWRkTm9kZSBcIkFib3V0IHRoZSBwcm9qZWN0XCIsID0+XG4gICAgICB3aW5kb3cub3BlbiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbmlmeS9tc2FcIlxuICAgIEBhZGROb2RlIFwiUmVwb3J0IGlzc3Vlc1wiLCA9PlxuICAgICAgd2luZG93Lm9wZW4gXCJodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5pZnkvbXNhL2lzc3Vlc1wiXG4gICAgQGFkZE5vZGUgXCJVc2VyIG1hbnVhbFwiLCA9PlxuICAgICAgd2luZG93Lm9wZW4gXCJodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5pZnkvbXNhL3dpa2lcIlxuICAgIEBlbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgIEBlbC5hcHBlbmRDaGlsZCBAYnVpbGRET00oKVxuICAgIEBcbiIsIk1lbnVCdWlsZGVyID0gcmVxdWlyZSBcIi4uL21lbnVidWlsZGVyXCJcbmsgPSByZXF1aXJlKFwia29hbGEtanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBJbXBvcnRNZW51ID0gTWVudUJ1aWxkZXIuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQGcgPSBkYXRhLmdcbiAgICBAZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICBAbXNhID0gZGF0YS5tc2FcblxuICByZW5kZXI6IC0+XG4gICAgbXNhID0gQG1zYVxuICAgIHVwbG9hZGVyID0gay5tayBcImlucHV0XCJcbiAgICB1cGxvYWRlci50eXBlID0gXCJmaWxlXCJcbiAgICB1cGxvYWRlci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICAjdXBsb2FkZXIuYWNjZXB0XG4gICAgIyBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vanNyZWYvcHJvcF9maWxldXBsb2FkX2FjY2VwdC5hc3BcbiAgICAjIGZvciBub3cgd2UgYWxsb3cgbXVsdGlwbGUgZmlsZXNcbiAgICB1cGxvYWRlci5tdWx0aXBsZSA9IHRydWVcbiAgICB1cGxvYWRlci5hZGRFdmVudExpc3RlbmVyIFwiY2hhbmdlXCIsIC0+XG4gICAgICBmaWxlcyA9IHVwbG9hZGVyLmZpbGVzIHx8IFtdXG4gICAgICBtc2EudS5maWxlLmltcG9ydEZpbGVzIGZpbGVzXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgdXBsb2FkZXJcblxuICAgIEBzZXROYW1lKFwiSW1wb3J0XCIpXG4gICAgQGFkZE5vZGUgXCJVUkxcIiwoZSkgPT5cbiAgICAgIHVybCA9IHByb21wdCBcIlVSTFwiLFxuICAgICAgXCJodHRwOi8vcm9zdGxhYi5vcmcvfmdvbGRiZXJnL2NsdXN0YWx3Mi1JMjAxNDA4MTgtMjE1MjQ5LTA1NTYtNTM2OTk4NzgtcGcuY2x1c3RhbHdcIlxuICAgICAgQG1zYS51LmZpbGUuaW1wb3J0VVJMIHVybCwgLT5cbiAgICAgICAgIyBtYXNzIHVwZGF0ZSBvbiB6b29tZXJcbiAgICAgICAgI3pvb21lciA9IEBnLnpvb21lci50b0pTT04oKVxuICAgICAgICAjI3pvb21lci50ZXh0VmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICMjem9vbWVyLmNvbHVtbldpZHRoID0gNFxuICAgICAgICAjem9vbWVyLmJveFJlY3RIZWlnaHQgPSAyXG4gICAgICAgICN6b29tZXIuYm94UmVjdFdpZHRoID0gMlxuICAgICAgICAjQGcuem9vbWVyLnNldCB6b29tZXJcblxuICAgIEBhZGROb2RlIFwiRnJvbSBmaWxlXCIsID0+XG4gICAgICB1cGxvYWRlci5jbGljaygpXG5cbiAgICBAYWRkTm9kZSBcIkRyYWcgJiBEcm9wXCIsID0+XG4gICAgICBhbGVydCBcIlllcC4gSnVzdCBkcmFnICYgZHJvcCB5b3VyIGZpbGVcIlxuXG4gICAgQGVsLmFwcGVuZENoaWxkIEBidWlsZERPTSgpXG4gICAgQFxuIiwiTWVudUJ1aWxkZXIgPSByZXF1aXJlIFwiLi4vbWVudWJ1aWxkZXJcIlxuZG9tID0gcmVxdWlyZSBcImRvbS1oZWxwZXJcIlxuXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yZGVyaW5nTWVudSA9IE1lbnVCdWlsZGVyLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQG9yZGVyID0gXCJJRFwiXG4gICAgQGVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG5cbiAgc2V0T3JkZXI6IChvcmRlcikgLT5cbiAgICBAb3JkZXIgPSBvcmRlclxuICAgIEByZW5kZXIoKVxuXG4gICMgVE9ETzogbWFrZSBtb3JlIGdlbmVyaWNcbiAgcmVuZGVyOiAtPlxuICAgIEBzZXROYW1lKFwiT3JkZXJpbmdcIilcbiAgICBAcmVtb3ZlQWxsTm9kZXMoKVxuXG4gICAgY29tcHMgPSBAZ2V0Q29tcGFyYXRvcnMoKVxuICAgIGZvciBtIGluIGNvbXBzXG4gICAgICBAX2FkZE5vZGUgbVxuXG4gICAgZWwgPSBAYnVpbGRET00oKVxuXG4gICAgIyBUT0RPOiBtYWtlIG1vcmUgZWZmaWNpZW50XG4gICAgZG9tLnJlbW92ZUFsbENoaWxkcyBAZWxcbiAgICBAZWwuYXBwZW5kQ2hpbGQgZWxcbiAgICBAXG5cbiAgX2FkZE5vZGU6IChtKSAtPlxuICAgIHRleHQgPSBtLnRleHRcbiAgICBzdHlsZSA9IHt9XG4gICAgaWYgdGV4dCBpcyBAb3JkZXJcbiAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzc3RUQ4MFwiXG4gICAgQGFkZE5vZGUgdGV4dCwgPT5cbiAgICAgIG0ucHJlY29kZSgpIGlmIG0ucHJlY29kZT9cbiAgICAgIEBtb2RlbC5jb21wYXJhdG9yID0gbS5jb21wYXJhdG9yXG4gICAgICBAbW9kZWwuc29ydCgpXG4gICAgICBAc2V0T3JkZXIgbS50ZXh0XG4gICAgLFxuICAgICAgc3R5bGU6IHN0eWxlXG5cbiAgZ2V0Q29tcGFyYXRvcnM6IC0+XG4gICAgbW9kZWxzID0gW11cblxuXG4gICAgbW9kZWxzLnB1c2ggdGV4dDogXCJJRFwiLCBjb21wYXJhdG9yOiBcImlkXCJcblxuICAgIG1vZGVscy5wdXNoIHRleHQ6IFwiSUQgRGVzY1wiLCBjb21wYXJhdG9yOiAoYSwgYikgLT5cbiAgICAgICMgYXV0byBjb252ZXJ0cyB0byBzdHJpbmcgZm9yIGxvY2FsZUNvbXBhcmVcbiAgICAgICAgLSAoXCJcIiArIGEuZ2V0KFwiaWRcIikpLmxvY2FsZUNvbXBhcmUoXCJcIiArIGIuZ2V0KFwiaWRcIiksIFtdLCBudW1lcmljOiB0cnVlIClcblxuICAgIG1vZGVscy5wdXNoIHRleHQ6IFwiTGFiZWxcIiwgY29tcGFyYXRvcjogXCJuYW1lXCJcblxuICAgIG1vZGVscy5wdXNoIHRleHQ6IFwiTGFiZWwgRGVzY1wiLCBjb21wYXJhdG9yOiAoYSwgYikgLT5cbiAgICAgICAgLSBhLmdldChcIm5hbWVcIikubG9jYWxlQ29tcGFyZShiLmdldChcIm5hbWVcIikpXG5cbiAgICBtb2RlbHMucHVzaCB0ZXh0OiBcIlNlcVwiLCBjb21wYXJhdG9yOiBcInNlcVwiXG5cbiAgICBtb2RlbHMucHVzaCB0ZXh0OiBcIlNlcSBEZXNjXCIsIGNvbXBhcmF0b3I6IChhLGIpIC0+XG4gICAgICAgIC0gYS5nZXQoXCJzZXFcIikubG9jYWxlQ29tcGFyZShiLmdldChcInNlcVwiKSlcblxuICAgIHNldElkZW50ID0gPT5cbiAgICAgIEBpZGVudCA9IEBnLnN0YXRzLmlkZW50aXR5KClcblxuICAgIG1vZGVscy5wdXNoIHRleHQ6IFwiSWRlbnRpdHlcIiwgY29tcGFyYXRvcjogKGEsYikgPT5cbiAgICAgIHZhbCA9IEBpZGVudFthLmlkXSAtIEBpZGVudFtiLmlkXVxuICAgICAgcmV0dXJuIDEgaWYgdmFsID4gMFxuICAgICAgcmV0dXJuIC0xIGlmIHZhbCA8IDBcbiAgICAgIDBcbiAgICAsIHByZWNvZGU6IHNldElkZW50XG5cbiAgICBtb2RlbHMucHVzaCB0ZXh0OiBcIklkZW50aXR5IERlc2NcIiwgY29tcGFyYXRvcjogKGEsYikgPT5cbiAgICAgIHZhbCA9IEBpZGVudFthLmlkXSAtIEBpZGVudFtiLmlkXVxuICAgICAgcmV0dXJuIC0xIGlmIHZhbCA+IDBcbiAgICAgIHJldHVybiAxIGlmIHZhbCA8IDBcbiAgICAgIDBcbiAgICAsIHByZWNvZGU6IHNldElkZW50XG5cbiAgICBtb2RlbHMucHVzaCB0ZXh0OiBcIlJlZmVyZW5jZVwiLCBjb21wYXJhdG9yOiAoc2VxKSAtPlxuICAgICAgICBub3Qgc2VxLmdldCBcInJlZlwiXG5cbiAgICBtb2RlbHMucHVzaCB0ZXh0OiBcIlBhcnRpdGlvbiBjb2Rlc1wiLCBjb21wYXJhdG9yOiBcInBhcnRpdGlvblwiLCBwcmVjb2RlOiA9PlxuICAgICAgIyBzZXQgcGFydGl0aW9ucyByYW5kb21cbiAgICAgIEBnLnZpcy5zZXQoJ2xhYmVsUGFydGl0aW9uJywgdHJ1ZSlcbiAgICAgIEBtb2RlbC5lYWNoIChlbCkgLT5cbiAgICAgICAgZWwuc2V0KCdwYXJ0aXRpb24nLCBfLnJhbmRvbSgxLDMpKVxuXG5cbiAgICByZXR1cm4gbW9kZWxzXG4iLCJNZW51QnVpbGRlciA9IHJlcXVpcmUgXCIuLi9tZW51YnVpbGRlclwiXG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uTWVudSA9IE1lbnVCdWlsZGVyLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG5cbiAgcmVuZGVyOiAtPlxuICAgIEBzZXROYW1lKFwiU2VsZWN0aW9uXCIpXG4gICAgQGFkZE5vZGUgXCJGaW5kIE1vdGlmIChzdXBwb3J0cyBSZWdFeClcIiwgPT5cbiAgICAgIHNlYXJjaCA9IHByb21wdCBcInlvdXIgc2VhcmNoXCIsIFwiRFwiXG4gICAgICBAZy51c2VyLnNldCBcInNlYXJjaFRleHRcIiwgc2VhcmNoXG5cbiAgICBAYWRkTm9kZSBcIkludmVydCBjb2x1bW5zXCIsID0+XG4gICAgICBAZy5zZWxjb2wuaW52ZXJ0Q29sIFswLi5AbW9kZWwuZ2V0TWF4TGVuZ3RoKCldXG4gICAgQGFkZE5vZGUgXCJJbnZlcnQgcm93c1wiLCA9PlxuICAgICAgQGcuc2VsY29sLmludmVydFJvdyBAbW9kZWwucGx1Y2sgXCJpZFwiXG4gICAgQGFkZE5vZGUgXCJSZXNldFwiLCA9PlxuICAgICAgQGcuc2VsY29sLnJlc2V0KClcbiAgICBAZWwuYXBwZW5kQ2hpbGQgQGJ1aWxkRE9NKClcbiAgICBAXG4iLCJNZW51QnVpbGRlciA9IHJlcXVpcmUgXCIuLi9tZW51YnVpbGRlclwiXG5kb20gPSByZXF1aXJlIFwiZG9tLWhlbHBlclwiXG5cbm1vZHVsZS5leHBvcnRzID0gVmlzTWVudSA9IE1lbnVCdWlsZGVyLmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgQGxpc3RlblRvIEBnLnZpcywgXCJjaGFuZ2VcIiwgQHJlbmRlclxuXG4gIHJlbmRlcjogLT5cbiAgICBAcmVtb3ZlQWxsTm9kZXMoKVxuICAgIEBzZXROYW1lKFwiVmlzLmVsZW1lbnRzXCIpXG5cbiAgICB2aXNFbGVtZW50cyA9IEBnZXRWaXNFbGVtZW50cygpXG4gICAgZm9yIHZpc0VsIGluIHZpc0VsZW1lbnRzXG4gICAgICBAX2FkZFZpc0VsIHZpc0VsXG5cbiAgICAjIG90aGVyXG4gICAgQGFkZE5vZGUgXCJSZXNldFwiLCA9PlxuICAgICAgQGcudmlzLnNldCBcImxhYmVsc1wiLCB0cnVlXG4gICAgICBAZy52aXMuc2V0IFwic2VxdWVuY2VzXCIsIHRydWVcbiAgICAgIEBnLnZpcy5zZXQgXCJtZXRhY2VsbFwiLCB0cnVlXG4gICAgICBAZy52aXMuc2V0IFwiY29uc2VydlwiLCB0cnVlXG4gICAgICBAZy52aXMuc2V0IFwibGFiZWxJZFwiLCB0cnVlXG4gICAgICBAZy52aXMuc2V0IFwibGFiZWxOYW1lXCIsIHRydWVcbiAgICAgIEBnLnZpcy5zZXQgXCJsYWJlbENoZWNrYm94XCIsIGZhbHNlXG4gICAgICBAZy52aXMuc2V0IFwic2VxbG9nb1wiLCBmYWxzZVxuICAgICAgQGcudmlzLnNldCBcImdhcEhlYWRlclwiLCBmYWxzZVxuICAgICAgQGcudmlzLnNldCBcImxlZnRIZWFkZXJcIiwgdHJ1ZVxuICAgICAgQGcudmlzLnNldCBcIm1ldGFHYXBzXCIsIHRydWVcbiAgICAgIEBnLnZpcy5zZXQgXCJtZXRhSWRlbnRpdHlcIiwgdHJ1ZVxuICAgICAgQGcudmlzLnNldCBcIm1ldGFMaW5rc1wiLCB0cnVlXG5cbiAgICAjIFRPRE86IG1ha2UgbW9yZSBlZmZpY2llbnRcbiAgICBkb20ucmVtb3ZlQWxsQ2hpbGRzIEBlbFxuICAgIEBlbC5hcHBlbmRDaGlsZCBAYnVpbGRET00oKVxuICAgIEBcblxuICBfYWRkVmlzRWw6ICh2aXNFbCkgLT5cbiAgICBzdHlsZSA9IHt9XG5cbiAgICBpZiBAZy52aXMuZ2V0IHZpc0VsLmlkXG4gICAgICBwcmUgPSBcIkhpZGUgXCJcbiAgICAgIHN0eWxlLmNvbG9yID0gXCJyZWRcIlxuICAgIGVsc2VcbiAgICAgIHByZSA9IFwiU2hvdyBcIlxuICAgICAgc3R5bGUuY29sb3IgPSBcImdyZWVuXCJcblxuICAgIEBhZGROb2RlIChwcmUgKyB2aXNFbC5uYW1lKSwgPT5cbiAgICAgIEBnLnZpcy5zZXQgdmlzRWwuaWQsICEgQGcudmlzLmdldCB2aXNFbC5pZFxuICAgICxcbiAgICAgIHN0eWxlOiBzdHlsZVxuXG4gIGdldFZpc0VsZW1lbnRzOiAtPlxuICAgIHZpcyA9IFtdXG4gICAgdmlzLnB1c2ggbmFtZTogXCJNYXJrZXJzXCIsIGlkOiBcIm1hcmtlcnNcIlxuICAgIHZpcy5wdXNoIG5hbWU6IFwiTGFiZWxzXCIsIGlkOiBcImxhYmVsc1wiXG4gICAgI3Zpcy5wdXNoIG5hbWU6IFwiU2VxdWVuY2VzXCIsIGlkOiBcInNlcXVlbmNlc1wiXG4gICAgdmlzLnB1c2ggbmFtZTogXCJNZXRhIGluZm9cIiwgaWQ6IFwibWV0YWNlbGxcIlxuICAgIHZpcy5wdXNoIG5hbWU6IFwiT3ZlcnZpZXdib3hcIiwgaWQ6IFwib3ZlcnZpZXdib3hcIlxuICAgIHZpcy5wdXNoIG5hbWU6IFwiQ29uc2VydlwiLCBpZDogXCJjb25zZXJ2XCJcbiAgICB2aXMucHVzaCBuYW1lOiBcIlNlcS4gbG9nb1wiLCBpZDogXCJzZXFsb2dvXCJcbiAgICB2aXMucHVzaCBuYW1lOiBcIkdhcCBIZWFkZXJcIiwgaWQ6IFwiZ2FwSGVhZGVyXCJcbiAgICB2aXMucHVzaCBuYW1lOiBcIkxlZnQgaGVhZGVyXCIsIGlkOiBcImxlZnRIZWFkZXJcIlxuICAgIHZpcy5wdXNoIG5hbWU6IFwiTGFiZWwgbmFtZVwiLCBpZDogXCJsYWJlbE5hbWVcIlxuICAgIHZpcy5wdXNoIG5hbWU6IFwiTGFiZWwgaWRcIiwgaWQ6IFwibGFiZWxJZFwiXG4gICAgdmlzLnB1c2ggbmFtZTogXCJMYWJlbCBjaGVja2JveFwiLCBpZDogXCJsYWJlbENoZWNrYm94XCJcbiAgICB2aXMucHVzaCBuYW1lOiBcIk1ldGEgZ2Fwc1wiLCBpZDogXCJtZXRhR2Fwc1wiXG4gICAgdmlzLnB1c2ggbmFtZTogXCJNZXRhIGlkZW50aXR5XCIsIGlkOiBcIm1ldGFJZGVudGl0eVwiXG4gICAgdmlzLnB1c2ggbmFtZTogXCJNZXRhIGxpbmtzXCIsIGlkOiBcIm1ldGFMaW5rc1wiXG4gICAgcmV0dXJuIHZpc1xuIiwiRmVhdHVyZSA9IHJlcXVpcmUgXCIuL0ZlYXR1cmVcIlxuTW9kZWwgPSByZXF1aXJlKFwiYmFja2JvbmUtdGhpblwiKS5Nb2RlbFxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmUgPSBNb2RlbC5leHRlbmRcblxuICBkZWZhdWx0czpcbiAgICB4U3RhcnQ6IC0xXG4gICAgeEVuZDogLTFcbiAgICBoZWlnaHQ6IC0xXG4gICAgdGV4dDogXCJcIlxuICAgIGZpbGxDb2xvcjogXCJyZWRcIlxuICAgIGZpbGxPcGFjaXR5OiAwLjVcbiAgICB0eXBlOiBcInJlY3RhbmdsZVwiXG4gICAgYm9yZGVyU2l6ZTogMVxuICAgIGJvcmRlckNvbG9yOiBcImJsYWNrXCJcbiAgICBib3JkZXJPcGFjaXR5OiAwLjVcbiAgICB2YWxpZGF0ZTogdHJ1ZVxuICAgIHJvdzogMFxuXG4gIGluaXRpYWxpemU6IChvYmopIC0+XG4gICAgaWYgb2JqLnN0YXJ0P1xuICAgICAgQHNldCBcInhTdGFydFwiLCBvYmouc3RhcnRcbiAgICBpZiBvYmouZW5kP1xuICAgICAgQHNldCBcInhFbmRcIiwgb2JqLmVuZFxuICAgICMgbmFtZSBoYXMgYSBwcmVkZWZpbmVkIG1lYW5pbmdcbiAgICBpZiBvYmouYXR0cmlidXRlcz9cbiAgICAgIGlmIG9iai5hdHRyaWJ1dGVzLk5hbWU/XG4gICAgICAgIEBzZXQgXCJ0ZXh0XCIsIG9iai5hdHRyaWJ1dGVzLk5hbWVcbiAgICAgIGlmIG9iai5hdHRyaWJ1dGVzLkNvbG9yP1xuICAgICAgICBAc2V0IFwiZmlsbENvbG9yXCIsIG9iai5hdHRyaWJ1dGVzLkNvbG9yXG5cbiAgICBpZiBAYXR0cmlidXRlcy54RW5kIDwgQGF0dHJpYnV0ZXMueFN0YXJ0XG4gICAgICBjb25zb2xlLndhcm4gXCJpbnZhbGlkIGZlYXR1cmUgcmFuZ2UgZm9yXCIsIEBhdHRyaWJ1dGVzXG5cbiAgICBpZiBub3QgXy5pc051bWJlcihAYXR0cmlidXRlcy54U3RhcnQpIG9yIG5vdCBfLmlzTnVtYmVyKEBhdHRyaWJ1dGVzLnhFbmQpXG4gICAgICBjb25zb2xlLndhcm4gXCJwbGVhc2UgcHJvdmlkZSBudW1lcmljIGZlYXR1cmUgcmFuZ2VzXCIsIG9ialxuICAgICAgIyB0cnlpbmcgYXV0by1jYXN0aW5nXG4gICAgICBAc2V0IFwieFN0YXJ0XCIsIHBhcnNlSW50KEBhdHRyaWJ1dGVzLnhTdGFydClcbiAgICAgIEBzZXQgXCJ4RW5kXCIsIHBhcnNlSW50KEBhdHRyaWJ1dGVzLnhFbmQpXG5cbiAgdmFsaWRhdGU6IC0+XG4gICAgaWYgaXNOYU4gQGF0dHJpYnV0ZXMueFN0YXJ0IG9yIGlzTmFOIEBhdHRyaWJ1dGVzLnhFbmRcbiAgICAgIFwiZmVhdHVyZXMgbmVlZCBpbnRlZ2VyIHN0YXJ0IGFuZCBlbmQuXCJcblxuICBjb250YWluczogKGluZGV4KSAtPlxuICAgIHJldHVybiAgQGF0dHJpYnV0ZXMueFN0YXJ0IDw9IGluZGV4ICYmIGluZGV4IDw9IEBhdHRyaWJ1dGVzLnhFbmRcblxuIiwiRmVhdHVyZSA9IHJlcXVpcmUgXCIuL0ZlYXR1cmVcIlxuQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLkNvbGxlY3Rpb25cbl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZUNvbCA9IENvbGxlY3Rpb24uZXh0ZW5kXG4gIG1vZGVsOiBGZWF0dXJlXG5cbiAgY29uc3RydWN0b3I6IC0+XG4gICAgQHN0YXJ0T25DYWNoZSA9IFtdXG4gICAgIyBpbnZhbGlkYXRlIGNhY2hlXG4gICAgQG9uIFwiYWxsXCIsIC0+XG4gICAgICBAc3RhcnRPbkNhY2hlID0gW11cbiAgICAsIEBcbiAgICBDb2xsZWN0aW9uLmFwcGx5IEAsIGFyZ3VtZW50c1xuXG4gICMgcmV0dXJucyBhbGwgZmVhdHVyZXMgc3RhcnRpbmcgb24gaW5kZXhcbiAgc3RhcnRPbjogKGluZGV4KSAtPlxuICAgIHVubGVzcyBAc3RhcnRPbkNhY2hlW2luZGV4XT9cbiAgICAgIEBzdGFydE9uQ2FjaGVbaW5kZXhdID0gQHdoZXJlKHt4U3RhcnQ6IGluZGV4fSlcbiAgICByZXR1cm4gQHN0YXJ0T25DYWNoZVtpbmRleF1cblxuICBjb250YWluczogKGluZGV4KSAtPlxuICAgIEByZWR1Y2UgKGVsLG1lbW8pIC0+XG4gICAgICBtZW1vIHx8IGVsLmNvbnRhaW5zIGluZGV4XG4gICAgLCBmYWxzZVxuXG4gIGdldEZlYXR1cmVPblJvdzogKHJvdyx4KSAtPlxuICAgIEBmaWx0ZXIgKGVsKSAtPlxuICAgICAgZWwuZ2V0KFwicm93XCIpIGlzIHJvdyBhbmQgZWwuZ2V0KFwieFN0YXJ0XCIpIDw9IHggYW5kIHggPD0gZWwuZ2V0KFwieEVuZFwiKVxuXG4gICMgdHJpZXMgdG8gYXV0by1maXQgdGhlIHJvd3NcbiAgIyBub3QgYSB2ZXJ5IGVmZmljaWVudCBhbGdvcml0aG1cbiAgYXNzaWduUm93czogLT5cblxuICAgIGxlbiA9IChAbWF4IChlbCkgLT4gZWwuZ2V0KFwieEVuZFwiKSkuYXR0cmlidXRlcy54RW5kXG4gICAgcm93cyA9ICgwIGZvciB4IGluIFswLi4gbGVuXSlcblxuICAgIEBlYWNoIChlbCkgLT5cbiAgICAgIG1heCA9IDBcbiAgICAgIGZvciB4IGluIFtlbC5nZXQoXCJ4U3RhcnRcIikgLi4gZWwuZ2V0KFwieEVuZFwiKV0gYnkgMVxuICAgICAgICBpZiByb3dzW3hdID4gbWF4XG4gICAgICAgICAgbWF4ID0gcm93c1t4XVxuICAgICAgICByb3dzW3hdKytcbiAgICAgIGVsLnNldChcInJvd1wiLCBtYXgpXG5cbiAgICBfLm1heCByb3dzXG5cbiAgZ2V0Q3VycmVudEhlaWdodDogLT5cbiAgICAoQG1heCAoZWwpIC0+IGVsLmdldChcInJvd1wiKSkuYXR0cmlidXRlcy5yb3cgKyAxXG5cbiAgIyBnaXZlcyB0aGUgbWluaW1hbCBuZWVkZWQgbnVtYmVyIG9mIHJvd3NcbiAgIyBub3QgYSB2ZXJ5IGVmZmljaWVudCBhbGdvcml0aG1cbiAgIyAodGhlcmUgaXMgb25lIGluIE8obikgKVxuICBnZXRNaW5Sb3dzOiAtPlxuXG4gICAgbGVuID0gKEBtYXggKGVsKSAtPiBlbC5nZXQoXCJ4RW5kXCIpKS5hdHRyaWJ1dGVzLnhFbmRcbiAgICByb3dzID0gKDAgZm9yIHggaW4gWzAuLiBsZW5dKVxuXG4gICAgQGVhY2ggKGVsKSAtPlxuICAgICAgZm9yIHggaW4gW2VsLmdldChcInhTdGFydFwiKSAuLiBlbC5nZXQoXCJ4RW5kXCIpXSBieSAxXG4gICAgICAgIHJvd3NbeF0rK1xuXG4gICAgXy5tYXggcm93c1xuIiwiU2VxdWVuY2UgPSByZXF1aXJlIFwiLi9TZXF1ZW5jZVwiXG5GZWF0dXJlQ29sID0gcmVxdWlyZSBcIi4vRmVhdHVyZUNvbFwiXG5Db2xsZWN0aW9uID0gcmVxdWlyZShcImJhY2tib25lLXRoaW5cIikuQ29sbGVjdGlvblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcU1hbmFnZXIgPSBDb2xsZWN0aW9uLmV4dGVuZFxuICBtb2RlbDogU2VxdWVuY2VcblxuICBjb25zdHJ1Y3RvcjogKHNlcXMsIGcpIC0+XG4gICAgQ29sbGVjdGlvbi5hcHBseSBALCBhcmd1bWVudHNcbiAgICBAZyA9IGdcblxuICAgIEBvbiBcImFkZCByZXNldCByZW1vdmVcIiwgPT5cbiAgICAgICMgaW52YWxpZGF0ZSBjYWNoZVxuICAgICAgQGxlbmd0aENhY2hlID0gbnVsbFxuICAgICAgQF9iaW5kU2Vxc1dpdGhGZWF0dXJlcygpXG4gICAgLCBAXG5cbiAgICAjIHVzZSB0aGUgZmlyc3Qgc2VxIGFzIHJlZmVyZW5jZSBhcyBkZWZhdWx0XG4gICAgQG9uIFwicmVzZXRcIiwgPT5cbiAgICAgIEBfYXV0b1NldFJlZlNlcSgpXG4gICAgQF9hdXRvU2V0UmVmU2VxKClcblxuICAgIEBsZW5ndGhDYWNoZSA9IG51bGxcblxuICAgIEBmZWF0dXJlcyA9IHt9XG4gICAgQFxuXG4gICMgZ2l2ZXMgdGhlIG1heCBsZW5ndGggb2YgYWxsIHNlcXVlbmNlc1xuICAjIChjYWNoZWQpXG4gIGdldE1heExlbmd0aDogKCkgLT5cbiAgICByZXR1cm4gMCBpZiBAbW9kZWxzLmxlbmd0aCBpcyAwXG4gICAgaWYgQGxlbmd0aENhY2hlIGlzIG51bGxcbiAgICAgIEBsZW5ndGhDYWNoZSA9IEBtYXgoKHNlcSkgLT4gc2VxLmdldChcInNlcVwiKS5sZW5ndGgpLmdldChcInNlcVwiKS5sZW5ndGhcbiAgICByZXR1cm4gQGxlbmd0aENhY2hlXG5cbiAgIyBnZXRzIHRoZSBwcmV2aW91cyBtb2RlbFxuICAjIEBwYXJhbSBlbmRsZXNzIFtib29sZWFuXSBmb3IgdGhlIGZpcnN0IGVsZW1lbnRcbiAgIyB0cnVlOiByZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQsIGZhbHNlOiByZXR1cm5zIHVuZGVmaW5lZFxuICBwcmV2OiAobW9kZWwsIGVuZGxlc3MpIC0+XG4gICAgaW5kZXggPSBAaW5kZXhPZihtb2RlbCkgLSAxXG4gICAgaW5kZXggPSBALmxlbmd0aCAtIDEgaWYgaW5kZXggPCAwIGFuZCBlbmRsZXNzXG4gICAgQGF0KGluZGV4KVxuXG4gICMgZ2V0cyB0aGUgbmV4dCBtb2RlbFxuICAjIEBwYXJhbSBlbmRsZXNzIFtib29sZWFuXSBmb3IgdGhlIGxhc3QgZWxlbWVudFxuICAjIHRydWU6IHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQsIGZhbHNlOiByZXR1cm5zIHVuZGVmaW5lZFxuICBuZXh0OiAobW9kZWwsIGVuZGxlc3MpIC0+XG4gICAgaW5kZXggPSBAaW5kZXhPZihtb2RlbCkgKyAxXG4gICAgaW5kZXggPSAwIGlmIGluZGV4ID09IEAubGVuZ3RoIGFuZCBlbmRsZXNzXG4gICAgQGF0KGluZGV4KVxuXG4gICMgQHJldHVybnMgbiBbaW50XSBudW1iZXIgb2YgaGlkZGVuIGNvbHVtbnMgdW50aWwgblxuICBjYWxjSGlkZGVuU2VxczogKG4pIC0+XG4gICAgbk5ldyA9IG5cbiAgICBmb3IgaSBpbiBbMC4ubk5ld11cbiAgICAgIGlmIEBhdChpKS5nZXQoXCJoaWRkZW5cIilcbiAgICAgICAgbk5ldysrXG4gICAgbk5ldyAtIG5cblxuICAjIHlvdSBjYW4gYWRkIGZlYXR1cmVzIGluZGVwZW5kZW50IHRvIHRoZSBjdXJyZW50IHNlcXMgYXMgdGhleSBtYXkgYmUgYWRkZWRcbiAgIyBsYXRlciAobGFnZ2luZyBjb25uZWN0aW9uKVxuICBhZGRGZWF0dXJlczogKGZlYXR1cmVzKSAtPlxuICAgIGlmIGZlYXR1cmVzLmNvbmZpZz9cbiAgICAgIG9iaiA9IGZlYXR1cmVzXG4gICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzLnNlcXNcbiAgICAgIGlmIG9iai5jb25maWcuY29sb3JzP1xuICAgICAgICBjb2xvcnMgPSBvYmouY29uZmlnLmNvbG9yc1xuICAgICAgICBfLmVhY2ggZmVhdHVyZXMsIChzZXEpIC0+XG4gICAgICAgICAgXy5lYWNoIHNlcSwgKHZhbCkgLT5cbiAgICAgICAgICAgIGlmIGNvbG9yc1t2YWwuZmVhdHVyZV0/XG4gICAgICAgICAgICAgIHZhbC5maWxsQ29sb3IgPSBjb2xvcnNbdmFsLmZlYXR1cmVdXG4gICAgaWYgXy5pc0VtcHR5IEBmZWF0dXJlc1xuICAgICAgQGZlYXR1cmVzID0gZmVhdHVyZXNcbiAgICBlbHNlXG4gICAgICBfLmVhY2ggZmVhdHVyZXMsICh2YWwsIGtleSkgPT5cbiAgICAgICAgdW5sZXNzIEBmZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eSBrZXlcbiAgICAgICAgICBAZmVhdHVyZXNba2V5XSA9IHZhbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgQGZlYXR1cmVzW2tleV0gPSBfLnVuaW9uIEBmZWF0dXJlc1trZXldLCB2YWxcbiAgICAjIHJlaGFzaFxuICAgIEBfYmluZFNlcXNXaXRoRmVhdHVyZXMoKVxuXG4gICMgYWRkcyBmZWF0dXJlcyB0byBhIHNlcXVlbmNlXG4gIF9iaW5kU2VxV2l0aEZlYXR1cmVzOiAoc2VxKSAtPlxuICAgICMgVE9ETzogcHJvYmFibHkgd2UgZG9uJ3QgYWx3YXlzIHdhbnQgdG8gYmluZCB0byBuYW1lXG4gICAgZmVhdHVyZXMgPSBAZmVhdHVyZXNbc2VxLmF0dHJpYnV0ZXMubmFtZV1cbiAgICBpZiBmZWF0dXJlc1xuICAgICAgc2VxLnNldCBcImZlYXR1cmVzXCIsIG5ldyBGZWF0dXJlQ29sIGZlYXR1cmVzXG4gICAgICBzZXEuYXR0cmlidXRlcy5mZWF0dXJlcy5hc3NpZ25Sb3dzKClcbiAgICAgIHNlcS5zZXQgXCJoZWlnaHRcIiwgc2VxLmF0dHJpYnV0ZXMuZmVhdHVyZXMuZ2V0Q3VycmVudEhlaWdodCgpICsgMVxuXG4gICMgcmVoYXNoIHRoZSBzZXF1ZW5jZSBmZWF0dXJlIGJpbmRpbmdcbiAgX2JpbmRTZXFzV2l0aEZlYXR1cmVzOiAoKSAtPlxuICAgIEBlYWNoIChzZXEpID0+ICBAX2JpbmRTZXFXaXRoRmVhdHVyZXMoc2VxKVxuXG4gICMgcmVtb3ZlcyBhbGwgZmVhdHVyZXMgZnJvbSB0aGUgY2FjaGUgKG5vdCBmcm9tIHRoZSBzZXFzKVxuICByZW1vdmVBbGxGZWF0dXJlczogLT5cbiAgICBkZWxldGUgQGZlYXR1cmVzXG5cbiAgX2F1dG9TZXRSZWZTZXE6IC0+XG4gICAgaWYgQGxlbmd0aCA+IDBcbiAgICAgIEBhdCgwKS5zZXQgXCJyZWZcIiwgdHJ1ZVxuXG4gICMgc2V0cyBhIHNlcXVlbmNlIChlLmcuIEJMQVNUIHN0YXJ0IG9yIGNvbnNlbnN1cyBzZXEpIGFzIHJlZmVyZW5jZVxuICBzZXRSZWY6IChzZXEpIC0+XG4gICAgb2JqID0gQGdldCBzZXFcbiAgICBAZWFjaCAocykgLT5cbiAgICAgIGlmIHNlcS5jaWRcbiAgICAgICAgaWYgb2JqLmNpZCA9PSBzLmNpZFxuICAgICAgICAgIHMuc2V0IFwicmVmXCIsIHRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHMuc2V0IFwicmVmXCIsIGZhbHNlXG5cbiAgICBAZy5jb25maWcuc2V0IFwiaGFzUmVmXCIsIHRydWVcbiAgICBAdHJpZ2dlciBcImNoYW5nZTpyZWZlcmVuY2VcIiwgc2VxXG4iLCJNb2RlbCA9IHJlcXVpcmUoXCJiYWNrYm9uZS10aGluXCIpLk1vZGVsXG5GZWF0dXJlQ29sID0gcmVxdWlyZSBcIi4vRmVhdHVyZUNvbFwiXG5cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVuY2UgPSBNb2RlbC5leHRlbmRcblxuICBkZWZhdWx0czpcbiAgICBuYW1lOiBcIlwiXG4gICAgaWQ6IFwiXCJcbiAgICBzZXE6IFwiXCJcbiAgICBoZWlnaHQ6IDFcbiAgICByZWY6IGZhbHNlICMgcmVmZXJlbmNlOiB0aGUgc2VxdWVuY2UgdXNlZCBpbiBCTEFTVCBvciB0aGUgY29uc2Vuc3VzIHNlcVxuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgIyByZXNpZHVlcyB3aXRob3V0IGNvbG9yXG4gICAgQC5zZXQgXCJncmV5XCIsIFtdXG4gICAgdW5sZXNzIEAuZ2V0KFwiZmVhdHVyZXNcIik/XG4gICAgICBALnNldCBcImZlYXR1cmVzXCIsIG5ldyBGZWF0dXJlQ29sKClcbiIsIm1vZHVsZS5leHBvcnRzLnNlcSA9IHJlcXVpcmUgXCIuL1NlcXVlbmNlXCJcbm1vZHVsZS5leHBvcnRzLnNlcWNvbCA9IHJlcXVpcmUgXCIuL1NlcUNvbGxlY3Rpb25cIlxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZSA9IHJlcXVpcmUgXCIuL0ZlYXR1cmVcIlxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZWNvbCA9IHJlcXVpcmUgXCIuL0ZlYXR1cmVDb2xcIlxuIiwiIyBtb2RlbHNcblNlcUNvbGxlY3Rpb24gPSByZXF1aXJlIFwiLi9tb2RlbC9TZXFDb2xsZWN0aW9uXCJcblxuIyBnbG9iYWxzXG5Db2xvcmF0b3IgPSByZXF1aXJlIFwiLi9nL2NvbG9yc2NoZW1lXCJcbkNvbHVtbnMgPSByZXF1aXJlIFwiLi9nL2NvbHVtbnNcIlxuQ29uZmlnID0gcmVxdWlyZSBcIi4vZy9jb25maWdcIlxuUGFja2FnZSA9IHJlcXVpcmUgXCIuL2cvcGFja2FnZVwiXG5TZWxDb2wgPSByZXF1aXJlIFwiLi9nL3NlbGVjdGlvbi9TZWxlY3Rpb25Db2xcIlxuVXNlciA9IHJlcXVpcmUgXCIuL2cvdXNlclwiXG5WaXNpYmlsaXR5ID0gcmVxdWlyZSBcIi4vZy92aXNpYmlsaXR5XCJcblZpc09yZGVyaW5nID0gcmVxdWlyZSBcIi4vZy92aXNPcmRlcmluZ1wiXG5ab29tZXIgPSByZXF1aXJlIFwiLi9nL3pvb21lclwiXG5cbiMgTVYgZnJvbSBiYWNrYm9uZVxuYm9uZVZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtY2hpbGRzXCIpXG5FdmVudGhhbmRsZXIgPSByZXF1aXJlIFwiYmlvanMtZXZlbnRzXCJcblxuIyBNU0Egdmlld3NcblN0YWdlID0gcmVxdWlyZSBcIi4vdmlld3MvU3RhZ2VcIlxuXG4jIHN0YXRpc3RpY3NcblN0YXRzID0gcmVxdWlyZSBcInN0YXQuc2Vxc1wiXG5cbiMgdXRpbHNcbiQgPSByZXF1aXJlKFwiamJvbmVcIilcbkZpbGVIZWxwZXIgPSByZXF1aXJlIFwiLi91dGlscy9maWxlXCJcblRyZWVIZWxwZXIgPSByZXF1aXJlIFwiLi91dGlscy90cmVlXCJcblByb3h5SGVscGVyID0gcmVxdWlyZSBcIi4vdXRpbHMvcHJveHlcIlxuXG4jIG9wdHMgaXMgYSBkaWN0aW9uYXJ5IGNvbnNpc3Rpbmcgb2ZcbiMgQHBhcmFtIGVsIFtTdHJpbmddIGlkIG9yIHJlZmVyZW5jZSB0byBhIERPTSBlbGVtZW50XG4jIEBwYXJhbSBzZXFzIFtTZXFBcnJheV0gQXJyYXkgb2Ygc2VxdWVuY2VzIGZvciBpbml0bGl6YXRpb25cbiMgQHBhcmFtIGNvbmYgW0RpY3RdIHVzZXIgY29uZmlnXG4jIEBwYXJhbSB2aXMgW0RpY3RdIGNvbmZpZyBvZiB2aXNpYmxlIHZpZXdzXG4jIEBwYXJhbSB6b29tZXIgW0RpY3RdIGRpc3BsYXkgc2V0dGluZ3MgbGlrZSBjb2x1bW5XaWR0aFxubW9kdWxlLmV4cG9ydHMgPSBib25lVmlldy5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cblxuICAgIGRhdGEgPSB7fSB1bmxlc3MgZGF0YT9cbiAgICAjIGNoZWNrIGZvciBkZWZhdWx0IGFycmF5c1xuICAgIGRhdGEuY29sb3JzY2hlbWUgPSB7fSB1bmxlc3MgZGF0YS5jb2xvcnNjaGVtZT9cbiAgICBkYXRhLmNvbHVtbnMgPSB7fSB1bmxlc3MgZGF0YS5jb2x1bW5zP1xuICAgIGRhdGEuY29uZiA9IHt9IHVubGVzcyBkYXRhLmNvbmY/XG4gICAgZGF0YS52aXMgPSB7fSB1bmxlc3MgZGF0YS52aXM/XG4gICAgZGF0YS52aXNvcmRlciA9IHt9IHVubGVzcyBkYXRhLnZpc29yZGVyID9cbiAgICBkYXRhLnpvb21lciA9IHt9IHVubGVzcyBkYXRhLnpvb21lcj9cblxuICAgICMgZyBpcyBvdXIgZ2xvYmFsIE1lZGlhdG9yXG4gICAgQGcgPSBFdmVudGhhbmRsZXIubWl4aW4ge31cblxuICAgICMgbG9hZCBzZXFzIGFuZCBhZGQgc3Vidmlld3NcbiAgICBAc2VxcyA9IG5ldyBTZXFDb2xsZWN0aW9uIGRhdGEuc2VxcywgQGdcblxuICAgICMgcG9wdWxhdGUgaXQgYW5kIGluaXQgdGhlIGdsb2JhbCBtb2RlbHNcbiAgICBAZy5jb25maWcgPSBuZXcgQ29uZmlnIGRhdGEuY29uZlxuICAgIEBnLnBhY2thZ2UgPSBuZXcgUGFja2FnZSBAZ1xuICAgIEBnLnNlbGNvbCA9IG5ldyBTZWxDb2wgW10se2c6QGd9XG4gICAgQGcudXNlciA9IG5ldyBVc2VyKClcbiAgICBAZy52aXMgPSBuZXcgVmlzaWJpbGl0eSBkYXRhLnZpcywge21vZGVsOiBAc2Vxc31cbiAgICBAZy52aXNvcmRlciA9IG5ldyBWaXNPcmRlcmluZyBkYXRhLnZpc29yZGVyXG4gICAgQGcuem9vbWVyID0gbmV3IFpvb21lciBkYXRhLnpvb21lcix7ZzpAZywgbW9kZWw6IEBzZXFzfVxuXG4gICAgIyBkZWJ1ZyBtb2RlXG4gICAgaWYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIGlzIFwibG9jYWxob3N0XCJcbiAgICAgIEBnLmNvbmZpZy5zZXQgXCJkZWJ1Z1wiLCB0cnVlXG5cbiAgICAjIHN0YXRzXG4gICAgcHVyZVNlcSA9IEBzZXFzLnBsdWNrKFwic2VxXCIpXG4gICAgQGcuc3RhdHMgPSBuZXcgU3RhdHMgQHNlcXNcbiAgICBAZy5zdGF0cy5hbHBoYWJldFNpemUgPSBAZy5jb25maWcuZ2V0IFwiYWxwaGFiZXRTaXplXCJcbiAgICBAZy5jb2x1bW5zID0gbmV3IENvbHVtbnMgZGF0YS5jb2x1bW5zLEBnLnN0YXRzICAjIGZvciBhY3Rpb24gb24gdGhlIGNvbHVtbnMgbGlrZSBoaWRpbmdcblxuICAgICMgZGVwZW5kaW5nIGNvbmZpZ1xuICAgIEBnLmNvbG9yc2NoZW1lID0gbmV3IENvbG9yYXRvciBkYXRhLmNvbG9yc2NoZW1lLCBwdXJlU2VxLCBAZy5zdGF0c1xuXG4gICAgIyBtb3JlIGluaXRcbiAgICBAZy56b29tZXIuc2V0RWwgQGVsLCBAc2Vxc1xuXG4gICAgQGFkZFZpZXcgXCJzdGFnZVwiLG5ldyBTdGFnZSB7bW9kZWw6IEBzZXFzLCBnOiBAZ31cbiAgICBAZWwuc2V0QXR0cmlidXRlIFwiY2xhc3NcIiwgXCJiaW9qc19tc2FfZGl2XCJcblxuICAgICMgdXRpbHNcbiAgICBAdSA9IHt9XG4gICAgQHUuZmlsZSA9IG5ldyBGaWxlSGVscGVyIEBcbiAgICBAdS5wcm94eSA9IG5ldyBQcm94eUhlbHBlciBnOiBAZ1xuICAgIEB1LnRyZWUgPSBuZXcgVHJlZUhlbHBlciBAXG5cbiAgICBpZiBAZy5jb25maWcuZ2V0KFwiZXZlbnRCdXNcIikgaXMgdHJ1ZVxuICAgICAgQHN0YXJ0RXZlbnRCdXMoKVxuXG4gICAgaWYgQGcuY29uZmlnLmdldCBcImRyb3BJbXBvcnRcIlxuICAgICAgZXZlbnRzID1cbiAgICAgICAgXCJkcmFnb3ZlclwiOiBAZHJhZ092ZXJcbiAgICAgICAgXCJkcm9wXCI6IEBkcm9wRmlsZVxuICAgICAgQGRlbGVnYXRlRXZlbnRzIGV2ZW50c1xuXG4gICAgaWYgZGF0YS5pbXBvcnRVUkxcbiAgICAgIEB1LmZpbGUuaW1wb3J0VVJMIGRhdGEuaW1wb3J0VVJMLCA9PlxuICAgICAgICBAcmVuZGVyKClcblxuICAgICMgYm9vdHN0cmFwcyB0aGUgbWVudSBiYXIgYnkgZGVmYXVsdCAtPiBkZXN0cm95cyBtb2R1bGFyaXR5XG4gICAgaWYgZGF0YS5ib290c3RyYXBNZW51XG4gICAgICBtZW51RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHdyYXBwZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgdW5sZXNzIEBlbC5wYXJlbnROb2RlXG4gICAgICAgIHdyYXBwZXJEaXYuYXBwZW5kQ2hpbGQgbWVudURpdlxuICAgICAgICB3cmFwcGVyRGl2LmFwcGVuZENoaWxkIEBlbFxuICAgICAgZWxzZVxuICAgICAgICBAZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlckRpdiwgQGVsKVxuICAgICAgICB3cmFwcGVyRGl2LmFwcGVuZENoaWxkIG1lbnVEaXZcbiAgICAgICAgd3JhcHBlckRpdi5hcHBlbmRDaGlsZCBAZWxcblxuICAgICAgZGVmTWVudSA9IG5ldyBtc2EubWVudS5kZWZhdWx0bWVudShcbiAgICAgICAgZWw6IG1lbnVEaXYsXG4gICAgICAgIG1zYTogQFxuICAgICAgKVxuICAgICAgZGVmTWVudS5yZW5kZXIoKVxuXG4gICAgJCh3aW5kb3cpLm9uKFwicmVzaXplXCIsIChlKSA9PlxuICAgICAgZiA9IC0+XG4gICAgICAgIEBnLnpvb21lci5hdXRvUmVzaXplKClcbiAgICAgIHNldFRpbWVvdXQgZi5iaW5kKEApLCA1XG4gICAgKVxuXG4gIGRyYWdPdmVyOiAoZSkgLT5cbiAgICAjIHByZXZlbnQgdGhlIG5vcm1hbCBicm93c2VyIGFjdGlvbnNcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnRhcmdldC5jbGFzc05hbWUgPSAnaG92ZXInXG4gICAgZmFsc2VcblxuICBkcm9wRmlsZTogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZmlsZXMgPSBlLnRhcmdldC5maWxlcyB8fCBlLmRhdGFUcmFuc2Zlci5maWxlc1xuICAgIEB1LmZpbGUuaW1wb3J0RmlsZXMgZmlsZXNcbiAgICByZXR1cm4gZmFsc2VcblxuICBzdGFydEV2ZW50QnVzOiAtPlxuICAgIGJ1c09ianMgPSBbXCJjb25maWdcIiwgXCJjb2x1bW5zXCIsIFwiY29sb3JzY2hlbWVcIiwgXCJzZWxjb2xcIiAsXCJ2aXNcIiwgXCJ2aXNvcmRlclwiLCBcInpvb21lclwiXVxuICAgIGZvciBrZXkgaW4gYnVzT2Jqc1xuICAgICAgQF9wcm94eVRvRyBrZXlcblxuICBfcHJveHlUb0c6IChrZXkpIC0+XG4gICAgQGxpc3RlblRvIEBnW2tleV0sIFwiYWxsXCIsKG5hbWUscHJldixub3csb3B0cykgLT5cbiAgICAgICMgc3VwcHJlc3MgZHVwbGljYXRlIGV2ZW50c1xuICAgICAgcmV0dXJuIGlmIG5hbWUgaXMgXCJjaGFuZ2VcIlxuICAgICAgIyBiYWNrYm9uZSB1c2VzIHRoZSBzZWNvbmQgYXJndW1lbnQgZm9yIHRoZSBuZXh0IHZhbHVlIC0+IHN3YXBcbiAgICAgIGlmIG9wdHM/XG4gICAgICAgIEBnLnRyaWdnZXIoa2V5ICsgXCI6XCIgKyBuYW1lLG5vdyxwcmV2LG9wdHMpXG4gICAgICBlbHNlXG4gICAgICAgIEBnLnRyaWdnZXIoa2V5ICsgXCI6XCIgKyBuYW1lLG5vdyxwcmV2KVxuXG4gIHJlbmRlcjogLT5cbiAgICBpZiBAc2VxcyBpcyB1bmRlZmluZWQgb3IgQHNlcXMubGVuZ3RoIGlzIDBcbiAgICAgIGNvbnNvbGUubG9nIFwid2FybmluZy4gZW1wdHkgc2Vxcy5cIlxuICAgIEByZW5kZXJTdWJ2aWV3cygpXG4gICAgQGcudmlzLnNldCBcImxvYWRlZFwiLCB0cnVlXG4gICAgQFxuIiwibW9kdWxlLmV4cG9ydHMgPVxuICAjIG1hdGggdXRpbGl0aWVzXG4gIGNsYXNzIEJNYXRoXG4gICAgQHJhbmRvbUludDogKGxvd2VyLCB1cHBlcikgLT5cbiAgICAgICMgQ2FsbGVkIHdpdGggb25lIGFyZ3VtZW50XG4gICAgICBbbG93ZXIsIHVwcGVyXSA9IFswLCBsb3dlcl0gICAgIHVubGVzcyB1cHBlcj9cbiAgICAgICMgTG93ZXIgbXVzdCBiZSBsZXNzIHRoZW4gdXBwZXJcbiAgICAgIFtsb3dlciwgdXBwZXJdID0gW3VwcGVyLCBsb3dlcl0gaWYgbG93ZXIgPiB1cHBlclxuICAgICAgIyBMYXN0IHN0YXRlbWVudCBpcyBhIHJldHVybiB2YWx1ZVxuICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSArIGxvd2VyKVxuXG4gICAgIyBAcmV0dXJuIFtJbnRlZ2VyXSByYW5kb20gaWRcbiAgICBAdW5pcXVlSWQ6IChsZW5ndGggPSA4KSAtPlxuICAgICAgaWQgPSBcIlwiXG4gICAgICBpZCArPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMikgd2hpbGUgaWQubGVuZ3RoIDwgbGVuZ3RoXG4gICAgICBpZC5zdWJzdHIgMCwgbGVuZ3RoXG5cbiAgICAjIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChpbmNsdXNpdmUpXG4gICAgQGdldFJhbmRvbUludDogKG1pbiwgbWF4KSAtPlxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW5cbiIsIkZhc3RhID0gcmVxdWlyZShcImJpb2pzLWlvLWZhc3RhXCIpXG5HRkYgPSByZXF1aXJlKFwiYmlvanMtaW8tZ2ZmXCIpXG54aHIgPSByZXF1aXJlIFwieGhyXCJcbmJsb2JVUkwgPSByZXF1aXJlIFwiYmx1ZWltcF9jYW52YXN0b2Jsb2JcIlxuc2F2ZUFzID0gcmVxdWlyZSBcImJyb3dzZXItc2F2ZWFzXCJcbl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwb3J0ZXIgPVxuXG4gIG9wZW5JbkphbHZpZXc6ICh1cmwsIGNvbG9yc2NoZW1lKSAtPlxuICAgIGlmIHVybC5jaGFyQXQoMCkgaXMgJy4nXG4gICAgICAjIHJlbGF0aXZlIHVybHNcbiAgICAgIHVybCA9IGRvY3VtZW50LlVSTC5zdWJzdHIoMCxkb2N1bWVudC5VUkwubGFzdEluZGV4T2YoJy8nKSkgKyBcIi9cIiArIHVybFxuXG4gICAgIyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYSBsb2NhbCB1cmxcbiAgICBpZiB1cmwuaW5kZXhPZihcImh0dHBcIikgPCAwXG4gICAgICAjIGFwcGVuZCBob3N0IGFuZCBob3BlIGZvciB0aGUgYmVzdFxuICAgICAgaG9zdCA9IFwiaHR0cDovL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgICB1cmwgPSBob3N0ICsgdXJsXG5cbiAgICB1cmwgPSBlbmNvZGVVUklDb21wb25lbnQgdXJsXG4gICAgamFsdmlld1VybCA9IFwiaHR0cDovL3d3dy5qYWx2aWV3Lm9yZy9zZXJ2aWNlcy9sYXVuY2hBcHA/b3Blbj1cIiArIHVybFxuICAgIGphbHZpZXdVcmwgKz0gXCImY29sb3VyPVwiICsgY29sb3JzY2hlbWVcbiAgICB3aW5kb3cub3BlbiBqYWx2aWV3VXJsLCAnX2JsYW5rJ1xuXG4gIHB1Ymxpc2hXZWI6ICh0aGF0LCBjYikgLT5cbiAgICB0ZXh0ID0gRmFzdGEud3JpdGUgdGhhdC5zZXFzLnRvSlNPTigpXG4gICAgdGV4dCA9IGVuY29kZVVSSUNvbXBvbmVudCB0ZXh0XG4gICAgdXJsID0gdGhhdC51LnByb3h5LmNvcnNVUkwgXCJodHRwOi8vc3BydW5nZS5iaW9qcy5uZXRcIlxuICAgIHhoclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgYm9keTogXCJzcHJ1bmdlPVwiICsgdGV4dFxuICAgICAgdXJpOiB1cmxcbiAgICAgIGhlYWRlcnM6XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAsIChlcnIscmVwLGJvZHkpIC0+XG4gICAgICBsaW5rID0gYm9keS50cmltKClcbiAgICAgIGNiKGxpbmspXG5cbiAgc2hhcmVMaW5rOiAodGhhdCwgY2IpIC0+XG4gICAgdXJsID0gdGhhdC5nLmNvbmZpZy5nZXQgXCJpbXBvcnRVUkxcIlxuICAgIG1zYVVSTCA9IFwiaHR0cDovL2Jpb2pzLW1zYS5vcmcvYXBwLz9zZXE9XCJcbiAgICBmQ0IgPSAobGluaykgLT5cbiAgICAgIGZVUkwgPSBtc2FVUkwgKyBsaW5rXG4gICAgICBpZiBjYlxuICAgICAgICBjYiBmVVJMXG4gICAgdW5sZXNzIHVybFxuICAgICAgRXhwb3J0ZXIucHVibGlzaFdlYiB0aGF0LCBmQ0JcbiAgICBlbHNlXG4gICAgICBmQ0IgdXJsXG5cbiAgc2F2ZUFzRmlsZTogKHRoYXQsbmFtZSkgLT5cbiAgICAjIGxpbWl0IGF0IGFib3V0IDI1NmtcbiAgICB0ZXh0ID0gRmFzdGEud3JpdGUgdGhhdC5zZXFzLnRvSlNPTigpXG4gICAgYmxvYiA9IG5ldyBCbG9iKFt0ZXh0XSwge3R5cGUgOiAndGV4dC9wbGFpbid9KVxuICAgIHNhdmVBcyBibG9iLCBuYW1lXG5cbiAgc2F2ZVNlbGVjdGlvbjogKHRoYXQsbmFtZSkgLT5cbiAgICBzZWxlY3Rpb24gPSB0aGF0Lmcuc2VsY29sLnBsdWNrIFwic2VxSWRcIlxuICAgIGNvbnNvbGUubG9nIHNlbGVjdGlvblxuICAgIGlmIHNlbGVjdGlvbi5sZW5ndGggPiAwXG4gICAgICAjIGZpbHRlciB0aG9zZSBzZXFpZHNcbiAgICAgIHNlbGVjdGlvbiA9IHRoYXQuc2Vxcy5maWx0ZXIgKGVsKSAtPlxuICAgICAgICBfLmNvbnRhaW5zIHNlbGVjdGlvbiwgZWwuZ2V0IFwiaWRcIlxuICAgICAgZm9yIGkgaW4gWzAuLiBzZWxlY3Rpb24ubGVuZ3RoIC0gMV0gYnkgMVxuICAgICAgICBzZWxlY3Rpb25baV0gPSBzZWxlY3Rpb25baV0udG9KU09OKClcbiAgICBlbHNlXG4gICAgICBzZWxlY3Rpb24gPSB0aGF0LnNlcXMudG9KU09OKClcbiAgICAgIGNvbnNvbGUud2FybiBcIm5vIHNlbGVjdGlvbiBmb3VuZFwiXG4gICAgdGV4dCA9IEZhc3RhLndyaXRlIHNlbGVjdGlvblxuICAgIGJsb2IgPSBuZXcgQmxvYihbdGV4dF0sIHt0eXBlIDogJ3RleHQvcGxhaW4nfSlcbiAgICBzYXZlQXMgYmxvYiwgbmFtZVxuXG4gIHNhdmVBbm5vdHM6ICh0aGF0LG5hbWUpIC0+XG4gICAgZmVhdHVyZXMgPSB0aGF0LnNlcXMubWFwIChlbCkgLT5cbiAgICAgIGZlYXR1cmVzID0gZWwuZ2V0IFwiZmVhdHVyZXNcIlxuICAgICAgcmV0dXJuIGlmIGZlYXR1cmVzLmxlbmd0aCBpcyAwXG4gICAgICBzZXFuYW1lID0gZWwuZ2V0KFwibmFtZVwiKVxuICAgICAgZmVhdHVyZXMuZWFjaCAocykgLT5cbiAgICAgICAgcy5zZXQgXCJzZXFuYW1lXCIsIHNlcW5hbWVcbiAgICAgIHJldHVybiBmZWF0dXJlcy50b0pTT04oKVxuICAgIGZlYXR1cmVzID0gXy5mbGF0dGVuIF8uY29tcGFjdCBmZWF0dXJlc1xuICAgIGNvbnNvbGUubG9nIGZlYXR1cmVzXG4gICAgdGV4dCA9IEdGRi5leHBvcnRMaW5lcyBmZWF0dXJlc1xuICAgIGJsb2IgPSBuZXcgQmxvYihbdGV4dF0sIHt0eXBlIDogJ3RleHQvcGxhaW4nfSlcbiAgICBzYXZlQXMgYmxvYiwgbmFtZVxuXG4gIHNhdmVBc0ltZzogKHRoYXQsbmFtZSkgLT5cbiAgICAgICMgVE9ETzogdGhpcyBpcyB2ZXJ5IHVnbHlcbiAgICAgIGNhbnZhcyA9IHRoYXQuZ2V0Vmlldygnc3RhZ2UnKS5nZXRWaWV3KCdib2R5JykuZ2V0Vmlldygnc2VxYmxvY2snKS5lbFxuICAgICAgaWYgY2FudmFzP1xuICAgICAgICB1cmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKVxuICAgICAgICBzYXZlQXMgYmxvYlVSTCh1cmwpLCBuYW1lLCBcImltYWdlL3BuZ1wiXG4iLCJGYXN0YVJlYWRlciA9IHJlcXVpcmUoXCJiaW9qcy1pby1mYXN0YVwiKVxuQ2x1c3RhbFJlYWRlciA9IHJlcXVpcmUgXCJiaW9qcy1pby1jbHVzdGFsXCJcbkdmZlJlYWRlciA9IHJlcXVpcmUgXCJiaW9qcy1pby1nZmZcIlxuXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbnhociA9IHJlcXVpcmUgXCJ4aHJcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVIZWxwZXIgPSAobXNhKSAtPlxuICBAbXNhID0gbXNhXG4gIEBcblxuZnVucyA9XG4gIGd1ZXNzRmlsZVR5cGU6IChuYW1lKSAtPlxuICAgIG5hbWUgPSBuYW1lLnNwbGl0KFwiLlwiKVxuICAgIGZpbGVOYW1lID0gbmFtZVtuYW1lLmxlbmd0aCAtMV1cbiAgICBzd2l0Y2ggZmlsZU5hbWVcbiAgICAgIHdoZW4gXCJhbG5cIiwgXCJjbHVzdGFsXCIgdGhlbiByZXR1cm4gQ2x1c3RhbFJlYWRlclxuICAgICAgd2hlbiBcImZhc3RhXCIgdGhlbiByZXR1cm4gRmFzdGFSZWFkZXJcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIEZhc3RhUmVhZGVyXG5cbiAgZ3Vlc3NGaWxlRnJvbVRleHQ6ICh0ZXh0KSAtPlxuICAgIHVubGVzcyB0ZXh0P1xuICAgICAgY29uc29sZS53YXJuIFwiaW52YWxpZCBmaWxlIGZvcm1hdFwiXG4gICAgICByZXR1cm4gW1wiXCIsIFwiZXJyb3JcIl1cbiAgICBpZiB0ZXh0LnN1YnN0cmluZygwLDcpIGlzIFwiQ0xVU1RBTFwiXG4gICAgICByZWFkZXIgPSBDbHVzdGFsUmVhZGVyXG4gICAgICB0eXBlID0gXCJzZXFzXCJcbiAgICBlbHNlIGlmIHRleHQuc3Vic3RyaW5nKDAsMSkgaXMgXCI+XCJcbiAgICAgIHJlYWRlciA9IEZhc3RhUmVhZGVyXG4gICAgICB0eXBlID0gXCJzZXFzXCJcbiAgICBlbHNlIGlmIHRleHQuc3Vic3RyaW5nKDAsMSkgaXMgXCIoXCJcbiAgICAgIHR5cGUgPSBcIm5ld2lja1wiXG4gICAgZWxzZVxuICAgICAgcmVhZGVyID0gR2ZmUmVhZGVyXG4gICAgICB0eXBlID0gXCJmZWF0dXJlc1wiXG4gICAgICAjY29uc29sZS53YXJuIFwiVW5rbm93biBmb3JtYXQuIENvbnRhY3QgZ3JlZW5pZnlcIlxuICAgIFtyZWFkZXIsdHlwZV1cblxuICBwYXJzZVRleHQ6ICh0ZXh0KSAtPlxuICAgIFtyZWFkZXIsIHR5cGVdID0gQGd1ZXNzRmlsZUZyb21UZXh0IHRleHRcbiAgICBpZiB0eXBlIGlzIFwic2Vxc1wiXG4gICAgICBzZXFzID0gcmVhZGVyLnBhcnNlIHRleHRcbiAgICAgIHJldHVybiBbc2Vxcyx0eXBlXVxuICAgIGVsc2UgaWYgdHlwZSBpcyBcImZlYXR1cmVzXCJcbiAgICAgIGZlYXR1cmVzID0gcmVhZGVyLnBhcnNlU2VxcyB0ZXh0XG4gICAgICByZXR1cm4gW2ZlYXR1cmVzLHR5cGVdXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFt0ZXh0LHR5cGVdXG5cbiAgaW1wb3J0RmlsZXM6IChmaWxlcykgLT5cbiAgICBmb3IgaSBpbiBbMC4uZmlsZXMubGVuZ3RoIC0gMV0gYnkgMVxuICAgICAgZmlsZSA9IGZpbGVzW2ldXG4gICAgICByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICByZWFkZXIub25sb2FkID0gKGV2dCkgPT5cbiAgICAgICAgQGltcG9ydEZpbGUgZXZ0LnRhcmdldC5yZXN1bHRcbiAgICAgIHJlYWRlci5yZWFkQXNUZXh0IGZpbGVcblxuICBpbXBvcnRGaWxlOiAoZmlsZSkgLT5cbiAgICBbb2JqcywgdHlwZV0gPSBAcGFyc2VUZXh0IGZpbGVcbiAgICBpZiB0eXBlIGlzIFwiZXJyb3JcIlxuICAgICAgICByZXR1cm4gXCJlcnJvclwiXG4gICAgaWYgdHlwZSBpcyBcInNlcXNcIlxuICAgICAgQG1zYS5zZXFzLnJlc2V0IG9ianNcbiAgICAgIEBtc2EuZy5jb25maWcuc2V0IFwidXJsXCIsIFwidXNlcmltcG9ydFwiXG4gICAgICBAbXNhLmcudHJpZ2dlciBcInVybDp1c2VySW1wb3J0XCJcbiAgICBlbHNlIGlmIHR5cGUgaXMgXCJmZWF0dXJlc1wiXG4gICAgICBAbXNhLnNlcXMuYWRkRmVhdHVyZXMgb2Jqc1xuICAgIGVsc2UgaWYgdHlwZSBpcyBcIm5ld2lja1wiXG4gICAgICBAbXNhLnUudHJlZS5sb2FkVHJlZSA9PlxuICAgICAgICBAbXNhLnUudHJlZS5zaG93VHJlZSBmaWxlXG5cbiAgICBmaWxlTmFtZSA9IGZpbGUubmFtZVxuXG4gIGltcG9ydFVSTDogKHVybCwgY2IpIC0+XG4gICAgdXJsID0gQG1zYS51LnByb3h5LmNvcnNVUkwgdXJsXG4gICAgQG1zYS5nLmNvbmZpZy5zZXQgXCJ1cmxcIiwgdXJsXG4gICAgeGhyIHVybCwgKGVycixzdGF0dXMsYm9keSkgPT5cbiAgICAgIHVubGVzcyBlcnJcbiAgICAgICAgcmVzID0gQGltcG9ydEZpbGUgYm9keVxuICAgICAgICBpZiByZXMgaXMgXCJlcnJvclwiXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIEBtc2EuZy50cmlnZ2VyIFwiaW1wb3J0OnVybFwiLCB1cmxcbiAgICAgICAgaWYgY2JcbiAgICAgICAgICBjYigpXG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUubG9nIGVyclxuXG5fLmV4dGVuZCBGaWxlSGVscGVyOjosIGZ1bnNcbiIsIm1vZHVsZS5leHBvcnRzLmJtYXRoID0gcmVxdWlyZShcIi4vYm1hdGhcIilcbm1vZHVsZS5leHBvcnRzLnByb3h5ID0gcmVxdWlyZShcIi4vcHJveHlcIilcbm1vZHVsZS5leHBvcnRzLnNlcWdlbiA9IHJlcXVpcmUoXCIuL3NlcWdlblwiKVxubW9kdWxlLmV4cG9ydHMuZmlsZSA9IHJlcXVpcmUoXCIuL2ZpbGVcIilcbm1vZHVsZS5leHBvcnRzLmV4cG9ydCA9IHJlcXVpcmUoXCIuL2V4cG9ydFwiKVxuIiwiayA9IHJlcXVpcmUgXCJrb2FsYS1qc1wiXG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZGVyID1cblxuICAjIGFzeW5jaHJvbm91c2x5IHJlcXVpcmUgYSBzY3JpcHRcbiAgbG9hZFNjcmlwdDogKHVybCwgY2IpIC0+XG4gICAgcyA9IGsubWsgXCJzY3JpcHRcIlxuICAgIHMudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICBzLnNyYyA9IHVybFxuICAgIHMuYXN5bmMgPSB0cnVlXG4gICAgcy5vbmxvYWQgPSBzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IC0+XG4gICAgICBpZiBub3QgciBhbmQgKG5vdCBAcmVhZHlTdGF0ZSBvciBAcmVhZHlTdGF0ZSBpcyBcImNvbXBsZXRlXCIpXG4gICAgICAgIHIgPSB0cnVlXG4gICAgICAgIGNiKClcbiAgICB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIilbMF1cbiAgICB0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQgc1xuXG4gICMgam9pbnMgbXVsdGlwbGUgY2FsbGJhY2tzIGludG8gb25lIGNhbGxiYWNrXG4gICMgYSBiaXQgbGlrZSBQcm9taXNlLmFsbCAtIGJ1dCBmb3IgY2FsbGJhY2tzXG4gIGpvaW5DYjogKHJldENiLCBmaW5hbExlbmd0aCwgZmluYWxTY29wZSkgLT5cbiAgICBmaW5hbExlbmd0aCA9IGZpbmFsTGVuZ3RoIHx8IDFcbiAgICBjYnNGaW5pc2hlZCA9IDBcblxuICAgIGNhbGxiYWNrV3JhcHBlciA9IChjYiwgc2NvcGUpIC0+XG4gICAgICBpZiBub3QgY2I/XG4gICAgICAgICMgZGlyZWN0bHkgY2FsbGVkICh3aXRob3V0IGNiKVxuICAgICAgICBjb3VudGVyKClcbiAgICAgIGVsc2VcbiAgICAgICAgLT5cbiAgICAgICAgICBpZiBcImFwcGx5XCIgaW4gY2JcbiAgICAgICAgICAgIGNiLmFwcGx5IHNjb3BlLCBhcmd1bWVudHNcbiAgICAgICAgICBjb3VudGVyKClcblxuICAgIGNvdW50ZXIgPSAtPlxuICAgICAgY2JzRmluaXNoZWQrK1xuICAgICAgaWYgY2JzRmluaXNoZWQgaXMgZmluYWxMZW5ndGhcbiAgICAgICAgcmV0Q2IuY2FsbCBmaW5hbFNjb3BlXG5cbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5SGVscGVyID0gKG9wdHMpIC0+XG4gIEBnID0gb3B0cy5nXG4gIEBcblxucHJveHlGdW4gPVxuXG4gIGNvcnNVUkw6ICh1cmwpIC0+XG4gICAgIyBkbyBub3QgZmlsdGVyIG9uIGxvY2FsaG9zdFxuICAgIHJldHVybiB1cmwgaWYgZG9jdW1lbnQuVVJMLmluZGV4T2YoJ2xvY2FsaG9zdCcpID49IDAgYW5kIHVybFswXSBpcyBcIi9cIlxuICAgIHJldHVybiB1cmwgaWYgdXJsLmNoYXJBdCgwKSBpcyBcIi5cIiBvciB1cmwuY2hhckF0KDApIGlzIFwiL1wiXG5cbiAgICAjIHJlbW92ZSB3d3cgKyBodHRwXG4gICAgdXJsID0gdXJsLnJlcGxhY2UgXCJ3d3dcXC5cIiwgXCJcIlxuICAgIHVybCA9IHVybC5yZXBsYWNlIFwiaHR0cDovL1wiLCBcIlwiXG5cbiAgICAjIHByZXBlbmQgcHJveHlcbiAgICB1cmwgPSBAZy5jb25maWcuZ2V0KCdpbXBvcnRQcm94eScpICsgdXJsXG4gICAgdXJsXG5cbl8uZXh0ZW5kIFByb3h5SGVscGVyOjosIHByb3h5RnVuXG4iLCJTZXF1ZW5jZSA9IHJlcXVpcmUoXCJiaW9qcy1tb2RlbFwiKS5zZXFcbkJNYXRoID0gcmVxdWlyZSBcIi4vYm1hdGhcIlxuU3RhdCA9IHJlcXVpcmUgXCJzdGF0LnNlcXNcIlxuXG5zZXFnZW4gPSBtb2R1bGUuZXhwb3J0cyA9XG4gIF9nZW5lcmF0ZVNlcXVlbmNlOiAobGVuKSAtPlxuICAgIHRleHQgPSBcIlwiXG4gICAgZm9yIGkgaW4gWzAuLmxlbiAtIDFdIGJ5IDFcbiAgICAgIHRleHQgKz0gc2VxZ2VuLmdldFJhbmRvbUNoYXIoKVxuICAgIHJldHVybiB0ZXh0XG5cbiAgIyBnZW5lcmF0ZXMgYSBkdW1teSBzZXF1ZW5jZXNcbiAgIyBAcGFyYW0gbGVuIFtpbnRdIG51bWJlciBvZiBnZW5lcmF0ZWQgc2VxdWVuY2VzXG4gICMgQHBhcmFtIHNlcUxlbiBbaW50XSBsZW5ndGggb2YgdGhlIGdlbmVyYXRlZCBzZXF1ZW5jZXNcbiAgZ2V0RHVtbXlTZXF1ZW5jZXM6IChsZW4sIHNlcUxlbikgLT5cbiAgICBzZXFzID0gW11cbiAgICBsZW4gPSBCTWF0aC5nZXRSYW5kb21JbnQgMyw1IHVubGVzcyBsZW4/XG4gICAgc2VxTGVuID0gQk1hdGguZ2V0UmFuZG9tSW50IDUwLDIwMCB1bmxlc3Mgc2VxTGVuP1xuXG4gICAgZm9yIGkgaW4gWzEuLmxlbl0gYnkgMVxuICAgICAgc2Vxcy5wdXNoIG5ldyBTZXF1ZW5jZShzZXFnZW4uX2dlbmVyYXRlU2VxdWVuY2Uoc2VxTGVuKSwgXCJzZXFcIiArIGksXG4gICAgICBcInJcIiArIGkpXG4gICAgcmV0dXJuIHNlcXNcblxuICBnZXRSYW5kb21DaGFyOiAoZGljdCkgLT5cbiAgICBwb3NzaWJsZSA9IGRpY3QgfHwgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiXG4gICAgcG9zc2libGUuY2hhckF0IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvc3NpYmxlLmxlbmd0aClcblxuICAjIGdlbmVyYXRlcyBhIGR1bW15IHNlcXVlbmNlc1xuICAjIEBwYXJhbSBsZW4gW2ludF0gbnVtYmVyIG9mIGdlbmVyYXRlZCBzZXF1ZW5jZXNcbiAgIyBAcGFyYW0gc2VxTGVuIFtpbnRdIGxlbmd0aCBvZiB0aGUgZ2VuZXJhdGVkIHNlcXVlbmNlc1xuICBnZW5Db25zZXJ2ZWRTZXF1ZW5jZXM6IChsZW4sIHNlcUxlbiwgZGljdCkgLT5cbiAgICBzZXFzID0gW11cbiAgICBsZW4gPSBCTWF0aC5nZXRSYW5kb21JbnQgMyw1IHVubGVzcyBsZW4/XG4gICAgc2VxTGVuID0gQk1hdGguZ2V0UmFuZG9tSW50IDUwLDIwMCB1bmxlc3Mgc2VxTGVuP1xuXG4gICAgZGljdCA9IGRpY3QgfHwgXCJBQ0RFRkdISUtMTU5QUVJTVFZXWS0tLVwiXG5cbiAgICBmb3IgaSBpbiBbMS4ubGVuXSBieSAxXG4gICAgICBzZXFzW2ktMV0gPSBcIlwiXG5cbiAgICB0b2xlcmFuY2UgPSAwLjJcblxuICAgIGNvbnNlcnZBaW0gPSAxXG4gICAgZm9yIGkgaW4gWzAuLiBzZXFMZW4gLSAxXSBieSAxXG4gICAgICBpZiBpICUgMyA9PSAwXG4gICAgICAgIGNvbnNlcnZBaW0gPSAoQk1hdGguZ2V0UmFuZG9tSW50IDUwLDEwMCkgLyAxMDBcbiAgICAgIG9ic2VydmVkID0gW11cbiAgICAgIGZvciBqIGluIFswLi5sZW4gLSAxXSBieSAxXG4gICAgICAgIGNvdW50ZXIgPSAwXG4gICAgICAgIHdoaWxlIGNvdW50ZXIgPCAxMDBcbiAgICAgICAgICBjID0gc2VxZ2VuLmdldFJhbmRvbUNoYXIgZGljdFxuICAgICAgICAgIGNDb25zZXJ2ID0gU3RhdCBvYnNlcnZlZFxuICAgICAgICAgIGNDb25zZXJ2LmFkZFNlcSBjXG4gICAgICAgICAgY291bnRlcisrXG4gICAgICAgICAgaWYgTWF0aC5hYnMoY29uc2VydkFpbSAtIGNDb25zZXJ2LnNjYWxlKGNDb25zZXJ2LmNvbnNlcnZhdGlvbigpKVswXSkgPCB0b2xlcmFuY2VcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIHNlcXNbal0gKz0gY1xuICAgICAgICBvYnNlcnZlZC5wdXNoIGNcblxuICAgIHBzZXFzID0gW11cbiAgICBmb3IgaSBpbiBbMS4ubGVuXSBieSAxXG4gICAgICBwc2Vxcy5wdXNoIG5ldyBTZXF1ZW5jZShzZXFzW2ktMV0sIFwic2VxXCIgKyBpLCBcInJcIiArIGkpXG5cbiAgICByZXR1cm4gcHNlcXNcbiIsIiMgbWluaSBzdmcgaGVscGVyXG5cbnN2Z25zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cbnNldEF0dHIgPSAob2JqLG9wdHMpIC0+XG4gIGZvciBuYW1lLCB2YWx1ZSBvZiBvcHRzXG4gICAgb2JqLnNldEF0dHJpYnV0ZU5TIG51bGwsIG5hbWUsIHZhbHVlXG4gIG9ialxuXG5CYXNlID0gKG9wdHMpIC0+XG4gIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyBzdmducywgJ3N2ZydcbiAgc3ZnLnNldEF0dHJpYnV0ZSBcIndpZHRoXCIsIG9wdHMud2lkdGhcbiAgc3ZnLnNldEF0dHJpYnV0ZSBcImhlaWdodFwiLCBvcHRzLmhlaWdodFxuICBzdmdcblxuUmVjdCA9IChvcHRzKSAtPlxuICByZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TIHN2Z25zLCAncmVjdCdcbiAgc2V0QXR0ciByZWN0LG9wdHNcblxuTGluZSA9IChvcHRzKSAtPlxuICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TIHN2Z25zLCAnbGluZSdcbiAgc2V0QXR0ciBsaW5lLG9wdHNcblxuUG9seWdvbiA9IChvcHRzKSAtPlxuICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TIHN2Z25zLCAncG9seWdvbidcbiAgc2V0QXR0ciBsaW5lLG9wdHNcblxubW9kdWxlLmV4cG9ydHMucmVjdCA9IFJlY3Rcbm1vZHVsZS5leHBvcnRzLmxpbmUgPSBMaW5lXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gUG9seWdvblxubW9kdWxlLmV4cG9ydHMuYmFzZSA9IEJhc2VcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHJlZUhlbHBlciA9ICAobXNhKSAtPlxuICBAbXNhID0gbXNhXG4gIEBcblxudGYgPVxuXG4gICAgbG9hZFRyZWU6IChjYikgLT5cbiAgICAgIEBtc2EuZy5wYWNrYWdlLmxvYWRQYWNrYWdlcyBbXCJtc2EtdG50XCIsIFwiYmlvanMtaW8tbmV3aWNrXCJdLCBjYlxuXG4gICAgc2hvd1RyZWU6IChuZXdpY2tTdHIpIC0+XG4gICAgICBuZXdpY2sgPSBAcmVxdWlyZSBcImJpb2pzLWlvLW5ld2lja1wiXG4gICAgICBpZiB0eXBlb2YgbmV3aWNrU3RyIGlzIFwic3RyaW5nXCJcbiAgICAgICAgbmV3aWNrT2JqID0gbmV3aWNrLnBhcnNlX25ld2ljayBuZXdpY2tTdHJcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3aWNrT2JqID0gbmV3aWNrU3RyXG5cbiAgICAgIG10ID0gQHJlcXVpcmUgXCJtc2EtdG50XCJcblxuICAgICAgc2VsID0gbmV3IG10LnNlbGVjdGlvbnMoKVxuICAgICAgdHJlZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgXCJkaXZcIlxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCB0cmVlRGl2XG5cbiAgICAgIGNvbnNvbGUubG9nIEBtc2Euc2Vxcy5tb2RlbHNcbiAgICAgIGNvbnNvbGUubG9nIG5ld2lja09ialxuXG4gICAgICBub2RlcyA9IG10LmFwcFxuICAgICAgICBzZXFzOiBAbXNhLnNlcXMubW9kZWxzXG4gICAgICAgIHRyZWU6IG5ld2lja09ialxuXG4gICAgICBjb25zb2xlLmxvZyBcIm5vZGVzXCIsIG5vZGVzXG5cbiAgICAgIHQgPSBuZXcgbXQuYWRhcHRlcnMudHJlZVxuICAgICAgICBtb2RlbDogbm9kZXMsXG4gICAgICAgIGVsOiB0cmVlRGl2LFxuICAgICAgICBzZWw6IHNlbCxcblxuICAgICAgdHJlZURpdi5zdHlsZS53aWR0aCA9IFwiNTAwcHhcIlxuXG4gICAgIyB3b3JrYXJvdW5kIGFnYWluc3QgYnJvd3NlcmlmeSdzIHN0YXRpYyBhbmFseXNpc1xuICAgIHJlcXVpcmU6IChwa2cpIC0+XG4gICAgICByZXF1aXJlIHBrZ1xuXG5fLmV4dGVuZCB0cmVlSGVscGVyOjogLCB0ZlxuIiwiYm9uZVZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtY2hpbGRzXCIpXG5TZXFCbG9jayA9IHJlcXVpcmUgXCIuL2NhbnZhcy9DYW52YXNTZXFCbG9ja1wiXG5MYWJlbEJsb2NrID0gcmVxdWlyZSBcIi4vbGFiZWxzL0xhYmVsQmxvY2tcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGJvbmVWaWV3LmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG5cbiAgICBpZiB0cnVlXG4gICAgICBsYWJlbGJsb2NrID0gbmV3IExhYmVsQmxvY2sge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgICAgbGFiZWxibG9jay5vcmRlcmluZyA9IC0xXG4gICAgICBAYWRkVmlldyBcImxhYmVsYmxvY2tcIixsYWJlbGJsb2NrXG5cbiAgICBpZiBAZy52aXMuZ2V0IFwic2VxdWVuY2VzXCJcbiAgICAgIHNlcWJsb2NrID0gbmV3IFNlcUJsb2NrIHttb2RlbDogQG1vZGVsLCBnOiBAZ31cbiAgICAgIHNlcWJsb2NrLm9yZGVyaW5nID0gMFxuICAgICAgQGFkZFZpZXcgXCJzZXFibG9ja1wiLHNlcWJsb2NrXG5cbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTphbGlnbm1lbnRIZWlnaHRcIiwgQGFkanVzdEhlaWdodFxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsIFwiY2hhbmdlOmFsaWdubWVudFdpZHRoXCIsIEBhZGp1c3RXaWR0aFxuICAgIEBsaXN0ZW5UbyBAZy5jb2x1bW5zLCBcImNoYW5nZTpoaWRkZW5cIiwgQGFkanVzdEhlaWdodFxuXG4gIHJlbmRlcjogLT5cbiAgICBAcmVuZGVyU3Vidmlld3MoKVxuICAgIEBlbC5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9hbGJvZHlcIlxuICAgIEBlbC5zdHlsZS53aGl0ZVNwYWNlID0gXCJub3dyYXBcIlxuICAgIEBhZGp1c3RIZWlnaHQoKVxuICAgIEBhZGp1c3RXaWR0aCgpXG4gICAgQFxuXG4gIGFkanVzdEhlaWdodDogLT5cbiAgICBpZiBAZy56b29tZXIuZ2V0KFwiYWxpZ25tZW50SGVpZ2h0XCIpIGlzIFwiYXV0b1wiXG4gICAgICAjIFRPRE86IGZpeCB0aGUgbWFnaWMgNVxuICAgICAgQGVsLnN0eWxlLmhlaWdodCA9IChAZy56b29tZXIuZ2V0KFwicm93SGVpZ2h0XCIpICogQG1vZGVsLmxlbmd0aCkgKyA1XG4gICAgZWxzZVxuICAgICAgQGVsLnN0eWxlLmhlaWdodCA9IEBnLnpvb21lci5nZXQgXCJhbGlnbm1lbnRIZWlnaHRcIlxuXG4gIGFkanVzdFdpZHRoOiAtPlxuICAgICMgVE9ETzogMTUgaXMgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxiYXJcbiAgICBAZWwuc3R5bGUud2lkdGggPSBAZ2V0V2lkdGgoKVxuXG4gIGdldFdpZHRoOiAtPlxuICAgIHdpZHRoID0gMFxuICAgIHdpZHRoICs9IEBnLnpvb21lci5nZXRMZWZ0QmxvY2tXaWR0aCgpXG4gICAgaWYgQGcudmlzLmdldCBcInNlcXVlbmNlc1wiXG4gICAgICB3aWR0aCArPSBAZy56b29tZXIuZ2V0IFwiYWxpZ25tZW50V2lkdGhcIlxuICAgIHdpZHRoXG4iLCJ2aWV3ID0gcmVxdWlyZShcImJhY2tib25lLXZpZXdqXCIpXG5tb3VzZSA9IHJlcXVpcmUgXCJtb3VzZS1wb3NcIlxuc2VsZWN0aW9uID0gcmVxdWlyZSBcIi4uL2cvc2VsZWN0aW9uL1NlbGVjdGlvblwiXG5qYm9uZSA9IHJlcXVpcmUgXCJqYm9uZVwiXG5fID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJ2aWV3Qm94ID0gdmlldy5leHRlbmRcblxuICBjbGFzc05hbWU6IFwiYmlvanNfbXNhX292ZXJ2aWV3Ym94XCJcbiAgdGFnTmFtZTogXCJjYW52YXNcIlxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGxpc3RlblRvIEBnLnpvb21lcixcImNoYW5nZTpib3hSZWN0V2lkdGggY2hhbmdlOmJveFJlY3RIZWlnaHRcbiAgICBjaGFuZ2U6b3ZlcnZpZXdib3hQYWRkaW5nVG9wXCIsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcuc2VsY29sLCBcImFkZCByZXNldCBjaGFuZ2VcIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy5jb2x1bW5zLCBcImNoYW5nZTpoaWRkZW5cIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy5jb2xvcnNjaGVtZSwgXCJjaGFuZ2U6c2hvd0xvd2VyQ2FzZVwiLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEBtb2RlbCwgXCJjaGFuZ2VcIiwgXy5kZWJvdW5jZSBAcmVuZGVyLCA1XG5cbiAgICAjIGNvbG9yXG4gICAgQGNvbG9yID0gQGcuY29sb3JzY2hlbWUuZ2V0U2VsZWN0ZWRTY2hlbWUoKVxuICAgIEBsaXN0ZW5UbyBAZy5jb2xvcnNjaGVtZSwgXCJjaGFuZ2U6c2NoZW1lXCIsIC0+XG4gICAgICBAY29sb3IgPSBAZy5jb2xvcnNjaGVtZS5nZXRTZWxlY3RlZFNjaGVtZSgpXG4gICAgICBAcmVuZGVyKClcbiAgICBAZHJhZ1N0YXJ0ID0gW11cblxuICBldmVudHM6XG4gICAgY2xpY2s6IFwiX29uY2xpY2tcIlxuICAgIG1vdXNlZG93bjogXCJfb25tb3VzZWRvd25cIlxuXG4gIHJlbmRlcjogLT5cbiAgICBAX2NyZWF0ZUNhbnZhcygpXG4gICAgQGVsLnRleHRDb250ZW50ID0gXCJvdmVydmlld1wiXG4gICAgQGVsLnN0eWxlLm1hcmdpblRvcCA9IEBnLnpvb21lci5nZXQgXCJvdmVydmlld2JveFBhZGRpbmdUb3BcIlxuXG4gICAgIyBiYWNrZ3JvdW5kIGJnIGZvciBub24tZHJhd2VkIGFyZWFcbiAgICBAY3R4LmZpbGxTdHlsZSA9IFwiIzk5OTk5OVwiXG4gICAgQGN0eC5maWxsUmVjdCAwLDAsQGVsLndpZHRoLEBlbC5oZWlnaHRcblxuICAgIHJlY3RXaWR0aCA9IEBnLnpvb21lci5nZXQgXCJib3hSZWN0V2lkdGhcIlxuICAgIHJlY3RIZWlnaHQgPSBAZy56b29tZXIuZ2V0IFwiYm94UmVjdEhlaWdodFwiXG4gICAgaGlkZGVuID0gQGcuY29sdW1ucy5nZXQgXCJoaWRkZW5cIlxuICAgIHNob3dMb3dlckNhc2UgPSBAZy5jb2xvcnNjaGVtZS5nZXQgXCJzaG93TG93ZXJDYXNlXCJcblxuICAgIHkgPSAtcmVjdEhlaWdodFxuICAgIGZvciBpIGluIFswLi4gQG1vZGVsLmxlbmd0aCAtIDFdIGJ5IDFcbiAgICAgIHNlcSA9IEBtb2RlbC5hdChpKS5nZXQgXCJzZXFcIlxuICAgICAgeCA9IDBcbiAgICAgIHkgPSB5ICsgcmVjdEhlaWdodFxuXG5cbiAgICAgIGlmIEBtb2RlbC5hdChpKS5nZXQgXCJoaWRkZW5cIlxuICAgICAgICAjIGhpZGRlbiBzZXFcbiAgICAgICAgY29uc29sZS5sb2cgQG1vZGVsLmF0KGkpLmdldCBcImhpZGRlblwiXG4gICAgICAgIEBjdHguZmlsbFN0eWxlID0gXCJncmV5XCJcbiAgICAgICAgQGN0eC5maWxsUmVjdCAwLHksc2VxLmxlbmd0aCAqIHJlY3RXaWR0aCxyZWN0SGVpZ2h0XG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGZvciBqIGluIFswLi4gc2VxLmxlbmd0aCAtIDFdIGJ5IDFcbiAgICAgICAgYyA9IHNlcVtqXVxuICAgICAgICAjIHRvZG86IG9wdGlvbmFsIHVwcGVyY2FzaW5nXG4gICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCkgaWYgc2hvd0xvd2VyQ2FzZVxuICAgICAgICBjb2xvciA9IEBjb2xvci5nZXRDb2xvciBjLCB7cG9zOiBqfVxuXG4gICAgICAgIGlmIGhpZGRlbi5pbmRleE9mKGopID49IDBcbiAgICAgICAgICBjb2xvciA9IFwiZ3JleVwiXG5cbiAgICAgICAgaWYgY29sb3I/XG4gICAgICAgICAgQGN0eC5maWxsU3R5bGUgPSBjb2xvclxuICAgICAgICAgIEBjdHguZmlsbFJlY3QgeCx5LHJlY3RXaWR0aCxyZWN0SGVpZ2h0XG5cbiAgICAgICAgeCA9IHggKyByZWN0V2lkdGhcblxuICAgIEBfZHJhd1NlbGVjdGlvbigpXG5cbiAgX2RyYXdTZWxlY3Rpb246IC0+XG4gICAgIyBoaWRlIGR1cmluZyBzZWxlY3Rpb25cbiAgICByZXR1cm4gaWYgQGRyYWdTdGFydC5sZW5ndGggPiAwIGFuZCBub3QgQHByb2xvbmdTZWxlY3Rpb25cblxuICAgIHJlY3RXaWR0aCA9IEBnLnpvb21lci5nZXQgXCJib3hSZWN0V2lkdGhcIlxuICAgIHJlY3RIZWlnaHQgPSBAZy56b29tZXIuZ2V0IFwiYm94UmVjdEhlaWdodFwiXG4gICAgbWF4SGVpZ2h0ID0gcmVjdEhlaWdodCAqIEBtb2RlbC5sZW5ndGhcbiAgICBAY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmYwMFwiXG4gICAgQGN0eC5nbG9iYWxBbHBoYSA9IDAuOVxuICAgIGZvciBpIGluIFswLi4gQGcuc2VsY29sLmxlbmd0aCAtIDFdIGJ5IDFcbiAgICAgIHNlbCA9IEBnLnNlbGNvbC5hdChpKVxuICAgICAgaWYgc2VsLmdldCgndHlwZScpIGlzICdjb2x1bW4nXG4gICAgICAgIEBjdHguZmlsbFJlY3QgcmVjdFdpZHRoICogc2VsLmdldCgneFN0YXJ0JyksMCxyZWN0V2lkdGggKlxuICAgICAgICAoc2VsLmdldCgneEVuZCcpIC0gc2VsLmdldCgneFN0YXJ0JykgKyAxKSxtYXhIZWlnaHRcbiAgICAgIGVsc2UgaWYgc2VsLmdldCgndHlwZScpIGlzICdyb3cnXG4gICAgICAgIHNlcSA9IChAbW9kZWwuZmlsdGVyIChlbCkgLT4gZWwuZ2V0KCdpZCcpIGlzIHNlbC5nZXQoJ3NlcUlkJykpWzBdXG4gICAgICAgIHBvcyA9IEBtb2RlbC5pbmRleE9mKHNlcSlcbiAgICAgICAgQGN0eC5maWxsUmVjdCAwLHJlY3RIZWlnaHQgKiBwb3MsIHJlY3RXaWR0aCAqIHNlcS5nZXQoJ3NlcScpLmxlbmd0aCwgcmVjdEhlaWdodFxuICAgICAgZWxzZSBpZiBzZWwuZ2V0KCd0eXBlJykgaXMgJ3BvcydcbiAgICAgICAgc2VxID0gKEBtb2RlbC5maWx0ZXIgKGVsKSAtPiBlbC5nZXQoJ2lkJykgaXMgc2VsLmdldCgnc2VxSWQnKSlbMF1cbiAgICAgICAgcG9zID0gQG1vZGVsLmluZGV4T2Yoc2VxKVxuICAgICAgICBAY3R4LmZpbGxSZWN0IHJlY3RXaWR0aCAqIHNlbC5nZXQoJ3hTdGFydCcpLHJlY3RIZWlnaHQgKiBwb3MsIHJlY3RXaWR0aCAqIChzZWwuZ2V0KCd4RW5kJykgLSBzZWwuZ2V0KCd4U3RhcnQnKSArIDEpLCByZWN0SGVpZ2h0XG5cbiAgICBAY3R4Lmdsb2JhbEFscGhhID0gMVxuXG4gIF9vbmNsaWNrOiAoZXZ0KSAtPlxuICAgIEBnLnRyaWdnZXIgXCJtZXRhOmNsaWNrXCIsIHtzZXFJZDogQG1vZGVsLmdldCBcImlkXCIsIGV2dDpldnR9XG5cbiAgX29ubW91c2Vtb3ZlOiAoZSkgLT5cbiAgICAjIGR1cGxpY2F0ZSBldmVudHNcbiAgICByZXR1cm4gaWYgQGRyYWdTdGFydC5sZW5ndGggaXMgMFxuXG4gICAgQHJlbmRlcigpXG4gICAgQGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmMDBcIlxuICAgIEBjdHguZ2xvYmFsQWxwaGEgPSAwLjlcblxuICAgIHJlY3QgPSBAX2NhbGNTZWxlY3Rpb24oIG1vdXNlLmFicyBlIClcbiAgICBAY3R4LmZpbGxSZWN0IHJlY3RbMF1bMF0scmVjdFsxXVswXSxyZWN0WzBdWzFdIC0gcmVjdFswXVswXSwgcmVjdFsxXVsxXSAtIHJlY3RbMV1bMF1cblxuICAgICMgYWJvcnQgc2VsZWN0aW9uIGV2ZW50cyBvZiB0aGUgYnJvd3NlclxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAjIHN0YXJ0IHRoZSBzZWxlY3Rpb24gbW9kZVxuICBfb25tb3VzZWRvd246IChlKSAtPlxuICAgIEBkcmFnU3RhcnQgPSBtb3VzZS5hYnMgZVxuICAgIEBkcmFnU3RhcnRSZWwgPSBtb3VzZS5yZWwgZVxuXG4gICAgaWYgZS5jdHJsS2V5IG9yIGUubWV0YUtleVxuICAgICAgQHByb2xvbmdTZWxlY3Rpb24gPSB0cnVlXG4gICAgZWxzZVxuICAgICAgQHByb2xvbmdTZWxlY3Rpb24gPSBmYWxzZVxuICAgICMgZW5hYmxlIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAnbW91c2Vtb3ZlLm92ZXJtb3ZlJywgKGUpID0+IEBfb25tb3VzZW1vdmUoZSlcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAnbW91c2V1cC5vdmVydXAnLCAoZSkgPT4gQF9vbm1vdXNldXAoZSlcbiAgICByZXR1cm4gQGRyYWdTdGFydFxuXG4gICMgY2FsY3VsYXRlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgX2NhbGNTZWxlY3Rpb246IChkcmFnTW92ZSkgLT5cbiAgICAjIHJlbGF0aXZlIHRvIGZpcnN0IGNsaWNrXG4gICAgZHJhZ1JlbCA9IFtkcmFnTW92ZVswXSAtIEBkcmFnU3RhcnRbMF0sIGRyYWdNb3ZlWzFdIC0gQGRyYWdTdGFydFsxXV1cblxuICAgICMgcmVsYXRpdmUgdG8gdGFyZ2V0XG4gICAgZm9yIGkgaW4gWzAuLjFdIGJ5IDFcbiAgICAgIGRyYWdSZWxbaV0gPSBAZHJhZ1N0YXJ0UmVsW2ldICsgZHJhZ1JlbFtpXVxuXG4gICAgIyAwOngsIDE6IHlcbiAgICByZWN0ID0gW1tAZHJhZ1N0YXJ0UmVsWzBdLCBkcmFnUmVsWzBdXSwgW0BkcmFnU3RhcnRSZWxbMV0sIGRyYWdSZWxbMV1dXVxuXG4gICAgIyBzd2FwIHRoZSBjb29yZGluYXRlcyBpZiBuZWVkZWRcbiAgICBmb3IgaSBpbiBbMC4uMV0gYnkgMVxuICAgICAgaWYgcmVjdFtpXVsxXSA8IHJlY3RbaV1bMF1cbiAgICAgICAgcmVjdFtpXSA9IFtyZWN0W2ldWzFdLCByZWN0W2ldWzBdXVxuXG4gICAgICAjIGxvd2VyIGxpbWl0XG4gICAgICByZWN0W2ldWzBdID0gTWF0aC5tYXggcmVjdFtpXVswXSwgMFxuXG4gICAgcmV0dXJuIHJlY3RcblxuICBfZW5kU2VsZWN0aW9uOiAoZHJhZ0VuZCkgLT5cbiAgICAjIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vZmYoJy5vdmVybW92ZScpXG4gICAgamJvbmUoZG9jdW1lbnQuYm9keSkub2ZmKCcub3ZlcnVwJylcblxuICAgICMgZHVwbGljYXRlIGV2ZW50c1xuICAgIHJldHVybiBpZiBAZHJhZ1N0YXJ0Lmxlbmd0aCBpcyAwXG5cbiAgICByZWN0ID0gQF9jYWxjU2VsZWN0aW9uIGRyYWdFbmRcblxuICAgICMgeFxuICAgIGZvciBpIGluIFswLi4xXVxuICAgICAgcmVjdFswXVtpXSA9IE1hdGguZmxvb3IoIHJlY3RbMF1baV0gLyBAZy56b29tZXIuZ2V0KFwiYm94UmVjdFdpZHRoXCIpKVxuXG4gICAgIyB5XG4gICAgZm9yIGkgaW4gWzAuLjFdXG4gICAgICByZWN0WzFdW2ldID0gTWF0aC5mbG9vciggcmVjdFsxXVtpXSAvIEBnLnpvb21lci5nZXQoXCJib3hSZWN0SGVpZ2h0XCIpIClcblxuICAgICMgdXBwZXIgbGltaXRcbiAgICByZWN0WzBdWzFdID0gTWF0aC5taW4oQG1vZGVsLmdldE1heExlbmd0aCgpIC0gMSwgcmVjdFswXVsxXSlcbiAgICByZWN0WzFdWzFdID0gTWF0aC5taW4oQG1vZGVsLmxlbmd0aCAtIDEsIHJlY3RbMV1bMV0pXG5cbiAgICAjIHNlbGVjdFxuICAgIHNlbGlzID0gW11cbiAgICBmb3IgaiBpbiBbcmVjdFsxXVswXS4ucmVjdFsxXVsxXV0gYnkgMVxuICAgICAgYXJncyA9IHNlcUlkOiBAbW9kZWwuYXQoaikuZ2V0KCdpZCcpLCB4U3RhcnQ6IHJlY3RbMF1bMF0sIHhFbmQ6IHJlY3RbMF1bMV1cbiAgICAgIHNlbGlzLnB1c2ggbmV3IHNlbGVjdGlvbi5wb3NzZWwgYXJnc1xuXG4gICAgIyByZXNldFxuICAgIEBkcmFnU3RhcnQgPSBbXVxuICAgICMgbG9vayBmb3IgY3RybCBrZXlcbiAgICBpZiBAcHJvbG9uZ1NlbGVjdGlvblxuICAgICAgQGcuc2VsY29sLmFkZCBzZWxpc1xuICAgIGVsc2VcbiAgICAgIEBnLnNlbGNvbC5yZXNldCBzZWxpc1xuXG4gICAgIyBzYWZldHkgY2hlY2sgKyB1cGRhdGUgb2Zmc2V0XG4gICAgQGcuem9vbWVyLnNldExlZnRPZmZzZXQgcmVjdFswXVswXVxuICAgIEBnLnpvb21lci5zZXRUb3BPZmZzZXQgcmVjdFsxXVswXVxuXG4gICMgZW5kcyB0aGUgc2VsZWN0aW9uIG1vZGVcbiAgX29ubW91c2V1cDogKGUpIC0+XG4gICAgQF9lbmRTZWxlY3Rpb24gbW91c2UuYWJzIGVcblxuICBfb25tb3VzZW91dDogKGUpIC0+XG4gICAgQF9lbmRTZWxlY3Rpb24gbW91c2UuYWJzIGVcblxuICMgaW5pdCB0aGUgY2FudmFzXG4gIF9jcmVhdGVDYW52YXM6IC0+XG4gICAgcmVjdFdpZHRoID0gQGcuem9vbWVyLmdldCBcImJveFJlY3RXaWR0aFwiXG4gICAgcmVjdEhlaWdodCA9IEBnLnpvb21lci5nZXQgXCJib3hSZWN0SGVpZ2h0XCJcblxuICAgIEBlbC5oZWlnaHQgPSBAbW9kZWwubGVuZ3RoICogcmVjdEhlaWdodFxuICAgIEBlbC53aWR0aCA9IEBtb2RlbC5nZXRNYXhMZW5ndGgoKSAqIHJlY3RXaWR0aFxuICAgIEBjdHggPSBAZWwuZ2V0Q29udGV4dCBcIjJkXCJcbiAgICBAZWwuc3R5bGUub3ZlcmZsb3cgPSBcInNjcm9sbFwiXG4gICAgQGVsLnN0eWxlLmN1cnNvciA9IFwiY3Jvc3NoYWlyXCJcbiIsImJvbmVWaWV3ID0gcmVxdWlyZShcImJhY2tib25lLWNoaWxkc1wiKVxuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5rID0gcmVxdWlyZSAna29hbGEtanMnXG5kb20gPSByZXF1aXJlICdkb20taGVscGVyJ1xuc2VsID0gcmVxdWlyZSBcIi4uL2cvc2VsZWN0aW9uL1NlbGVjdGlvblwiXG5cbiMgdGhpcyBpcyBhIHZlcnkgc2ltcGxpc3RpYyBhcHByb2FjaCB0byBzaG93IHNlYXJjaCByZXN1bHRcbiMgVE9ETzogbmVlZHMgcHJvcGVyIHN0eWxpbmdcbm1vZHVsZS5leHBvcnRzID0gYm9uZVZpZXcuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQGcgPSBkYXRhLmdcblxuICAgIEBsaXN0ZW5UbyBAZy51c2VyLCBcImNoYW5nZTpzZWFyY2hUZXh0XCIsIChtb2RlbCwgcHJvcCkgLT5cbiAgICAgIEBzZWFyY2ggcHJvcFxuICAgICAgQHJlbmRlcigpXG4gICAgQHNlbCA9IFtdXG4gICAgQHNlbFBvcyA9IDBcblxuICBldmVudHM6XG4gICAgXCJzY3JvbGxcIjogXCJfc2VuZFNjcm9sbEV2ZW50XCJcblxuICByZW5kZXI6IC0+XG4gICAgQHJlbmRlclN1YnZpZXdzKClcblxuICAgIEBlbC5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9zZWFyY2hyZXN1bHRcIlxuICAgIHNlYXJjaFRleHQgPSBAZy51c2VyLmdldChcInNlYXJjaFRleHRcIilcbiAgICBpZiBzZWFyY2hUZXh0PyBhbmQgc2VhcmNoVGV4dC5sZW5ndGggPiAwXG4gICAgICBpZiBAc2VsLmxlbmd0aCBpcyAwXG4gICAgICAgIEBlbC50ZXh0Q29udGVudCA9IFwibm8gc2VsZWN0aW9uIGZvdW5kXCJcbiAgICAgIGVsc2VcbiAgICAgICAgQHJlc3VsdEJveCA9IGsubWsgXCJkaXZcIlxuICAgICAgICBAcmVzdWx0Qm94LmNsYXNzTmFtZSA9IFwiYmlvanNfbXNhX3NlYXJjaHJlc3VsdF9vdmJveFwiXG4gICAgICAgIEB1cGRhdGVSZXN1bHQoKVxuICAgICAgICBAZWwuYXBwZW5kQ2hpbGQgQHJlc3VsdEJveFxuICAgICAgICBAZWwuYXBwZW5kQ2hpbGQgQGJ1aWxkQnRucygpXG4gICAgQFxuXG4gIHVwZGF0ZVJlc3VsdDogLT5cbiAgICAgIHRleHQgPSBcInNlYXJjaCBwYXR0ZXJuOiBcIiArIEBnLnVzZXIuZ2V0KFwic2VhcmNoVGV4dFwiKVxuICAgICAgdGV4dCArPSBcIiwgc2VsZWN0aW9uOiBcIiArIChAc2VsUG9zICsgMSlcbiAgICAgIHNlbGkgPSBAc2VsW0BzZWxQb3NdXG4gICAgICB0ZXh0ICs9IFwiIChcIlxuICAgICAgdGV4dCArPSBzZWxpLmdldChcInhTdGFydFwiKSArIFwiIC0gXCIgKyBzZWxpLmdldChcInhFbmRcIilcbiAgICAgIHRleHQgKz0gXCIsIGlkOiBcIiArIHNlbGkuZ2V0KFwic2VxSWRcIilcbiAgICAgIHRleHQgKz0gXCIpXCJcbiAgICAgIEByZXN1bHRCb3gudGV4dENvbnRlbnQgPSB0ZXh0XG5cbiAgYnVpbGRCdG5zOiAtPlxuICAgIHByZXZCdG4gPSBrLm1rIFwiYnV0dG9uXCJcbiAgICBwcmV2QnRuLnRleHRDb250ZW50ID0gXCJQcmV2XCJcbiAgICBwcmV2QnRuLmFkZEV2ZW50TGlzdGVuZXIgXCJjbGlja1wiLCA9PlxuICAgICAgQG1vdmVTZWwgLTFcblxuICAgIG5leHRCdG4gPSBrLm1rIFwiYnV0dG9uXCJcbiAgICBuZXh0QnRuLnRleHRDb250ZW50ID0gXCJOZXh0XCJcbiAgICBuZXh0QnRuLmFkZEV2ZW50TGlzdGVuZXIgXCJjbGlja1wiLCA9PlxuICAgICAgQG1vdmVTZWwgMVxuXG4gICAgYWxsQnRuID0gay5tayBcImJ1dHRvblwiXG4gICAgYWxsQnRuLnRleHRDb250ZW50ID0gXCJBbGxcIlxuICAgIGFsbEJ0bi5hZGRFdmVudExpc3RlbmVyIFwiY2xpY2tcIiwgPT5cbiAgICAgIEBnLnNlbGNvbC5yZXNldCBAc2VsXG5cbiAgICBzZWFyY2hyb3cgPSBrLm1rIFwiZGl2XCJcbiAgICBzZWFyY2hyb3cuYXBwZW5kQ2hpbGQgcHJldkJ0blxuICAgIHNlYXJjaHJvdy5hcHBlbmRDaGlsZCBuZXh0QnRuXG4gICAgc2VhcmNocm93LmFwcGVuZENoaWxkIGFsbEJ0blxuICAgIHNlYXJjaHJvdy5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9zZWFyY2hyZXN1bHRfcm93XCJcbiAgICBzZWFyY2hyb3dcblxuICBtb3ZlU2VsOiAocmVsRGlzdCkgLT5cbiAgICBzZWxOZXcgPSBAc2VsUG9zICsgcmVsRGlzdFxuICAgIGlmIHNlbE5ldyA8IDAgb3Igc2VsTmV3ID49IEBzZWwubGVuZ3RoXG4gICAgICByZXR1cm4gLTFcbiAgICBlbHNlXG4gICAgICBAZm9jdXMgc2VsTmV3XG4gICAgICBAc2VsUG9zID0gc2VsTmV3XG4gICAgICBAdXBkYXRlUmVzdWx0KClcblxuICBmb2N1czogKHNlbFBvcykgLT5cbiAgICBzZWxpID0gQHNlbFtzZWxQb3NdXG4gICAgbGVmdEluZGV4ID0gc2VsaS5nZXQgXCJ4U3RhcnRcIlxuICAgIEBnLnpvb21lci5zZXRMZWZ0T2Zmc2V0IGxlZnRJbmRleFxuICAgIEBnLnNlbGNvbC5yZXNldCBbc2VsaV1cblxuICBzZWFyY2g6IChzZWFyY2hUZXh0KSAtPlxuICAgICMgbWFya3MgYWxsIGhpdHNcbiAgICBzZWFyY2ggPSBuZXcgUmVnRXhwIHNlYXJjaFRleHQsIFwiZ2lcIlxuICAgIG5ld1NlbGkgPSBbXVxuICAgIGxlZnRlc3RJbmRleCA9IG9yaWdJbmRleCA9IDEwMDA0MlxuXG4gICAgQG1vZGVsLmVhY2ggKHNlcSkgLT5cbiAgICAgIHN0clNlcSA9IHNlcS5nZXQoXCJzZXFcIilcbiAgICAgIHdoaWxlIG1hdGNoID0gc2VhcmNoLmV4ZWMgc3RyU2VxXG4gICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXhcbiAgICAgICAgYXJncyA9IHt4U3RhcnQ6IGluZGV4LCB4RW5kOiBpbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIDEsIHNlcUlkOlxuICAgICAgICAgIHNlcS5nZXQoXCJpZFwiKX1cbiAgICAgICAgbmV3U2VsaS5wdXNoIG5ldyBzZWwucG9zc2VsKGFyZ3MpXG4gICAgICAgIGxlZnRlc3RJbmRleCA9IE1hdGgubWluIGluZGV4LCBsZWZ0ZXN0SW5kZXhcblxuICAgIEBnLnNlbGNvbC5yZXNldCBuZXdTZWxpXG5cbiAgICAjIHNhZmV0eSBjaGVjayArIHVwZGF0ZSBvZmZzZXRcbiAgICBsZWZ0ZXN0SW5kZXggPSAwIGlmIGxlZnRlc3RJbmRleCBpcyBvcmlnSW5kZXhcbiAgICBAZy56b29tZXIuc2V0TGVmdE9mZnNldCBsZWZ0ZXN0SW5kZXhcblxuICAgIEBzZWwgPSBuZXdTZWxpXG4iLCJib25lVmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS1jaGlsZHNcIilcbkFsaWdubWVudEJvZHkgPSByZXF1aXJlIFwiLi9BbGlnbm1lbnRCb2R5XCJcbkhlYWRlckJsb2NrID0gcmVxdWlyZSBcIi4vaGVhZGVyL0hlYWRlckJsb2NrXCJcbk92ZXJ2aWV3Qm94ID0gcmVxdWlyZSBcIi4vT3ZlcnZpZXdCb3hcIlxuU2VhcmNoID0gcmVxdWlyZSBcIi4vU2VhcmNoXCJcbl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuXG4jIGEgbmVhdCBjb2xsZWN0aW9uIHZpZXdcbm1vZHVsZS5leHBvcnRzID0gYm9uZVZpZXcuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQGcgPSBkYXRhLmdcblxuICAgIEBkcmF3KClcbiAgICAjQGxpc3RlblRvIEBtb2RlbCxcInJlc2V0XCIsIC0+XG4gICAgIyB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgc3RhdHMgZ2l2ZXMgdXMgdGhlIG9rXG4gICAgQGxpc3RlblRvIEBnLnN0YXRzLFwicmVzZXRcIiwgLT5cbiAgICAgIEByZXJlbmRlcigpXG5cbiAgICAjIGRlYm91bmNlIGEgYnVsayBvcGVyYXRpb25cbiAgICBAbGlzdGVuVG8gQG1vZGVsLFwiY2hhbmdlOmhpZGRlblwiLCBfLmRlYm91bmNlIEByZXJlbmRlciwgMTBcblxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsXCJzb3J0XCIsIEByZXJlbmRlclxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsXCJhZGRcIiwgLT5cbiAgICAgIGNvbnNvbGUubG9nIFwic2VxIGFkZFwiXG5cbiAgICBAbGlzdGVuVG8gQGcudmlzLFwiY2hhbmdlOnNlcXVlbmNlc1wiLCBAcmVyZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcudmlzLFwiY2hhbmdlOm92ZXJ2aWV3Ym94XCIsIEByZXJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy52aXNvcmRlcixcImNoYW5nZVwiLCBAcmVyZW5kZXJcblxuICBkcmF3OiAtPlxuICAgIEByZW1vdmVWaWV3cygpXG5cbiAgICBpZiBAZy52aXMuZ2V0IFwib3ZlcnZpZXdib3hcIlxuICAgICAgb3ZlcnZpZXdib3ggPSBuZXcgT3ZlcnZpZXdCb3gge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgICAgb3ZlcnZpZXdib3gub3JkZXJpbmcgPSBAZy52aXNvcmRlci5nZXQgJ292ZXJ2aWV3Qm94J1xuICAgICAgQGFkZFZpZXcgXCJvdmVydmlld0JveFwiLCBvdmVydmlld2JveFxuXG4gICAgaWYgdHJ1ZVxuICAgICAgaGVhZGVyYmxvY2sgPSBuZXcgSGVhZGVyQmxvY2sge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgICAgaGVhZGVyYmxvY2sub3JkZXJpbmcgPSBAZy52aXNvcmRlci5nZXQgJ2hlYWRlckJveCdcbiAgICAgIEBhZGRWaWV3IFwiaGVhZGVyQm94XCIsIGhlYWRlcmJsb2NrXG5cbiAgICBpZiB0cnVlXG4gICAgICBzZWFyY2hibG9jayA9IG5ldyBTZWFyY2gge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgICAgc2VhcmNoYmxvY2sub3JkZXJpbmcgPSBAZy52aXNvcmRlci5nZXQgJ3NlYXJjaEJveCdcbiAgICAgIEBhZGRWaWV3IFwic2VhcmNoYm94XCIsIHNlYXJjaGJsb2NrXG5cbiAgICBib2R5ID0gbmV3IEFsaWdubWVudEJvZHkge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgIGJvZHkub3JkZXJpbmcgPSBAZy52aXNvcmRlci5nZXQgJ2FsaWdubWVudEJvZHknXG4gICAgQGFkZFZpZXcgXCJib2R5XCIsYm9keVxuXG4gIHJlbmRlcjogLT5cbiAgICBAcmVuZGVyU3Vidmlld3MoKVxuICAgIEBlbC5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9zdGFnZVwiXG5cbiAgICBAXG5cbiAgcmVyZW5kZXI6IC0+XG4gICAgQGRyYXcoKVxuICAgIEByZW5kZXIoKVxuIiwiRXZlbnRzID0gcmVxdWlyZShcImJpb2pzLWV2ZW50c1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENhbnZhc0NoYXJDYWNoZVxuXG4gIGNvbnN0cnVjdG9yOiAoQGcpIC0+XG4gICAgQGNhY2hlID0ge31cbiAgICBAY2FjaGVIZWlnaHQgPSAwXG4gICAgQGNhY2hlV2lkdGggPSAwXG5cbiAgIyByZXR1cm5zIGEgY2FjaGVkIGNhbnZhc1xuICBnZXRGb250VGlsZTogKGxldHRlciwgd2lkdGgsIGhlaWdodCkgLT5cbiAgICAjIHZhbGlkYXRlIGNhY2hlXG4gICAgaWYgd2lkdGggaXNudCBAY2FjaGVXaWR0aCBvciBoZWlnaHQgaXNudCBAY2FjaGVIZWlnaHRcbiAgICAgIEBjYWNoZUhlaWdodCA9IGhlaWdodFxuICAgICAgQGNhY2hlV2lkdGggPSB3aWR0aFxuICAgICAgQGNhY2hlID0ge31cblxuICAgIGlmIEBjYWNoZVtsZXR0ZXJdIGlzIHVuZGVmaW5lZFxuICAgICAgQGNyZWF0ZVRpbGUgbGV0dGVyLCB3aWR0aCwgaGVpZ2h0XG5cbiAgICByZXR1cm4gQGNhY2hlW2xldHRlcl1cblxuICAjIGNyZWF0ZXMgYSBjYW52YXMgd2l0aCBhIHNpbmdsZSBsZXR0ZXJcbiAgIyAoZm9yIHRoZSBmYXN0IGZvbnQgY2FjaGUpXG4gIGNyZWF0ZVRpbGU6IChsZXR0ZXIsIHdpZHRoLCBoZWlnaHQpIC0+XG5cbiAgICBjYW52YXMgPSBAY2FjaGVbbGV0dGVyXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgXCJjYW52YXNcIlxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgIEBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCAnMmQnXG4gICAgQGN0eC5mb250ID0gQGcuem9vbWVyLmdldChcInJlc2lkdWVGb250XCIpICsgXCJweCBtb25vXCJcblxuICAgIEBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSdcbiAgICBAY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCJcblxuICAgIEBjdHguZmlsbFRleHQgbGV0dGVyLHdpZHRoIC8gMixoZWlnaHQgLyAyLHdpZHRoXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuRXZlbnRzID0gcmVxdWlyZSBcImJpb2pzLWV2ZW50c1wiXG5cbmNhY2hlID1cblxuICBzZXRNYXhTY3JvbGxIZWlnaHQ6IC0+XG4gICAgQG1heFNjcm9sbEhlaWdodCA9IEBnLnpvb21lci5nZXRNYXhBbGlnbm1lbnRIZWlnaHQoKSAtIEBnLnpvb21lci5nZXQoJ2FsaWdubWVudEhlaWdodCcpXG5cbiAgc2V0TWF4U2Nyb2xsV2lkdGg6IC0+XG4gICAgQG1heFNjcm9sbFdpZHRoID0gQGcuem9vbWVyLmdldE1heEFsaWdubWVudFdpZHRoKCkgLSBAZy56b29tZXIuZ2V0QWxpZ25tZW50V2lkdGgoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlQ29uc3RydWN0b3IgPSAoZyxtb2RlbCkgLT5cbiAgdGhpcy5nID0gZ1xuICB0aGlzLm1vZGVsID0gbW9kZWxcbiAgQG1heFNjcm9sbFdpZHRoID0gMFxuICBAbWF4U2Nyb2xsSGVpZ2h0ID0gMFxuICBAc2V0TWF4U2Nyb2xsSGVpZ2h0KClcbiAgQHNldE1heFNjcm9sbFdpZHRoKClcblxuICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpyb3dIZWlnaHRcIiwgQHNldE1heFNjcm9sbEhlaWdodFxuICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpjb2x1bW5XaWR0aFwiLCBAc2V0TWF4U2Nyb2xsV2lkdGhcbiAgQGxpc3RlblRvIEBnLnpvb21lciwgXCJjaGFuZ2U6YWxpZ25tZW50V2lkdGhcIiwgQHNldE1heFNjcm9sbFdpZHRoXG4gIEBsaXN0ZW5UbyBAZy56b29tZXIsIFwiY2hhbmdlOmFsaWdubWVudEhlaWdodFwiLCBAc2V0TWF4U2Nyb2xsSGVpZ2h0XG4gIEBsaXN0ZW5UbyBAbW9kZWwsIFwiYWRkIGNoYW5nZSByZXNldFwiLCAtPlxuICAgIEBzZXRNYXhTY3JvbGxIZWlnaHQoKVxuICAgIEBzZXRNYXhTY3JvbGxXaWR0aCgpXG4gICwgQFxuICBAXG5cbl8uZXh0ZW5kIGNhY2hlQ29uc3RydWN0b3I6OiwgY2FjaGVcbkV2ZW50cy5taXhpbiBjYWNoZUNvbnN0cnVjdG9yOjpcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uQ2xhc3MgPSAoZyxjdHgpIC0+XG4gIEBnID0gZ1xuICBAY3R4ID0gY3R4XG4gIEBcblxuXy5leHRlbmQoU2VsZWN0aW9uQ2xhc3M6OixcblxuICAjIFRPRE86IHNob3VsZCBJIGJlIG1vdmVkIHRvIHRoZSBzZWxlY3Rpb24gbWFuYWdlcj9cbiAgIyByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByZXNpZHVlc1xuICAjIGUuZy4gWzAsM10gPSBwb3MgMCBhbmQgMyBhcmUgc2VsZWN0ZWRcbiAgX2dldFNlbGVjdGlvbjogKG1vZGVsKSAtPlxuICAgIG1heExlbiA9IG1vZGVsLmdldChcInNlcVwiKS5sZW5ndGhcbiAgICBzZWxlY3Rpb24gPSBbXVxuICAgIHNlbHMgPSBAZy5zZWxjb2wuZ2V0U2VsRm9yUm93IG1vZGVsLmdldCBcImlkXCJcbiAgICByb3dzID0gXy5maW5kIHNlbHMsIChlbCkgLT4gZWwuZ2V0KFwidHlwZVwiKSBpcyBcInJvd1wiXG4gICAgaWYgcm93cz9cbiAgICAgICMgZnVsbCBtYXRjaFxuICAgICAgZm9yIG4gaW4gWzAuLm1heExlbiAtIDFdIGJ5IDFcbiAgICAgICAgc2VsZWN0aW9uLnB1c2ggblxuICAgIGVsc2UgaWYgc2Vscy5sZW5ndGggPiAwXG4gICAgICBmb3Igc2VsIGluIHNlbHNcbiAgICAgICAgZm9yIG4gaW4gW3NlbC5nZXQoXCJ4U3RhcnRcIikuLnNlbC5nZXQoXCJ4RW5kXCIpXSBieSAxXG4gICAgICAgICAgc2VsZWN0aW9uLnB1c2ggblxuXG4gICAgcmV0dXJuIHNlbGVjdGlvblxuXG4gICMgbG9vcHMgb3ZlciBhbGwgc2VsZWN0aW9uIGFuZCBjYWxscyB0aGUgcmVuZGVyIG1ldGhvZFxuICBfYXBwZW5kU2VsZWN0aW9uOiAoZGF0YSkgLT5cbiAgICBzZXEgPSBkYXRhLm1vZGVsLmdldChcInNlcVwiKVxuICAgIHNlbGVjdGlvbiA9IEBfZ2V0U2VsZWN0aW9uIGRhdGEubW9kZWxcbiAgICAjIGdldCB0aGUgc3RhdHVzIG9mIHRoZSB1cHBlciBhbmQgbG93ZXIgcm93XG4gICAgW21QcmV2U2VsLG1OZXh0U2VsXSA9IEBfZ2V0UHJldk5leHRTZWxlY3Rpb24gZGF0YS5tb2RlbFxuXG4gICAgYm94V2lkdGggPSBAZy56b29tZXIuZ2V0KFwiY29sdW1uV2lkdGhcIilcbiAgICBib3hIZWlnaHQgPSBAZy56b29tZXIuZ2V0KFwicm93SGVpZ2h0XCIpXG5cbiAgICAjIGF2b2lkIHVubmVjZXNzYXJ5IGxvb3BzXG4gICAgcmV0dXJuIGlmIHNlbGVjdGlvbi5sZW5ndGggaXMgMFxuXG4gICAgaGlkZGVuT2Zmc2V0ID0gMFxuICAgIGZvciBuIGluIFswLi5zZXEubGVuZ3RoIC0gMV0gYnkgMVxuICAgICAgaWYgZGF0YS5oaWRkZW4uaW5kZXhPZihuKSA+PSAwXG4gICAgICAgIGhpZGRlbk9mZnNldCsrXG4gICAgICBlbHNlXG4gICAgICAgIGsgPSBuIC0gaGlkZGVuT2Zmc2V0XG4gICAgICAgICMgb25seSBpZiBpdHMgYSBuZXcgc2VsZWN0aW9uXG4gICAgICAgIGlmIHNlbGVjdGlvbi5pbmRleE9mKG4pID49IDAgYW5kIChrIGlzIDAgb3Igc2VsZWN0aW9uLmluZGV4T2YobiAtIDEpIDwgMCApXG4gICAgICAgICAgQF9yZW5kZXJTZWxlY3Rpb24gbjpuLGs6ayxzZWxlY3Rpb246IHNlbGVjdGlvbixtUHJldlNlbDogbVByZXZTZWwsbU5leHRTZWw6bU5leHRTZWwsIHhaZXJvOiBkYXRhLnhaZXJvLCB5WmVybzogZGF0YS55WmVybywgbW9kZWw6IGRhdGEubW9kZWxcblxuICAjIGRyYXdzIGEgc2luZ2xlIHVzZXIgc2VsZWN0aW9uXG4gIF9yZW5kZXJTZWxlY3Rpb246IChkYXRhKSAtPlxuXG4gICAgeFplcm8gPSBkYXRhLnhaZXJvXG4gICAgeVplcm8gPSBkYXRhLnlaZXJvXG4gICAgbiA9IGRhdGEublxuICAgIGsgPSBkYXRhLmtcbiAgICBzZWxlY3Rpb24gPSBkYXRhLnNlbGVjdGlvblxuICAgICMgYW5kIGNoZWNrcyB0aGUgcHJldiBhbmQgbmV4dCByb3cgZm9yIHNlbGVjdGlvbiAgLT4gbm8gYm9yZGVycyBpbiBhIHNlbGVjdGlvblxuICAgIG1QcmV2U2VsPSBkYXRhLm1QcmV2U2VsXG4gICAgbU5leHRTZWwgPSBkYXRhLm1OZXh0U2VsXG5cbiAgICAjIGdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgc2VsZWN0aW9uXG4gICAgc2VsZWN0aW9uTGVuZ3RoID0gMFxuICAgIGZvciBpIGluIFtuLi4gZGF0YS5tb2RlbC5nZXQoXCJzZXFcIikubGVuZ3RoIC0gMV0gYnkgMVxuICAgICAgaWYgc2VsZWN0aW9uLmluZGV4T2YoaSkgPj0gMFxuICAgICAgICBzZWxlY3Rpb25MZW5ndGgrK1xuICAgICAgZWxzZVxuICAgICAgICBicmVha1xuXG4gICAgIyBUT0RPOiB1Z2x5IVxuICAgIGJveFdpZHRoID0gQGcuem9vbWVyLmdldChcImNvbHVtbldpZHRoXCIpXG4gICAgYm94SGVpZ2h0ID0gQGcuem9vbWVyLmdldChcInJvd0hlaWdodFwiKVxuICAgIHRvdGFsV2lkdGggPSAoYm94V2lkdGggKiBzZWxlY3Rpb25MZW5ndGgpICsgMVxuXG4gICAgaGlkZGVuID0gQGcuY29sdW1ucy5nZXQoJ2hpZGRlbicpXG5cbiAgICBAY3R4LmJlZ2luUGF0aCgpXG4gICAgYmVmb3JlV2lkdGggPSBAY3R4LmxpbmVXaWR0aFxuICAgIEBjdHgubGluZVdpZHRoID0gM1xuICAgIGJlZm9yZVN0eWxlID0gQGN0eC5zdHJva2VTdHlsZVxuICAgIEBjdHguc3Ryb2tlU3R5bGUgPSBcIiNGRjAwMDBcIlxuXG4gICAgeFplcm8gKz0gayAqIGJveFdpZHRoXG5cbiAgICAjIHNwbGl0IHVwIHRoZSBzZWxlY3Rpb24gaW50byBzaW5nbGUgY2VsbHNcbiAgICB4UGFydCA9IDBcbiAgICBmb3IgaSBpbiBbMC4uIHNlbGVjdGlvbkxlbmd0aCAtIDFdXG4gICAgICB4UG9zID0gbiArIGlcbiAgICAgIGlmIGhpZGRlbi5pbmRleE9mKHhQb3MpID49IDBcbiAgICAgICAgY29udGludWVcbiAgICAgICMgdXBwZXIgbGluZVxuICAgICAgdW5sZXNzIG1QcmV2U2VsPyBhbmQgbVByZXZTZWwuaW5kZXhPZih4UG9zKSA+PSAwXG4gICAgICAgIEBjdHgubW92ZVRvIHhaZXJvICsgeFBhcnQsIHlaZXJvXG4gICAgICAgIEBjdHgubGluZVRvIHhQYXJ0ICsgYm94V2lkdGggKyB4WmVybywgeVplcm9cbiAgICAgICMgbG93ZXIgbGluZVxuICAgICAgdW5sZXNzIG1OZXh0U2VsPyBhbmQgbU5leHRTZWwuaW5kZXhPZih4UG9zKSA+PSAwXG4gICAgICAgIEBjdHgubW92ZVRvIHhQYXJ0ICsgeFplcm8sIGJveEhlaWdodCArIHlaZXJvXG4gICAgICAgIEBjdHgubGluZVRvIHhQYXJ0ICsgYm94V2lkdGggKyB4WmVybywgYm94SGVpZ2h0ICsgeVplcm9cblxuICAgICAgeFBhcnQgKz0gYm94V2lkdGhcblxuICAgICMgbGVmdFxuICAgIEBjdHgubW92ZVRvIHhaZXJvLHlaZXJvXG4gICAgQGN0eC5saW5lVG8geFplcm8sIGJveEhlaWdodCArIHlaZXJvXG5cbiAgICAjIHJpZ2h0XG4gICAgQGN0eC5tb3ZlVG8geFplcm8gKyB0b3RhbFdpZHRoLHlaZXJvXG4gICAgQGN0eC5saW5lVG8geFplcm8gKyB0b3RhbFdpZHRoLCBib3hIZWlnaHQgKyB5WmVyb1xuXG4gICAgQGN0eC5zdHJva2UoKVxuICAgIEBjdHguc3Ryb2tlU3R5bGUgPSBiZWZvcmVTdHlsZVxuICAgIEBjdHgubGluZVdpZHRoID0gYmVmb3JlV2lkdGhcblxuICAjIGxvb2tzIGF0IHRoZSBzZWxlY3Rpb24gb2YgdGhlIHByZXYgYW5kIG5leHQgZWxcbiAgIyBUT0RPOiB0aGlzIGlzIHZlcnkgbmFpdmUsIGFzIHRoZXJlIG1pZ2h0IGJlIGdhcHMgYWJvdmUgb3IgYmVsb3dcbiAgX2dldFByZXZOZXh0U2VsZWN0aW9uOiAobW9kZWwpIC0+XG5cbiAgICBtb2RlbFByZXYgPSBtb2RlbC5jb2xsZWN0aW9uLnByZXYgbW9kZWxcbiAgICBtb2RlbE5leHQgPSBtb2RlbC5jb2xsZWN0aW9uLm5leHQgbW9kZWxcbiAgICBtUHJldlNlbCA9IEBfZ2V0U2VsZWN0aW9uIG1vZGVsUHJldiBpZiBtb2RlbFByZXY/XG4gICAgbU5leHRTZWwgPSBAX2dldFNlbGVjdGlvbiBtb2RlbE5leHQgaWYgbW9kZWxOZXh0P1xuICAgIFttUHJldlNlbCxtTmV4dFNlbF1cbilcbiIsImJvbmVWaWV3ID0gcmVxdWlyZShcImJhY2tib25lLWNoaWxkc1wiKVxubW91c2UgPSByZXF1aXJlIFwibW91c2UtcG9zXCJcbl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5qYm9uZSA9IHJlcXVpcmUgXCJqYm9uZVwiXG5DaGFyQ2FjaGUgPSByZXF1aXJlIFwiLi9DYW52YXNDaGFyQ2FjaGVcIlxuU2VsZWN0aW9uQ2xhc3MgPSByZXF1aXJlIFwiLi9DYW52YXNTZWxlY3Rpb25cIlxuQ2FudmFzU2VxRHJhd2VyID0gcmVxdWlyZSBcIi4vQ2FudmFzU2VxRHJhd2VyXCJcbkNhbnZhc0Nvb3Jkc0NhY2hlID0gcmVxdWlyZSBcIi4vQ2FudmFzQ29vcmRzQ2FjaGVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGJvbmVWaWV3LmV4dGVuZFxuXG4gIHRhZ05hbWU6IFwiY2FudmFzXCJcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuXG4gICAgQGxpc3RlblRvIEBnLnpvb21lciwgXCJjaGFuZ2U6X2FsaWdubWVudFNjcm9sbExlZnQgY2hhbmdlOl9hbGlnbm1lbnRTY3JvbGxUb3BcIiwgKG1vZGVsLHZhbHVlLCBvcHRpb25zKSAtPlxuICAgICAgaWYgKG5vdCBvcHRpb25zPy5vcmlnaW4/KSBvciBvcHRpb25zLm9yaWdpbiBpc250IFwiY2FudmFzc2VxXCJcbiAgICAgICAgQHJlbmRlcigpXG5cbiAgICBAbGlzdGVuVG8gQGcuY29sdW1ucyxcImNoYW5nZTpoaWRkZW5cIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsXCJjaGFuZ2U6YWxpZ25tZW50V2lkdGggY2hhbmdlOmFsaWdubWVudEhlaWdodFwiLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEBnLmNvbG9yc2NoZW1lLCBcImNoYW5nZVwiLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEBnLnNlbGNvbCwgXCJyZXNldCBhZGRcIiwgQHJlbmRlclxuXG4gICAgIyBlbCBwcm9wc1xuICAgIEBlbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgIEBlbC5zdHlsZS5vdmVyZmxvd1ggPSBcImhpZGRlblwiXG4gICAgQGVsLnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCJcbiAgICBAZWwuY2xhc3NOYW1lID0gXCJiaW9qc19tc2Ffc2VxYmxvY2tcIlxuXG4gICAgQGN0eCA9IEBlbC5nZXRDb250ZXh0ICcyZCdcbiAgICBAY2FjaGUgPSBuZXcgQ2hhckNhY2hlIEBnXG4gICAgQGNvb3Jkc0NhY2hlID0gbmV3IENhbnZhc0Nvb3Jkc0NhY2hlIEBnLCBAbW9kZWxcblxuICAgICMgY2xlYXIgdGhlIGNoYXIgY2FjaGVcbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpyZXNpZHVlRm9udFwiLCAtPlxuICAgICAgQGNhY2hlID0gbmV3IENoYXJDYWNoZSBAZ1xuICAgICAgQHJlbmRlcigpXG5cbiAgICAjIGluaXQgc2VsZWN0aW9uXG4gICAgQHNlbCA9IG5ldyBTZWxlY3Rpb25DbGFzcyBAZyxAY3R4XG5cbiAgICBAX3NldENvbG9yKClcblxuICAgICMgdGhyb3R0bGUgdGhlIGV4cGVuc2l2ZSBkcmF3IGZ1bmN0aW9uXG4gICAgQHRocm90dGxlVGltZSA9IDBcbiAgICBAdGhyb3R0bGVDb3VudHMgPSAwXG4gICAgaWYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdEFwcGVhcmFuY2U/XG4gICAgICAjIHdlYmtpdCBicm93c2VyIC0gbm8gdGhyb3R0bGluZyBuZWVkZWRcbiAgICAgIEB0aHJvdHRsZWREcmF3ID0gLT5cbiAgICAgICAgc3RhcnQgPSArbmV3IERhdGUoKVxuICAgICAgICBAZHJhdygpXG4gICAgICAgIEB0aHJvdHRsZVRpbWUgKz0gK25ldyBEYXRlKCkgLSBzdGFydFxuICAgICAgICBAdGhyb3R0bGVDb3VudHMrK1xuICAgICAgICBpZiBAdGhyb3R0bGVDb3VudHMgPiAxNVxuICAgICAgICAgIHRUaW1lID0gTWF0aC5jZWlsKEB0aHJvdHRsZVRpbWUgLyBAdGhyb3R0bGVDb3VudHMpXG4gICAgICAgICAgY29uc29sZS5sb2cgXCJhdmdEcmF3VGltZS9XZWJLaXRcIiwgdFRpbWVcbiAgICAgICAgICAjIHJlbW92ZSBwZXJmIGFuYWx5c2VyXG4gICAgICAgICAgQHRocm90dGxlZERyYXcgPSBAZHJhd1xuICAgIGVsc2VcbiAgICAgICMgc2xvdyBicm93c2VycyBsaWtlIEdlY2tvXG4gICAgICBAdGhyb3R0bGVkRHJhdyA9IF8udGhyb3R0bGUgQHRocm90dGxlZERyYXcsIDMwXG5cbiAgICBAbWFuYWdlRXZlbnRzKClcblxuXG4gICMgbWVhc3VyZXMgdGhlIHRpbWUgb2YgYSByZWRyYXcgYW5kIHRodXMgc2V0IHRoZSB0aHJvdHRsZSBsaW1pdFxuICB0aHJvdHRsZWREcmF3OiAtPlxuICAgICMgK25ldyBpcyB0aGUgZmFzdGVzdDogaHR0cDovL2pzcGVyZi5jb20vbmV3LWRhdGUtdnMtZGF0ZS1ub3ctdnMtcGVyZm9ybWFuY2Utbm93LzZcbiAgICBzdGFydCA9ICtuZXcgRGF0ZSgpXG4gICAgQGRyYXcoKVxuICAgIEB0aHJvdHRsZVRpbWUgKz0gK25ldyBEYXRlKCkgLSBzdGFydFxuICAgIEB0aHJvdHRsZUNvdW50cysrXG5cbiAgICAjIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgYW5hbHlzaXNcbiAgICBpZiBAdGhyb3R0bGVDb3VudHMgPiAxNVxuICAgICAgdFRpbWUgPSBNYXRoLmNlaWwoQHRocm90dGxlVGltZSAvIEB0aHJvdHRsZUNvdW50cylcbiAgICAgIGNvbnNvbGUubG9nIFwiYXZnRHJhd1RpbWVcIiwgdFRpbWVcbiAgICAgIHRUaW1lICo9ICAxLjIgIyBhZGQgc2FmZXR5IHRpbWVcbiAgICAgIHRUaW1lID0gTWF0aC5tYXggMjAsIHRUaW1lICMgbGltaXQgZm9yIHVsdHJhIGZhc3QgY29tcHV0ZXJzXG4gICAgICBAdGhyb3R0bGVkRHJhdyA9IF8udGhyb3R0bGUgQGRyYXcsIHRUaW1lXG5cbiAgbWFuYWdlRXZlbnRzOiAtPlxuICAgIGV2ZW50cyA9IHt9XG4gICAgZXZlbnRzLm1vdXNlZG93biA9IFwiX29ubW91c2Vkb3duXCJcbiAgICBldmVudHMudG91Y2hzdGFydCA9IFwiX29udG91Y2hzdGFydFwiXG5cbiAgICBpZiBAZy5jb25maWcuZ2V0IFwicmVnaXN0ZXJNb3VzZUNsaWNrc1wiXG4gICAgICBldmVudHMuZGJsY2xpY2sgPSBcIl9vbmNsaWNrXCJcbiAgICBpZiBAZy5jb25maWcuZ2V0IFwicmVnaXN0ZXJNb3VzZUhvdmVyXCJcbiAgICAgIGV2ZW50cy5tb3VzZWluID0gXCJfb25tb3VzZWluXCJcbiAgICAgIGV2ZW50cy5tb3VzZW91dCA9IFwiX29ubW91c2VvdXRcIlxuXG4gICAgZXZlbnRzLm1vdXNld2hlZWwgPSBcIl9vbm1vdXNld2hlZWxcIlxuICAgIGV2ZW50cy5ET01Nb3VzZVNjcm9sbCA9IFwiX29ubW91c2V3aGVlbFwiXG4gICAgQGRlbGVnYXRlRXZlbnRzIGV2ZW50c1xuXG4gICAgIyBsaXN0ZW4gZm9yIGNoYW5nZXNcbiAgICBAbGlzdGVuVG8gQGcuY29uZmlnLCBcImNoYW5nZTpyZWdpc3Rlck1vdXNlSG92ZXJcIiwgQG1hbmFnZUV2ZW50c1xuICAgIEBsaXN0ZW5UbyBAZy5jb25maWcsIFwiY2hhbmdlOnJlZ2lzdGVyTW91c2VDbGlja1wiLCBAbWFuYWdlRXZlbnRzXG4gICAgQGRyYWdTdGFydCA9IFtdXG5cbiAgX3NldENvbG9yOiAtPlxuICAgIEBjb2xvciA9IEBnLmNvbG9yc2NoZW1lLmdldFNlbGVjdGVkU2NoZW1lKClcblxuICBkcmF3OiAtPlxuICAgICMgZmFzdGVzdCB3YXkgdG8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICMgaHR0cDovL2pzcGVyZi5jb20vY2FudmFzLWNsZWFyLXNwZWVkLzI1XG4gICAgQGVsLndpZHRoID0gQGVsLndpZHRoXG5cbiAgICAjIGRyYXcgYWxsIHRoZSBzdHVmZlxuICAgIGlmIEBzZXFEcmF3ZXI/ICBhbmQgQG1vZGVsLmxlbmd0aCA+IDBcbiAgICAgICMgY2hhciBiYXNlZFxuICAgICAgQHNlcURyYXdlci5kcmF3TGV0dGVycygpXG4gICAgICAjIHJvdyBiYXNlZFxuICAgICAgQHNlcURyYXdlci5kcmF3Um93cyBAc2VsLl9hcHBlbmRTZWxlY3Rpb24sIEBzZWxcbiAgICAgIEBzZXFEcmF3ZXIuZHJhd1Jvd3MgQGRyYXdGZWF0dXJlcywgQFxuXG4gIGRyYXdGZWF0dXJlczogKGRhdGEpIC0+XG4gICAgcmVjdFdpZHRoID0gQGcuem9vbWVyLmdldCBcImNvbHVtbldpZHRoXCJcbiAgICByZWN0SGVpZ2h0ID0gQGcuem9vbWVyLmdldCBcInJvd0hlaWdodFwiXG4gICAgaWYgZGF0YS5tb2RlbC5hdHRyaWJ1dGVzLmhlaWdodCA+IDFcbiAgICAgIGN0eCA9IEBjdHhcbiAgICAgIGRhdGEubW9kZWwuYXR0cmlidXRlcy5mZWF0dXJlcy5lYWNoIChmZWF0dXJlKSAtPlxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmVhdHVyZS5hdHRyaWJ1dGVzLmZpbGxDb2xvciB8fCBcInJlZFwiXG4gICAgICAgIGxlbiA9IGZlYXR1cmUuYXR0cmlidXRlcy54RW5kIC0gZmVhdHVyZS5hdHRyaWJ1dGVzLnhTdGFydCArIDFcbiAgICAgICAgeSA9IChmZWF0dXJlLmF0dHJpYnV0ZXMucm93ICsgMSkgKiByZWN0SGVpZ2h0XG4gICAgICAgIGN0eC5maWxsUmVjdCBmZWF0dXJlLmF0dHJpYnV0ZXMueFN0YXJ0ICogcmVjdFdpZHRoICsgZGF0YS54WmVybyx5ICsgZGF0YS55WmVybyxyZWN0V2lkdGggKiBsZW4scmVjdEhlaWdodFxuXG4gICAgICAjIGRyYXcgdGV4dFxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIlxuICAgICAgY3R4LmZvbnQgPSBAZy56b29tZXIuZ2V0KFwicmVzaWR1ZUZvbnRcIikgKyBcInB4IG1vbm9cIlxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuXG4gICAgICBkYXRhLm1vZGVsLmF0dHJpYnV0ZXMuZmVhdHVyZXMuZWFjaCAoZmVhdHVyZSkgLT5cbiAgICAgICAgbGVuID0gZmVhdHVyZS5hdHRyaWJ1dGVzLnhFbmQgLSBmZWF0dXJlLmF0dHJpYnV0ZXMueFN0YXJ0ICsgMVxuICAgICAgICB5ID0gKGZlYXR1cmUuYXR0cmlidXRlcy5yb3cgKyAxKSAqIHJlY3RIZWlnaHRcbiAgICAgICAgY3R4LmZpbGxUZXh0IGZlYXR1cmUuYXR0cmlidXRlcy50ZXh0LCBkYXRhLnhaZXJvICsgZmVhdHVyZS5hdHRyaWJ1dGVzLnhTdGFydCAqXG4gICAgICAgIHJlY3RXaWR0aCArIChsZW4gLyAyKSAqIHJlY3RXaWR0aCwgZGF0YS55WmVybyArIHJlY3RIZWlnaHQgKiAwLjUgKyB5XG5cbiAgcmVuZGVyOiAtPlxuXG4gICAgQGVsLnNldEF0dHJpYnV0ZSAnaGVpZ2h0JywgQGcuem9vbWVyLmdldChcImFsaWdubWVudEhlaWdodFwiKSArIFwicHhcIlxuICAgIEBlbC5zZXRBdHRyaWJ1dGUgJ3dpZHRoJywgQGcuem9vbWVyLmdldEFsaWdubWVudFdpZHRoKCkgKyBcInB4XCJcblxuICAgIEBnLnpvb21lci5fY2hlY2tTY3JvbGxpbmcoIEBfY2hlY2tTY3JvbGxpbmcoW0BnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxMZWZ0JyksXG4gICAgQGcuem9vbWVyLmdldCgnX2FsaWdubWVudFNjcm9sbFRvcCcpXSApLHtoZWFkZXI6IFwiY2FudmFzc2VxXCJ9KVxuXG4gICAgQF9zZXRDb2xvcigpXG5cbiAgICBAc2VxRHJhd2VyID0gbmV3IENhbnZhc1NlcURyYXdlciBAZyxAY3R4LEBtb2RlbCxcbiAgICAgIHdpZHRoOiBAZWwud2lkdGgsXG4gICAgICBoZWlnaHQ6IEBlbC5oZWlnaHRcbiAgICAgIGNvbG9yOiBAY29sb3JcbiAgICAgIGNhY2hlOiBAY2FjaGVcblxuICAgIEB0aHJvdHRsZWREcmF3KClcbiAgICBAXG5cbiAgX29ubW91c2Vtb3ZlOiAoZSwgcmV2ZXJzZWQpIC0+XG4gICAgcmV0dXJuIGlmIEBkcmFnU3RhcnQubGVuZ3RoIGlzIDBcblxuICAgIGRyYWdFbmQgPSBtb3VzZS5hYnMgZVxuICAgICMgcmVsYXRpdmUgdG8gZmlyc3QgY2xpY2tcbiAgICByZWxFbmQgPSBbZHJhZ0VuZFswXSAtIEBkcmFnU3RhcnRbMF0sIGRyYWdFbmRbMV0gLSBAZHJhZ1N0YXJ0WzFdXVxuICAgICMgcmVsYXRpdmUgdG8gaW5pdGlhbCBzY3JvbGwgc3RhdHVzXG5cbiAgICAjIHNjYWxlIGV2ZW50c1xuICAgIHNjYWxlRmFjdG9yID0gQGcuem9vbWVyLmdldCBcImNhbnZhc0V2ZW50U2NhbGVcIlxuICAgIGlmIHJldmVyc2VkXG4gICAgICBzY2FsZUZhY3RvciA9IDNcbiAgICBmb3IgaSBpbiBbMC4uMV0gYnkgMVxuICAgICAgcmVsRW5kW2ldID0gcmVsRW5kW2ldICogc2NhbGVGYWN0b3JcblxuICAgICMgY2FsY3VsYXRlIG5ldyBzY3JvbGxpbmcgdmFsc1xuICAgIHJlbERpc3QgPSBbQGRyYWdTdGFydFNjcm9sbFswXSAtIHJlbEVuZFswXSwgQGRyYWdTdGFydFNjcm9sbFsxXSAtIHJlbEVuZFsxXV1cblxuICAgICMgcm91bmQgdmFsdWVzXG4gICAgZm9yIGkgaW4gWzAuLjFdIGJ5IDFcbiAgICAgIHJlbERpc3RbaV0gPSBNYXRoLnJvdW5kIHJlbERpc3RbaV1cblxuICAgICMgdXBkYXRlIHNjcm9sbGJhclxuICAgIHNjcm9sbENvcnJlY3RlZCA9IEBfY2hlY2tTY3JvbGxpbmcoIHJlbERpc3QpXG4gICAgQGcuem9vbWVyLl9jaGVja1Njcm9sbGluZyBzY3JvbGxDb3JyZWN0ZWQsIHtvcmlnaW46IFwiY2FudmFzc2VxXCJ9XG5cbiAgICAjIHJlc2V0IHN0YXJ0IGlmIHVzZSBzY3JvbGxzIG91dCBvZiBib3VuZHNcbiAgICBmb3IgaSBpbiBbMC4uMV0gYnkgMVxuICAgICAgaWYgc2Nyb2xsQ29ycmVjdGVkW2ldIGlzbnQgcmVsRGlzdFtpXVxuICAgICAgICBpZiBzY3JvbGxDb3JyZWN0ZWRbaV0gaXMgMFxuICAgICAgICAgICMgcmVzZXQgb2YgbGVmdCwgdG9wXG4gICAgICAgICAgQGRyYWdTdGFydFtpXSA9IGRyYWdFbmRbaV1cbiAgICAgICAgICBAZHJhZ1N0YXJ0U2Nyb2xsW2ldID0gMFxuICAgICAgICBlbHNlXG4gICAgICAgICAgIyByZWNhbGlicmF0ZSBvbiByaWdodCwgYm90dG9tXG4gICAgICAgICAgQGRyYWdTdGFydFtpXSA9IGRyYWdFbmRbaV0gLSBzY3JvbGxDb3JyZWN0ZWRbaV1cblxuICAgIEB0aHJvdHRsZWREcmF3KClcblxuICAgICMgYWJvcnQgc2VsZWN0aW9uIGV2ZW50cyBvZiB0aGUgYnJvd3NlciAobW91c2Ugb25seSlcbiAgICBpZiBlLnByZXZlbnREZWZhdWx0P1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgIyBjb252ZXJ0cyB0b3VjaGVzIGludG8gb2xkIG1vdXNlIGV2ZW50XG4gIF9vbnRvdWNobW92ZTogKGUpIC0+XG4gICAgQF9vbm1vdXNlbW92ZSBlLmNoYW5nZWRUb3VjaGVzWzBdLCB0cnVlXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICMgc3RhcnQgdGhlIGRyYWdnaW5nIG1vZGVcbiAgX29ubW91c2Vkb3duOiAoZSkgLT5cbiAgICBAZHJhZ1N0YXJ0ID0gbW91c2UuYWJzIGVcbiAgICBAZHJhZ1N0YXJ0U2Nyb2xsID0gW0BnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxMZWZ0JyksIEBnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxUb3AnKV1cbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAnbW91c2Vtb3ZlLm92ZXJtb3ZlJywgKGUpID0+IEBfb25tb3VzZW1vdmUoZSlcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAnbW91c2V1cC5vdmVydXAnLCA9PiBAX2NsZWFudXAoKVxuICAgICNqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAnbW91c2VvdXQub3Zlcm91dCcsIChlKSA9PiBAX29ubW91c2V3aW5vdXQoZSlcbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAjIHN0YXJ0cyB0aGUgdG91Y2ggbW9kZVxuICBfb250b3VjaHN0YXJ0OiAoZSkgLT5cbiAgICBAZHJhZ1N0YXJ0ID0gbW91c2UuYWJzIGUuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICBAZHJhZ1N0YXJ0U2Nyb2xsID0gW0BnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxMZWZ0JyksIEBnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxUb3AnKV1cbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vbiAndG91Y2htb3ZlLm92ZXJ0bW92ZScsIChlKSA9PiBAX29udG91Y2htb3ZlKGUpXG4gICAgamJvbmUoZG9jdW1lbnQuYm9keSkub24gJ3RvdWNoZW5kLm92ZXJ0ZW5kIHRvdWNobGVhdmUub3ZlcnRsZWF2ZVxuICAgIHRvdWNoY2FuY2VsLm92ZXJ0Y2FuZWwnLCAoZSkgPT4gQF90b3VjaENsZWFudXAoZSlcblxuICAjIGNoZWNrcyB3aGV0aGVyIG1vdXNlIG1vdmVkIG91dCBvZiB0aGUgd2luZG93XG4gICMgLT4gdGVybWluYXRlIGRyYWdnaW5nXG4gIF9vbm1vdXNld2lub3V0OiAoZSkgLT5cbiAgICBpZiBlLnRvRWxlbWVudCBpcyBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGVcbiAgICAgIEBfY2xlYW51cCgpXG5cbiAgIyB0ZXJtaW5hdGVzIGRyYWdnaW5nXG4gIF9jbGVhbnVwOiAtPlxuICAgIEBkcmFnU3RhcnQgPSBbXVxuICAgICMgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vZmYoJy5vdmVybW92ZScpXG4gICAgamJvbmUoZG9jdW1lbnQuYm9keSkub2ZmKCcub3ZlcnVwJylcbiAgICBqYm9uZShkb2N1bWVudC5ib2R5KS5vZmYoJy5vdmVyb3V0JylcblxuICAjIHRlcm1pbmF0ZXMgdG91Y2hpbmdcbiAgX3RvdWNoQ2xlYW51cDogKGUpIC0+XG4gICAgaWYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwXG4gICAgICAjIG1heWJlIHdlIGNhbiBzZW5kIGEgZmluYWwgZXZlbnRcbiAgICAgIEBfb25tb3VzZW1vdmUgZS5jaGFuZ2VkVG91Y2hlc1swXSwgdHJ1ZVxuXG4gICAgQGRyYWdTdGFydCA9IFtdXG4gICAgIyByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgIGpib25lKGRvY3VtZW50LmJvZHkpLm9mZignLm92ZXJ0bW92ZScpXG4gICAgamJvbmUoZG9jdW1lbnQuYm9keSkub2ZmKCcub3ZlcnRlbmQnKVxuICAgIGpib25lKGRvY3VtZW50LmJvZHkpLm9mZignLm92ZXJ0bGVhdmUnKVxuICAgIGpib25lKGRvY3VtZW50LmJvZHkpLm9mZignLm92ZXJ0Y2FuY2VsJylcblxuICAjIG1pZ2h0IGJlIGluY29tcGF0aWJsZSB3aXRoIHNvbWUgYnJvd3NlcnNcbiAgX29ubW91c2V3aGVlbDogKGUpIC0+XG4gICAgZGVsdGEgPSBtb3VzZS53aGVlbERlbHRhIGVcbiAgICBAZy56b29tZXIuc2V0ICdfYWxpZ25tZW50U2Nyb2xsTGVmdCcsIEBnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxMZWZ0JykgKyBkZWx0YVswXVxuICAgIEBnLnpvb21lci5zZXQgJ19hbGlnbm1lbnRTY3JvbGxUb3AnLCBAZy56b29tZXIuZ2V0KCdfYWxpZ25tZW50U2Nyb2xsVG9wJykgKyBkZWx0YVsxXVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gIF9vbmNsaWNrOiAoZSkgLT5cbiAgICByZXMgPSBAX2dldENsaWNrUG9zKGUpXG4gICAgaWYgcmVzP1xuICAgICAgaWYgcmVzLmZlYXR1cmU/XG4gICAgICAgIEBnLnRyaWdnZXIgXCJmZWF0dXJlOmNsaWNrXCIsIHJlc1xuICAgICAgZWxzZVxuICAgICAgICBAZy50cmlnZ2VyIFwicmVzaWR1ZTpjbGlja1wiLCByZXNcbiAgICBAdGhyb3R0bGVkRHJhdygpXG5cbiAgX29ubW91c2VpbjogKGUpIC0+XG4gICAgcmVzID0gQF9nZXRDbGlja1BvcyhlKVxuICAgIGlmIHJlcz9cbiAgICAgIGlmIHJlcy5mZWF0dXJlP1xuICAgICAgICBAZy50cmlnZ2VyIFwiZmVhdHVyZTptb3VzZWluXCIsIHJlc1xuICAgICAgZWxzZVxuICAgICAgICBAZy50cmlnZ2VyIFwicmVzaWR1ZTptb3VzZWluXCIsIHJlc1xuICAgIEB0aHJvdHRsZWREcmF3KClcblxuICBfb25tb3VzZW91dDogKGUpIC0+XG4gICAgcmVzID0gQF9nZXRDbGlja1BvcyhlKVxuICAgIGlmIHJlcz9cbiAgICAgIGlmIHJlcy5mZWF0dXJlP1xuICAgICAgICBAZy50cmlnZ2VyIFwiZmVhdHVyZTptb3VzZW91dFwiLCByZXNcbiAgICAgIGVsc2VcbiAgICAgICAgQGcudHJpZ2dlciBcInJlc2lkdWU6bW91c2VvdXRcIiwgcmVzXG5cbiAgICBAdGhyb3R0bGVkRHJhdygpXG5cbiAgX2dldENsaWNrUG9zOiAoZSkgLT5cbiAgICBjb29yZHMgPSBtb3VzZS5yZWwgZVxuXG4gICAgY29vcmRzWzBdICs9IEBnLnpvb21lci5nZXQoXCJfYWxpZ25tZW50U2Nyb2xsTGVmdFwiKVxuICAgIHggPSBNYXRoLmZsb29yKGNvb3Jkc1swXSAvIEBnLnpvb21lci5nZXQoXCJjb2x1bW5XaWR0aFwiKSApXG4gICAgW3kscm93TnVtYmVyXSA9IEBzZXFEcmF3ZXIuX2dldFNlcUZvcllDbGljayhjb29yZHNbMV0pXG5cbiAgICAjIGFkZCBoaWRkZW4gY29sdW1uc1xuICAgIHggKz0gQGcuY29sdW1ucy5jYWxjSGlkZGVuQ29sdW1ucyB4XG4gICAgIyBhZGQgaGlkZGVuIHNlcXNcbiAgICB5ICs9IEBtb2RlbC5jYWxjSGlkZGVuU2VxcyB5XG5cbiAgICB4ID0gTWF0aC5tYXggMCx4XG4gICAgeSA9IE1hdGgubWF4IDAseVxuXG4gICAgc2VxSWQgPSBAbW9kZWwuYXQoeSkuZ2V0IFwiaWRcIlxuXG4gICAgaWYgcm93TnVtYmVyID4gMFxuICAgICAgIyBjbGljayBvbiBhIGZlYXR1cmVcbiAgICAgIGZlYXR1cmVzID0gQG1vZGVsLmF0KHkpLmdldChcImZlYXR1cmVzXCIpLmdldEZlYXR1cmVPblJvdyhyb3dOdW1iZXIgLSAxLCB4KVxuICAgICAgdW5sZXNzIGZlYXR1cmVzLmxlbmd0aCBpcyAwXG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlc1swXVxuICAgICAgICBjb25zb2xlLmxvZyBmZWF0dXJlc1swXS5hdHRyaWJ1dGVzXG4gICAgICAgIHJldHVybiB7c2VxSWQ6c2VxSWQsIGZlYXR1cmU6IGZlYXR1cmUsIHJvd1BvczogeCwgZXZ0OmV9XG4gICAgZWxzZVxuICAgICAgIyBjbGljayBvbiBhIHNlcVxuICAgICAgcmV0dXJuIHtzZXFJZDpzZXFJZCwgcm93UG9zOiB4LCBldnQ6ZX1cblxuICAjIGNoZWNrcyB3aGV0aGVyIHRoZSBzY3JvbGxpbmcgY29vcmRpbmF0ZXMgYXJlIHZhbGlkXG4gICMgQHJldHVybnM6IFt4U2Nyb2xsLHlTY3JvbGxdIHZhbGlkIGNvb3JkaW5hdGVzXG4gIF9jaGVja1Njcm9sbGluZzogKHNjcm9sbE9iaikgLT5cblxuICAgICMgMDogbWF4TGVmdCwgMTogbWF4VG9wXG4gICAgbWF4ID0gW0Bjb29yZHNDYWNoZS5tYXhTY3JvbGxXaWR0aCwgQGNvb3Jkc0NhY2hlLm1heFNjcm9sbEhlaWdodF1cblxuICAgIGZvciBpIGluIFswLi4xXSBieSAxXG4gICAgICBpZiBzY3JvbGxPYmpbaV0gPiBtYXhbaV1cbiAgICAgICAgc2Nyb2xsT2JqW2ldID0gbWF4W2ldXG5cbiAgICAgIGlmIHNjcm9sbE9ialtpXSA8IDBcbiAgICAgICAgc2Nyb2xsT2JqW2ldID0gMFxuXG4gICAgcmV0dXJuIHNjcm9sbE9ialxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblxuZHJhd2VyID1cblxuICBkcmF3TGV0dGVyczogLT5cblxuICAgIHJlY3RIZWlnaHQgPSBAcmVjdEhlaWdodFxuXG4gICAgIyByZWN0c1xuICAgIEBjdHguZ2xvYmFsQWxwaGEgPSBAZy5jb2xvcnNjaGVtZS5nZXQgXCJvcGFjaXR5XCJcbiAgICBAZHJhd1NlcXMgKGRhdGEpIC0+IEBkcmF3U2VxKGRhdGEsIEBfZHJhd1JlY3QpXG4gICAgQGN0eC5nbG9iYWxBbHBoYSA9IDFcblxuICAgICMgbGV0dGVyc1xuICAgIEBkcmF3U2VxcyAoZGF0YSkgLT4gQGRyYXdTZXEoZGF0YSwgQF9kcmF3TGV0dGVyKVxuXG4gIGRyYXdTZXFzOiAoY2FsbGJhY2ssIHRhcmdldCkgLT5cbiAgICBoaWRkZW4gPSBAZy5jb2x1bW5zLmdldCBcImhpZGRlblwiXG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgQFxuXG4gICAgW3N0YXJ0LCB5XSA9IEBnZXRTdGFydFNlcSgpXG5cbiAgICBmb3IgaSBpbiBbc3RhcnQuLiBAbW9kZWwubGVuZ3RoIC0gMV0gYnkgMVxuICAgICAgc2VxID0gQG1vZGVsLmF0KGkpXG4gICAgICBjb250aW51ZSBpZiBzZXEuZ2V0KCdoaWRkZW4nKVxuICAgICAgY2FsbGJhY2suY2FsbCB0YXJnZXQsIHttb2RlbDogc2VxLCB5UG9zOiB5LCB5OiBpLCBoaWRkZW46IGhpZGRlbn1cblxuICAgICAgc2VxSGVpZ2h0ID0gKHNlcS5hdHRyaWJ1dGVzLmhlaWdodCB8fCAxKSAqIEByZWN0SGVpZ2h0XG4gICAgICB5ID0geSArIHNlcUhlaWdodFxuXG4gICAgICAjIG91dCBvZiB2aWV3cG9ydCAtIHN0b3BcbiAgICAgIGlmIHkgPiBAaGVpZ2h0XG4gICAgICAgIGJyZWFrXG5cbiAgIyBjYWxscyB0aGUgY2FsbGJhY2sgZm9yIGV2ZXJ5IGRyYXdhYmxlIHJvd1xuICBkcmF3Um93czogKGNhbGxiYWNrLCB0YXJnZXQpIC0+XG4gICAgQGRyYXdTZXFzIChkYXRhKSAtPiBAZHJhd1JvdyhkYXRhLCBjYWxsYmFjaywgdGFyZ2V0KVxuXG4gICMgZHJhd3MgYSBzaW5nbGUgcm93XG4gIGRyYXdSb3c6IChkYXRhLCBjYWxsYmFjaywgdGFyZ2V0KSAtPlxuICAgIHJlY3RXaWR0aCA9IEBnLnpvb21lci5nZXQgXCJjb2x1bW5XaWR0aFwiXG4gICAgc3RhcnQgPSBNYXRoLm1heCAwLCBNYXRoLmFicyhNYXRoLmNlaWwoIC0gQGcuem9vbWVyLmdldCgnX2FsaWdubWVudFNjcm9sbExlZnQnKSAvIHJlY3RXaWR0aCkpXG4gICAgeCA9IC0gTWF0aC5hYnMoIC0gQGcuem9vbWVyLmdldCgnX2FsaWdubWVudFNjcm9sbExlZnQnKSAlIHJlY3RXaWR0aClcblxuICAgIHhaZXJvID0geCAtIHN0YXJ0ICogcmVjdFdpZHRoXG4gICAgeVplcm8gPSBkYXRhLnlQb3NcbiAgICBjYWxsYmFjay5jYWxsIHRhcmdldCwgbW9kZWw6IGRhdGEubW9kZWwsIHhaZXJvOiB4WmVybywgeVplcm86IHlaZXJvLCBoaWRkZW46IGRhdGEuaGlkZGVuXG5cbiAgIyByZXR1cm5zIGZpcnN0IHNlcXVlbmNlIGluIHRoZSB2aWV3cG9ydFxuICAjIHkgaXMgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGRyYXdpbmdcbiAgZ2V0U3RhcnRTZXE6IC0+XG4gICAgc3RhcnQgPSAoTWF0aC5tYXggMCwgTWF0aC5mbG9vciggQGcuem9vbWVyLmdldCgnX2FsaWdubWVudFNjcm9sbFRvcCcpIC8gQHJlY3RIZWlnaHQpKSArIDFcbiAgICBjb3VudGVyID0gMFxuICAgIGkgPSAwXG4gICAgd2hpbGUgY291bnRlciA8IHN0YXJ0IGFuZCBpIDwgQG1vZGVsLmxlbmd0aFxuICAgICAgY291bnRlciArPSBAbW9kZWwuYXQoaSkuYXR0cmlidXRlcy5oZWlnaHQgfHwgMVxuICAgICAgaSsrXG4gICAgeSA9IE1hdGgubWF4KDAsIEBnLnpvb21lci5nZXQoJ19hbGlnbm1lbnRTY3JvbGxUb3AnKSAtIGNvdW50ZXIgKiBAcmVjdEhlaWdodCArIChAbW9kZWwuYXQoaSAtIDEpXG4gICAgLmF0dHJpYnV0ZXMuaGVpZ2h0ICB8fCAxICkgKiBAcmVjdEhlaWdodClcbiAgICBbaSAtIDEsIC15XVxuXG4gICMgcmV0dXJucyBbdGhlIGNsaWNrZWQgc2VxIGZvciBhIHZpZXdwb3J0LCByb3cgbnVtYmVyXVxuICBfZ2V0U2VxRm9yWUNsaWNrOiAoY2xpY2spIC0+XG4gICAgW3N0YXJ0LCB5RGlmZl0gPSBAZ2V0U3RhcnRTZXEoKVxuICAgIHlSZWwgPSB5RGlmZiAlIEByZWN0SGVpZ2h0XG4gICAgY2xpY2tlZFJvd3MgPSAoTWF0aC5tYXggMCwgTWF0aC5mbG9vciggKGNsaWNrIC0geVJlbCApIC8gQHJlY3RIZWlnaHQpKSArIDFcbiAgICBjb3VudGVyID0gMFxuICAgIGkgPSBzdGFydFxuICAgIHdoaWxlIGNvdW50ZXIgPCBjbGlja2VkUm93cyBhbmQgaSA8IEBtb2RlbC5sZW5ndGhcbiAgICAgIGNvdW50ZXIgKz0gQG1vZGVsLmF0KGkpLmF0dHJpYnV0ZXMuaGVpZ2h0IHx8IDFcbiAgICAgIGkrK1xuICAgIHJvd051bWJlciA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoY2xpY2sgLyBAcmVjdEhlaWdodCkgLSBjb3VudGVyICsgKEBtb2RlbC5hdChpIC0gMSkuZ2V0KFwiaGVpZ2h0XCIpIHx8IDEpKVxuICAgIHJldHVybiBbaSAtIDEsIHJvd051bWJlcl1cblxuICAjIFRPRE86IHZlcnkgZXhwZW5zaXZlIG1ldGhvZFxuICBkcmF3U2VxOiAoZGF0YSwgY2FsbGJhY2spIC0+XG4gICAgc2VxID0gZGF0YS5tb2RlbC5nZXQgXCJzZXFcIlxuICAgIHkgPSBkYXRhLnlQb3NcbiAgICByZWN0V2lkdGggPSBAcmVjdFdpZHRoXG4gICAgcmVjdEhlaWdodCA9IEByZWN0SGVpZ2h0XG5cbiAgICAjIHNraXAgdW5uZWVkZWQgYmxvY2tzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICBzdGFydCA9IE1hdGgubWF4IDAsIE1hdGguYWJzKE1hdGguY2VpbCggLSBAZy56b29tZXIuZ2V0KCdfYWxpZ25tZW50U2Nyb2xsTGVmdCcpIC8gcmVjdFdpZHRoKSlcbiAgICB4ID0gLSBNYXRoLmFicyggLSBAZy56b29tZXIuZ2V0KCdfYWxpZ25tZW50U2Nyb2xsTGVmdCcpICUgcmVjdFdpZHRoKVxuXG4gICAgcmVzID0ge3JlY3RXaWR0aDogcmVjdFdpZHRoLCByZWN0SGVpZ2h0OiByZWN0SGVpZ2h0LCB5UG9zOiB5LCB5OiBkYXRhLnl9XG4gICAgZWxXaWR0aCA9IEB3aWR0aFxuXG4gICAgZm9yIGogaW4gW3N0YXJ0Li4gc2VxLmxlbmd0aCAtIDFdIGJ5IDFcbiAgICAgIGMgPSBzZXFbal1cbiAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKClcblxuICAgICAgIyBjYWxsIHRoZSBjdXN0b20gZnVuY3Rpb25cbiAgICAgIHJlcy54ID0galxuICAgICAgcmVzLmMgPSBjXG4gICAgICByZXMueFBvcyA9IHhcblxuICAgICAgIyBsb2NhbCBjYWxsIGlzIGZhc3RlciB0aGFuIGFwcGx5XG4gICAgICAjIGh0dHA6Ly9qc3BlcmYuY29tL2Z1bmN0aW9uLWNhbGxzLWRpcmVjdC12cy1hcHBseS12cy1jYWxsLXZzLWJpbmQvNlxuICAgICAgaWYgZGF0YS5oaWRkZW4uaW5kZXhPZihqKSA8IDBcbiAgICAgICAgY2FsbGJhY2sgQCxyZXNcbiAgICAgIGVsc2VcbiAgICAgICAgY29udGludWVcblxuICAgICAgIyBtb3ZlIHRvIHRoZSByaWdodFxuICAgICAgeCA9IHggKyByZWN0V2lkdGhcblxuICAgICAgIyBvdXQgb2Ygdmlld3BvcnQgLSBzdG9wXG4gICAgICBpZiB4ID4gZWxXaWR0aFxuICAgICAgICBicmVha1xuXG4gIF9kcmF3UmVjdDogKHRoYXQsIGRhdGEpIC0+XG4gICAgY29sb3IgPSB0aGF0LmNvbG9yLmdldENvbG9yIGRhdGEuYyxcbiAgICAgIHBvczpkYXRhLnhcbiAgICAgIHk6IGRhdGEueVxuICAgIGlmIGNvbG9yP1xuICAgICAgdGhhdC5jdHguZmlsbFN0eWxlID0gY29sb3JcbiAgICAgIHRoYXQuY3R4LmZpbGxSZWN0IGRhdGEueFBvcyxkYXRhLnlQb3MsZGF0YS5yZWN0V2lkdGgsZGF0YS5yZWN0SGVpZ2h0XG5cbiAgIyBSRUFMTFkgZXhwZW5zaXZlIGNhbGwgb24gRkZcbiAgIyBQZXJmb3JtYW5jZTpcbiAgIyBjaHJvbWU6IDIwMDBtcyBkcmF3TGV0dGVyIC0gMTAwMG1zIGRyYXdSZWN0XG4gICMgRkY6IDE3MDBtcyBkcmF3TGV0dGVyIC0gMzAwbXMgZHJhd1JlY3RcbiAgX2RyYXdMZXR0ZXI6ICh0aGF0LGRhdGEpIC0+XG4gICAgdGhhdC5jdHguZHJhd0ltYWdlIHRoYXQuY2FjaGUuZ2V0Rm9udFRpbGUoZGF0YS5jLCBkYXRhLnJlY3RXaWR0aCxcbiAgICAgIGRhdGEucmVjdEhlaWdodCksIGRhdGEueFBvcywgZGF0YS55UG9zLGRhdGEucmVjdFdpZHRoLGRhdGEucmVjdEhlaWdodFxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RydWMgPSAoZyxjdHgsbW9kZWwsb3B0cykgLT5cbiAgdGhpcy5nID0gZ1xuICB0aGlzLmN0eCA9IGN0eFxuICB0aGlzLm1vZGVsID0gbW9kZWxcbiAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGhcbiAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxuICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxuICB0aGlzLmNhY2hlID0gb3B0cy5jYWNoZVxuICB0aGlzLnJlY3RIZWlnaHQgPSBAZy56b29tZXIuZ2V0IFwicm93SGVpZ2h0XCJcbiAgdGhpcy5yZWN0V2lkdGggPSBAZy56b29tZXIuZ2V0IFwiY29sdW1uV2lkdGhcIlxuICBAXG5cbl8uZXh0ZW5kIGNvbnN0cnVjOjosIGRyYXdlclxuIiwidmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS12aWV3alwiKVxuZG9tID0gcmVxdWlyZShcImRvbS1oZWxwZXJcIilcbnN2ZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdmdcIilcblxuQ29uc2VydmF0aW9uVmlldyA9IHZpZXcuZXh0ZW5kXG5cbiAgY2xhc3NOYW1lOiBcImJpb2pzX21zYV9jb25zZXJ2XCJcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsXCJjaGFuZ2U6c3RlcFNpemUgY2hhbmdlOmxhYmVsV2lkdGggY2hhbmdlOmNvbHVtbldpZHRoXCIsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcudmlzLFwiY2hhbmdlOmxhYmVscyBjaGFuZ2U6bWV0YWNlbGxcIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy5jb2x1bW5zLCBcImNoYW5nZTpzY2FsaW5nXCIsIEByZW5kZXJcbiAgICAjIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBzdGF0cyBnaXZlcyB1cyB0aGUgb2tcbiAgICAjQGxpc3RlblRvIEBtb2RlbCwgXCJyZXNldFwiLEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcuc3RhdHMsXCJyZXNldFwiLCBAcmVuZGVyXG4gICAgQG1hbmFnZUV2ZW50cygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIGNvbnNlcnYgPSBAZy5zdGF0cy5zY2FsZShAZy5zdGF0cy5jb25zZXJ2YXRpb24oKSlcblxuICAgIGRvbS5yZW1vdmVBbGxDaGlsZHMgQGVsXG5cbiAgICBuTWF4ID0gQG1vZGVsLmdldE1heExlbmd0aCgpXG4gICAgY2VsbFdpZHRoID0gQGcuem9vbWVyLmdldCBcImNvbHVtbldpZHRoXCJcbiAgICBtYXhIZWlnaHQgPSAyMFxuICAgIHdpZHRoID0gY2VsbFdpZHRoICogKG5NYXggLSBAZy5jb2x1bW5zLmdldCgnaGlkZGVuJykubGVuZ3RoKVxuXG4gICAgcyA9IHN2Zy5iYXNlIGhlaWdodDogbWF4SGVpZ2h0LCB3aWR0aDogd2lkdGhcbiAgICBzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgcy5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIlxuXG4gICAgc3RlcFNpemUgPSBAZy56b29tZXIuZ2V0IFwic3RlcFNpemVcIlxuICAgIGhpZGRlbiA9IEBnLmNvbHVtbnMuZ2V0IFwiaGlkZGVuXCJcbiAgICB4ID0gMFxuICAgIG4gPSAwXG4gICAgd2hpbGUgbiA8IG5NYXhcbiAgICAgIGlmIGhpZGRlbi5pbmRleE9mKG4pID49IDBcbiAgICAgICAgbiArPSBzdGVwU2l6ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgd2lkdGggPSBjZWxsV2lkdGggKiBzdGVwU2l6ZVxuICAgICAgYXZnSGVpZ2h0ID0gMFxuICAgICAgZm9yIGkgaW4gWzAgLi4gc3RlcFNpemUgLSAxXVxuICAgICAgICBhdmdIZWlnaHQgKz0gY29uc2VydltuXVxuICAgICAgaGVpZ2h0ID0gbWF4SGVpZ2h0ICogIChhdmdIZWlnaHQgLyBzdGVwU2l6ZSlcblxuICAgICAgcmVjdCA9ICBzdmcucmVjdCB4OngseTogbWF4SGVpZ2h0IC0gaGVpZ2h0LHdpZHRoOndpZHRoIC0gY2VsbFdpZHRoIC8gNCxoZWlnaHQ6aGVpZ2h0LHN0eWxlOlxuICAgICAgICBcInN0cm9rZTpyZWQ7c3Ryb2tlLXdpZHRoOjE7XCJcbiAgICAgIHJlY3Qucm93UG9zID0gblxuICAgICAgcy5hcHBlbmRDaGlsZCByZWN0XG4gICAgICB4ICs9IHdpZHRoXG4gICAgICBuICs9IHN0ZXBTaXplXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgc1xuICAgIEBcblxuICAjVE9ETzogbWFrZSBtb3JlIGdlbmVyYWwgd2l0aCBIZWFkZXJWaWV3XG4gIF9vbmNsaWNrOiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IGV2dC50YXJnZXQucm93UG9zXG4gICAgc3RlcFNpemUgPSBAZy56b29tZXIuZ2V0KFwic3RlcFNpemVcIilcbiAgICAjIHNpbXVsYXRlIGhpZGRlbiBjb2x1bW5zXG4gICAgZm9yIGkgaW4gWzAuLnN0ZXBTaXplIC0gMV0gYnkgMVxuICAgICAgQGcudHJpZ2dlciBcImJhcjpjbGlja1wiLCB7cm93UG9zOiByb3dQb3MgKyBpLCBldnQ6ZXZ0fVxuXG4gIG1hbmFnZUV2ZW50czogLT5cbiAgICBldmVudHMgPSB7fVxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlQ2xpY2tzXCJcbiAgICAgIGV2ZW50cy5jbGljayA9IFwiX29uY2xpY2tcIlxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlSG92ZXJcIlxuICAgICAgZXZlbnRzLm1vdXNlaW4gPSBcIl9vbm1vdXNlaW5cIlxuICAgICAgZXZlbnRzLm1vdXNlb3V0ID0gXCJfb25tb3VzZW91dFwiXG4gICAgQGRlbGVnYXRlRXZlbnRzIGV2ZW50c1xuICAgIEBsaXN0ZW5UbyBAZy5jb25maWcsIFwiY2hhbmdlOnJlZ2lzdGVyTW91c2VIb3ZlclwiLCBAbWFuYWdlRXZlbnRzXG4gICAgQGxpc3RlblRvIEBnLmNvbmZpZywgXCJjaGFuZ2U6cmVnaXN0ZXJNb3VzZUNsaWNrXCIsIEBtYW5hZ2VFdmVudHNcblxuICBfb25tb3VzZWluOiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IEBnLnpvb21lci5nZXQgXCJzdGVwU2l6ZVwiICogZXZ0LnJvd1Bvc1xuICAgIEBnLnRyaWdnZXIgXCJiYXI6bW91c2VpblwiLCB7cm93UG9zOiByb3dQb3MsIGV2dDpldnR9XG5cbiAgX29ubW91c2VvdXQ6IChldnQpIC0+XG4gICAgcm93UG9zID0gQGcuem9vbWVyLmdldCBcInN0ZXBTaXplXCIgKiBldnQucm93UG9zXG4gICAgQGcudHJpZ2dlciBcImJhcjptb3VzZW91dFwiLCB7cm93UG9zOiByb3dQb3MsIGV2dDpldnR9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uc2VydmF0aW9uVmlld1xuIiwidmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS12aWV3alwiKVxuZG9tID0gcmVxdWlyZShcImRvbS1oZWxwZXJcIilcbnN2ZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdmdcIilcblxuIyBUT0RPOiBtZXJnZSB0aGlzIHdpdGggdGhlIGNvbnNlcnZhdGlvbiB2aWV3XG5Db25zZXJ2YXRpb25WaWV3ID0gdmlldy5leHRlbmRcblxuICBjbGFzc05hbWU6IFwiYmlvanNfbXNhX2dhcHZpZXdcIlxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGxpc3RlblRvIEBnLnpvb21lcixcImNoYW5nZTpzdGVwU2l6ZSBjaGFuZ2U6bGFiZWxXaWR0aCBjaGFuZ2U6Y29sdW1uV2lkdGhcIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy52aXMsXCJjaGFuZ2U6bGFiZWxzIGNoYW5nZTptZXRhY2VsbFwiLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEBnLmNvbHVtbnMsIFwiY2hhbmdlOnNjYWxpbmdcIiwgQHJlbmRlclxuICAgICMgd2UgbmVlZCB0byB3YWl0IHVudGlsIHN0YXRzIGdpdmVzIHVzIHRoZSBva1xuICAgIEBsaXN0ZW5UbyBAbW9kZWwsIFwicmVzZXRcIixAcmVuZGVyXG4gICAgQG1hbmFnZUV2ZW50cygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIGdhcHMgPSBAZy5zdGF0cy5nYXBzKClcblxuICAgIGRvbS5yZW1vdmVBbGxDaGlsZHMgQGVsXG5cbiAgICBuTWF4ID0gQG1vZGVsLmdldE1heExlbmd0aCgpXG4gICAgY2VsbFdpZHRoID0gQGcuem9vbWVyLmdldCBcImNvbHVtbldpZHRoXCJcbiAgICBtYXhIZWlnaHQgPSAyMFxuICAgIHdpZHRoID0gY2VsbFdpZHRoICogKG5NYXggLSBAZy5jb2x1bW5zLmdldCgnaGlkZGVuJykubGVuZ3RoKVxuXG4gICAgcyA9IHN2Zy5iYXNlIGhlaWdodDogbWF4SGVpZ2h0LCB3aWR0aDogd2lkdGhcbiAgICBzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgcy5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIlxuXG4gICAgc3RlcFNpemUgPSBAZy56b29tZXIuZ2V0IFwic3RlcFNpemVcIlxuICAgIGhpZGRlbiA9IEBnLmNvbHVtbnMuZ2V0IFwiaGlkZGVuXCJcbiAgICB4ID0gMFxuICAgIG4gPSAwXG4gICAgd2hpbGUgbiA8IG5NYXhcbiAgICAgIGlmIGhpZGRlbi5pbmRleE9mKG4pID49IDBcbiAgICAgICAgbiArPSBzdGVwU2l6ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgd2lkdGggPSBjZWxsV2lkdGggKiBzdGVwU2l6ZVxuICAgICAgYXZnSGVpZ2h0ID0gMFxuICAgICAgZm9yIGkgaW4gWzAgLi4gc3RlcFNpemUgLSAxXVxuICAgICAgICBhdmdIZWlnaHQgKz0gZ2Fwc1tuXVxuICAgICAgaGVpZ2h0ID0gbWF4SGVpZ2h0ICogIChhdmdIZWlnaHQgLyBzdGVwU2l6ZSlcblxuICAgICAgcmVjdCA9ICBzdmcucmVjdCB4OngseTogbWF4SGVpZ2h0IC0gaGVpZ2h0LHdpZHRoOndpZHRoIC0gY2VsbFdpZHRoIC8gNCxoZWlnaHQ6aGVpZ2h0LHN0eWxlOlxuICAgICAgICBcInN0cm9rZTpyZWQ7c3Ryb2tlLXdpZHRoOjE7XCJcbiAgICAgIHJlY3Qucm93UG9zID0gblxuICAgICAgcy5hcHBlbmRDaGlsZCByZWN0XG4gICAgICB4ICs9IHdpZHRoXG4gICAgICBuICs9IHN0ZXBTaXplXG5cbiAgICBAZWwuYXBwZW5kQ2hpbGQgc1xuICAgIEBcblxuICAjVE9ETzogbWFrZSBtb3JlIGdlbmVyYWwgd2l0aCBIZWFkZXJWaWV3XG4gIF9vbmNsaWNrOiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IGV2dC50YXJnZXQucm93UG9zXG4gICAgc3RlcFNpemUgPSBAZy56b29tZXIuZ2V0KFwic3RlcFNpemVcIilcbiAgICAjIHNpbXVsYXRlIGhpZGRlbiBjb2x1bW5zXG4gICAgZm9yIGkgaW4gWzAuLnN0ZXBTaXplIC0gMV0gYnkgMVxuICAgICAgQGcudHJpZ2dlciBcImdhcDpjbGlja1wiLCB7cm93UG9zOiByb3dQb3MgKyBpLCBldnQ6ZXZ0fVxuXG4gIG1hbmFnZUV2ZW50czogLT5cbiAgICBldmVudHMgPSB7fVxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlQ2xpY2tzXCJcbiAgICAgIGV2ZW50cy5jbGljayA9IFwiX29uY2xpY2tcIlxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlSG92ZXJcIlxuICAgICAgZXZlbnRzLm1vdXNlaW4gPSBcIl9vbm1vdXNlaW5cIlxuICAgICAgZXZlbnRzLm1vdXNlb3V0ID0gXCJfb25tb3VzZW91dFwiXG4gICAgQGRlbGVnYXRlRXZlbnRzIGV2ZW50c1xuICAgIEBsaXN0ZW5UbyBAZy5jb25maWcsIFwiY2hhbmdlOnJlZ2lzdGVyTW91c2VIb3ZlclwiLCBAbWFuYWdlRXZlbnRzXG4gICAgQGxpc3RlblRvIEBnLmNvbmZpZywgXCJjaGFuZ2U6cmVnaXN0ZXJNb3VzZUNsaWNrXCIsIEBtYW5hZ2VFdmVudHNcblxuICBfb25tb3VzZWluOiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IEBnLnpvb21lci5nZXQgXCJzdGVwU2l6ZVwiICogZXZ0LnJvd1Bvc1xuICAgIEBnLnRyaWdnZXIgXCJnYXA6bW91c2VpblwiLCB7cm93UG9zOiByb3dQb3MsIGV2dDpldnR9XG5cbiAgX29ubW91c2VvdXQ6IChldnQpIC0+XG4gICAgcm93UG9zID0gQGcuem9vbWVyLmdldCBcInN0ZXBTaXplXCIgKiBldnQucm93UG9zXG4gICAgQGcudHJpZ2dlciBcImdhcDptb3VzZW91dFwiLCB7cm93UG9zOiByb3dQb3MsIGV2dDpldnR9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uc2VydmF0aW9uVmlld1xuIiwiYm9uZVZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtY2hpbGRzXCIpXG5MYWJlbEhlYWRlciA9IHJlcXVpcmUgXCIuL0xhYmVsSGVhZGVyXCJcblJpZ2h0TGFiZWxIZWFkZXIgPSByZXF1aXJlIFwiLi9SaWdodEhlYWRlckJsb2NrXCJcblxubW9kdWxlLmV4cG9ydHMgPSBib25lVmlldy5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBkcmF3KClcbiAgICBAbGlzdGVuVG8gQGcudmlzLFwiY2hhbmdlOmxhYmVscyBjaGFuZ2U6bWV0YWNlbGwgY2hhbmdlOmxlZnRIZWFkZXJcIiwgPT5cbiAgICAgIEBkcmF3KClcbiAgICAgIEByZW5kZXIoKVxuXG4gIGRyYXc6IC0+XG4gICAgQHJlbW92ZVZpZXdzKClcblxuICAgIGlmIEBnLnZpcy5nZXQoXCJsZWZ0SGVhZGVyXCIpIGFuZCAoQGcudmlzLmdldChcImxhYmVsc1wiKSBvciBAZy52aXMuZ2V0KFwibWV0YWNlbGxcIikpXG4gICAgICBsSGVhZGVyID0gbmV3IExhYmVsSGVhZGVyIHttb2RlbDogQG1vZGVsLCBnOiBAZ31cbiAgICAgIGxIZWFkZXIub3JkZXJpbmcgPSAtNTBcbiAgICAgIEBhZGRWaWV3IFwibEhlYWRlclwiLCBsSGVhZGVyXG5cbiAgICBySGVhZGVyID0gbmV3IFJpZ2h0TGFiZWxIZWFkZXIge21vZGVsOiBAbW9kZWwsIGc6IEBnfVxuICAgIHJIZWFkZXIub3JkZXJpbmcgPSAwXG4gICAgQGFkZFZpZXcgXCJySGVhZGVyXCIsIHJIZWFkZXJcblxuICByZW5kZXI6IC0+XG4gICAgQHJlbmRlclN1YnZpZXdzKClcblxuICAgIEBlbC5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9oZWFkZXJcIlxuIiwiayA9IHJlcXVpcmUgXCJrb2FsYS1qc1wiXG52aWV3ID0gcmVxdWlyZShcImJhY2tib25lLXZpZXdqXCIpXG5kb20gPSByZXF1aXJlKFwiZG9tLWhlbHBlclwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhYmVsSGVhZGVyID0gdmlldy5leHRlbmRcblxuICBjbGFzc05hbWU6IFwiYmlvanNfbXNhX2hlYWRlcnNcIlxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG5cbiAgICBAbGlzdGVuVG8gQGcudmlzLCBcImNoYW5nZTptZXRhY2VsbCBjaGFuZ2U6bGFiZWxzXCIsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpsYWJlbFdpZHRoIGNoYW5nZTptZXRhV2lkdGhcIiwgQHJlbmRlclxuXG4gIHJlbmRlcjogLT5cblxuICAgIGRvbS5yZW1vdmVBbGxDaGlsZHMgQGVsXG5cbiAgICB3aWR0aCA9IDBcbiAgICB3aWR0aCArPSBAZy56b29tZXIuZ2V0TGVmdEJsb2NrV2lkdGgoKVxuICAgIEBlbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiXG5cbiAgICBpZiBAZy52aXMuZ2V0IFwibGFiZWxzXCJcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBAbGFiZWxET00oKVxuXG4gICAgaWYgQGcudmlzLmdldCBcIm1ldGFjZWxsXCJcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBAbWV0YURPTSgpXG5cbiAgICBAZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICBAZWwuc3R5bGUuZm9udFNpemUgPSBAZy56b29tZXIuZ2V0IFwibWFya2VyRm9udHNpemVcIlxuICAgIEBcblxuICBsYWJlbERPTTogLT5cbiAgICBsYWJlbEhlYWRlciA9IGsubWsgXCJkaXZcIlxuICAgIGxhYmVsSGVhZGVyLnN0eWxlLndpZHRoID0gQGcuem9vbWVyLmdldExhYmVsV2lkdGgoKVxuICAgIGxhYmVsSGVhZGVyLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG5cbiAgICBpZiBALmcudmlzLmdldCBcImxhYmVsQ2hlY2tib3hcIlxuICAgICAgbGFiZWxIZWFkZXIuYXBwZW5kQ2hpbGQgQGFkZEVsKFwiLlwiLCAxMClcblxuICAgIGlmIEAuZy52aXMuZ2V0IFwibGFiZWxJZFwiXG4gICAgICBsYWJlbEhlYWRlci5hcHBlbmRDaGlsZCBAYWRkRWwoXCJpZFwiLCBAZy56b29tZXIuZ2V0IFwibGFiZWxJZExlbmd0aFwiKVxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJsYWJlbFBhcnRpdGlvblwiXG4gICAgICBsYWJlbEhlYWRlci5hcHBlbmRDaGlsZCBAYWRkRWwoXCJwYXJ0XCIsIDE1KVxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJsYWJlbE5hbWVcIlxuICAgICAgbmFtZSA9IEBhZGRFbChcIm5hbWVcIilcbiAgICAgICNuYW1lLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjUwcHhcIlxuICAgICAgbGFiZWxIZWFkZXIuYXBwZW5kQ2hpbGQgbmFtZVxuXG4gICAgbGFiZWxIZWFkZXJcblxuICBhZGRFbDogKGNvbnRlbnQsIHdpZHRoKSAtPlxuICAgIGlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcInNwYW5cIlxuICAgIGlkLnRleHRDb250ZW50ID0gY29udGVudFxuICAgIGlmIHdpZHRoP1xuICAgICAgaWQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIlxuICAgIGlkLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgaWRcblxuICBtZXRhRE9NOiAtPlxuICAgIG1ldGFIZWFkZXIgPSBrLm1rIFwiZGl2XCJcbiAgICBtZXRhSGVhZGVyLnN0eWxlLndpZHRoID0gQGcuem9vbWVyLmdldE1ldGFXaWR0aCgpXG4gICAgbWV0YUhlYWRlci5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJtZXRhR2Fwc1wiXG4gICAgICBtZXRhSGVhZGVyLmFwcGVuZENoaWxkIEBhZGRFbChcImdhcHNcIiwgQGcuem9vbWVyLmdldCgnbWV0YUdhcFdpZHRoJykpXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJtZXRhSWRlbnRpdHlcIlxuICAgICAgbWV0YUhlYWRlci5hcHBlbmRDaGlsZCBAYWRkRWwoXCJpZGVudFwiLCBAZy56b29tZXIuZ2V0KCdtZXRhSWRlbnRXaWR0aCcpKVxuICAgIGlmIEAuZy52aXMuZ2V0IFwibWV0YUxpbmtzXCJcbiAgICAgIG1ldGFIZWFkZXIuYXBwZW5kQ2hpbGQgQGFkZEVsKFwibGlua3NcIilcblxuICAgIG1ldGFIZWFkZXJcbiIsInZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtdmlld2pcIilcbmRvbSA9IHJlcXVpcmUoXCJkb20taGVscGVyXCIpXG5zdmcgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvc3ZnXCIpXG5qYm9uZSA9IHJlcXVpcmUgXCJqYm9uZVwiXG5cbkhlYWRlclZpZXcgPSB2aWV3LmV4dGVuZFxuXG4gIGNsYXNzTmFtZTogXCJiaW9qc19tc2FfbWFya2VyXCJcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsXCJjaGFuZ2U6c3RlcFNpemUgY2hhbmdlOmxhYmVsV2lkdGggY2hhbmdlOmNvbHVtbldpZHRoIGNoYW5nZTptYXJrZXJTdGVwU2l6ZSBjaGFuZ2U6bWFya2VyRm9udHNpemVcIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy52aXMsXCJjaGFuZ2U6bGFiZWxzIGNoYW5nZTptZXRhY2VsbFwiLCBAcmVuZGVyXG4gICAgQG1hbmFnZUV2ZW50cygpXG5cbiAgcmVuZGVyOiAtPlxuICAgIGRvbS5yZW1vdmVBbGxDaGlsZHMgQGVsXG5cbiAgICBAZWwuc3R5bGUuZm9udFNpemUgPSBAZy56b29tZXIuZ2V0IFwibWFya2VyRm9udHNpemVcIlxuXG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcInNwYW5cIlxuICAgIG4gPSAwXG4gICAgY2VsbFdpZHRoID0gQGcuem9vbWVyLmdldCBcImNvbHVtbldpZHRoXCJcblxuICAgIG5NYXggPSBAbW9kZWwuZ2V0TWF4TGVuZ3RoKClcbiAgICBzdGVwU2l6ZSA9IEBnLnpvb21lci5nZXQoXCJzdGVwU2l6ZVwiKVxuICAgIGhpZGRlbiA9IEBnLmNvbHVtbnMuZ2V0IFwiaGlkZGVuXCJcblxuICAgIHdoaWxlIG4gPCBuTWF4XG4gICAgICBpZiBoaWRkZW4uaW5kZXhPZihuKSA+PSAwXG4gICAgICAgIEBtYXJrZXJIaWRkZW4oc3BhbixuLCBzdGVwU2l6ZSlcbiAgICAgICAgbiArPSBzdGVwU2l6ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgXCJzcGFuXCJcbiAgICAgIHNwYW4uc3R5bGUud2lkdGggPSAoY2VsbFdpZHRoICogc3RlcFNpemUpICsgXCJweFwiXG4gICAgICBzcGFuLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgICAjIFRPRE86IHRoaXMgZG9lc24ndCB3b3JrIGZvciBhIGxhcmdlciBzdGVwU2l6ZVxuICAgICAgaWYgKG4gKyAxKSAlIEBnLnpvb21lci5nZXQoJ21hcmtlclN0ZXBTaXplJykgaXMgMFxuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gKG4gKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCIuXCJcbiAgICAgIHNwYW4ucm93UG9zID0gblxuXG4gICAgICBuICs9IHN0ZXBTaXplXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQgc3BhblxuXG4gICAgQGVsLmFwcGVuZENoaWxkIGNvbnRhaW5lclxuICAgIEBcblxuICBtYXJrZXJIaWRkZW46IChzcGFuLG4sc3RlcFNpemUpIC0+XG4gICAgaGlkZGVuID0gQGcuY29sdW1ucy5nZXQoXCJoaWRkZW5cIikuc2xpY2UgMFxuXG4gICAgbWluID0gTWF0aC5tYXggMCwgbiAtIHN0ZXBTaXplXG4gICAgcHJldkhpZGRlbiA9IHRydWVcbiAgICBmb3IgaiBpbiAgW21pbiAuLiBuXSBieSAxXG4gICAgICBwcmV2SGlkZGVuICY9IGhpZGRlbi5pbmRleE9mKGopID49IDBcblxuICAgICMgZmlsdGVyIGR1cGxpY2F0ZXNcbiAgICByZXR1cm4gaWYgcHJldkhpZGRlblxuXG4gICAgbk1heCA9IEBtb2RlbC5nZXRNYXhMZW5ndGgoKVxuXG4gICAgbGVuZ3RoID0gMFxuICAgIGluZGV4ID0gLTFcbiAgICAjIGFjY3VtbGF0ZSBtdWx0aXBsZSByb3dzXG4gICAgZm9yIG4gaW4gW24uLm5NYXhdIGJ5IDFcbiAgICAgIGluZGV4ID0gaGlkZGVuLmluZGV4T2YobikgdW5sZXNzIGluZGV4ID49IDAjIHNldHMgdGhlIGZpcnN0IGluZGV4XG4gICAgICBpZiBoaWRkZW4uaW5kZXhPZihuKSA+PSAwXG4gICAgICAgIGxlbmd0aCsrXG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrXG5cbiAgICBzID0gc3ZnLmJhc2UgaGVpZ2h0OiAxMCwgd2lkdGg6IDEwXG4gICAgcy5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIlxuICAgIHRyaWFuZ2xlID0gc3ZnLnBvbHlnb24gcG9pbnRzOiBcIjAsMCA1LDUgMTAsMFwiLCBzdHlsZTpcbiAgICAgIFwiZmlsbDpsaW1lO3N0cm9rZTpwdXJwbGU7c3Ryb2tlLXdpZHRoOjFcIlxuICAgIGpib25lKHRyaWFuZ2xlKS5vbiBcImNsaWNrXCIsIChldnQpID0+XG4gICAgICBoaWRkZW4uc3BsaWNlIGluZGV4LCBsZW5ndGhcbiAgICAgIEBnLmNvbHVtbnMuc2V0IFwiaGlkZGVuXCIsIGhpZGRlblxuXG4gICAgcy5hcHBlbmRDaGlsZCB0cmlhbmdsZVxuICAgIHNwYW4uYXBwZW5kQ2hpbGQgc1xuICAgIHJldHVybiBzXG5cbiAgbWFuYWdlRXZlbnRzOiAtPlxuICAgIGV2ZW50cyA9IHt9XG4gICAgaWYgQGcuY29uZmlnLmdldCBcInJlZ2lzdGVyTW91c2VDbGlja3NcIlxuICAgICAgZXZlbnRzLmNsaWNrID0gXCJfb25jbGlja1wiXG4gICAgaWYgQGcuY29uZmlnLmdldCBcInJlZ2lzdGVyTW91c2VIb3ZlclwiXG4gICAgICBldmVudHMubW91c2VpbiA9IFwiX29ubW91c2VpblwiXG4gICAgICBldmVudHMubW91c2VvdXQgPSBcIl9vbm1vdXNlb3V0XCJcbiAgICBAZGVsZWdhdGVFdmVudHMgZXZlbnRzXG4gICAgQGxpc3RlblRvIEBnLmNvbmZpZywgXCJjaGFuZ2U6cmVnaXN0ZXJNb3VzZUhvdmVyXCIsIEBtYW5hZ2VFdmVudHNcbiAgICBAbGlzdGVuVG8gQGcuY29uZmlnLCBcImNoYW5nZTpyZWdpc3Rlck1vdXNlQ2xpY2tcIiwgQG1hbmFnZUV2ZW50c1xuXG4gIF9vbmNsaWNrOiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IGV2dC50YXJnZXQucm93UG9zXG4gICAgc3RlcFNpemUgPSBAZy56b29tZXIuZ2V0KFwic3RlcFNpemVcIilcbiAgICBAZy50cmlnZ2VyIFwiY29sdW1uOmNsaWNrXCIsIHtyb3dQb3M6IHJvd1BvcyxzdGVwU2l6ZTogc3RlcFNpemUsIGV2dDpldnR9XG5cbiAgX29ubW91c2VpbjogKGV2dCkgLT5cbiAgICByb3dQb3MgPSBAZy56b29tZXIuZ2V0IFwic3RlcFNpemVcIiAqIGV2dC5yb3dQb3NcbiAgICBzdGVwU2l6ZSA9IEBnLnpvb21lci5nZXQoXCJzdGVwU2l6ZVwiKVxuICAgIEBnLnRyaWdnZXIgXCJjb2x1bW46bW91c2VpblwiLCB7cm93UG9zOiByb3dQb3Msc3RlcFNpemU6IHN0ZXBTaXplLCBldnQ6ZXZ0fVxuXG4gIF9vbm1vdXNlb3V0OiAoZXZ0KSAtPlxuICAgIHJvd1BvcyA9IEBnLnpvb21lci5nZXQgXCJzdGVwU2l6ZVwiICogZXZ0LnJvd1Bvc1xuICAgIHN0ZXBTaXplID0gQGcuem9vbWVyLmdldChcInN0ZXBTaXplXCIpXG4gICAgQGcudHJpZ2dlciBcImNvbHVtbjptb3VzZW91dFwiLCB7cm93UG9zOiByb3dQb3Msc3RlcFNpemU6IHN0ZXBTaXplLCBldnQ6ZXZ0fVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclZpZXdcbiIsIk1hcmtlclZpZXcgPSByZXF1aXJlIFwiLi9NYXJrZXJWaWV3XCJcbkNvbnNlcnZhdGlvblZpZXcgPSByZXF1aXJlIFwiLi9Db25zZXJ2YXRpb25WaWV3XCJcbmJvbmVWaWV3ID0gcmVxdWlyZShcImJhY2tib25lLWNoaWxkc1wiKVxuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5TZXFMb2dvV3JhcHBlciA9IHJlcXVpcmUgXCIuL1NlcUxvZ29XcmFwcGVyXCJcbkdhcFZpZXcgPSByZXF1aXJlIFwiLi9HYXBWaWV3XCJcblxubW9kdWxlLmV4cG9ydHMgPSBib25lVmlldy5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBibG9ja0V2ZW50cyA9IGZhbHNlXG5cbiAgICBAbGlzdGVuVG8gQGcudmlzLFwiY2hhbmdlOmhlYWRlclwiLCAtPlxuICAgICAgQGRyYXcoKVxuICAgICAgQHJlbmRlcigpXG4gICAgQGxpc3RlblRvIEBnLnZpcyxcImNoYW5nZVwiLCBAX3NldFNwYWNlclxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsXCJjaGFuZ2U6YWxpZ25tZW50V2lkdGhcIiwgQF9zZXRXaWR0aFxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsIFwiY2hhbmdlOl9hbGlnbm1lbnRTY3JvbGxMZWZ0XCIsIEBfYWRqdXN0U2Nyb2xsaW5nTGVmdFxuXG4gICAgIyBUT0RPOiBkdXBsaWNhdGUgcmVuZGVyaW5nXG4gICAgQGxpc3RlblRvIEBnLmNvbHVtbnMsIFwiY2hhbmdlOmhpZGRlblwiLCAtPlxuICAgICAgQGRyYXcoKVxuICAgICAgQHJlbmRlcigpXG5cbiAgICBAZHJhdygpXG5cbiAgICBAZy52aXMub25jZSAnY2hhbmdlOmxvYWRlZCcsIEBfYWRqdXN0U2Nyb2xsaW5nTGVmdCwgQFxuXG4gIGV2ZW50czpcbiAgICBcInNjcm9sbFwiOiBcIl9zZW5kU2Nyb2xsRXZlbnRcIlxuXG4gIGRyYXc6IC0+XG4gICAgQHJlbW92ZVZpZXdzKClcblxuICAgIGlmIEBnLnZpcy5nZXQgXCJjb25zZXJ2XCJcbiAgICAgIGNvbnNlcnYgPSBuZXcgQ29uc2VydmF0aW9uVmlldyB7bW9kZWw6IEBtb2RlbCwgZzogQGd9XG4gICAgICBjb25zZXJ2Lm9yZGVyaW5nID0gLTIwXG4gICAgICBAYWRkVmlldyBcImNvbnNlcnZcIixjb25zZXJ2XG5cbiAgICBpZiBAZy52aXMuZ2V0IFwibWFya2Vyc1wiXG4gICAgICBtYXJrZXIgPSBuZXcgTWFya2VyVmlldyB7bW9kZWw6IEBtb2RlbCwgZzogQGd9XG4gICAgICBtYXJrZXIub3JkZXJpbmcgPSAtMTBcbiAgICAgIEBhZGRWaWV3IFwibWFya2VyXCIsbWFya2VyXG5cbiAgICBpZiBAZy52aXMuZ2V0IFwic2VxbG9nb1wiXG4gICAgICBzZXFsb2dvID0gbmV3IFNlcUxvZ29XcmFwcGVyIHttb2RlbDogQG1vZGVsLCBnOiBAZ31cbiAgICAgIHNlcWxvZ28ub3JkZXJpbmcgPSAtMzBcbiAgICAgIEBhZGRWaWV3IFwic2VxbG9nb1wiLHNlcWxvZ29cblxuICAgIGlmIEBnLnZpcy5nZXQgXCJnYXBIZWFkZXJcIlxuICAgICAgZ2FwdmlldyA9IG5ldyBHYXBWaWV3IHttb2RlbDogQG1vZGVsLCBnOiBAZ31cbiAgICAgIGdhcHZpZXcub3JkZXJpbmcgPSAtMjVcbiAgICAgIEBhZGRWaWV3IFwiZ2Fwdmlld1wiLGdhcHZpZXdcblxuICByZW5kZXI6IC0+XG4gICAgQHJlbmRlclN1YnZpZXdzKClcblxuICAgIEBfc2V0U3BhY2VyKClcblxuICAgIEBlbC5jbGFzc05hbWUgPSBcImJpb2pzX21zYV9yaGVhZGVyXCJcbiAgICBAZWwuc3R5bGUub3ZlcmZsb3dYID0gXCJhdXRvXCJcbiAgICBAZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICAjQGVsLnN0eWxlLmhlaWdodCA9IEBnLnpvb21lci5nZXQoXCJtYXJrZXJIZWlnaHRcIikgKyBcInB4XCJcbiAgICBAX3NldFdpZHRoKClcbiAgICBAX2FkanVzdFNjcm9sbGluZ0xlZnQoKVxuICAgIEBcblxuICAjIHNjcm9sbExlZnQgdHJpZ2dlcnMgYSByZWZsb3cgb2YgdGhlIHdob2xlIGFyZWEgKGV2ZW4gb25seSBnZXQpXG4gIF9zZW5kU2Nyb2xsRXZlbnQ6IC0+XG4gICAgdW5sZXNzIEBibG9ja0V2ZW50c1xuICAgICAgQGcuem9vbWVyLnNldCBcIl9hbGlnbm1lbnRTY3JvbGxMZWZ0XCIsIEBlbC5zY3JvbGxMZWZ0LCB7b3JpZ2luOiBcImhlYWRlclwifVxuICAgIEBibG9ja0V2ZW50cyA9IGZhbHNlXG5cbiAgX2FkanVzdFNjcm9sbGluZ0xlZnQ6IChtb2RlbCx2YWx1ZSxvcHRpb25zKSAtPlxuICAgIGlmIChub3Qgb3B0aW9ucz8ub3JpZ2luPykgb3Igb3B0aW9ucy5vcmlnaW4gaXNudCBcImhlYWRlclwiXG4gICAgICBzY3JvbGxMZWZ0ID0gQGcuem9vbWVyLmdldCBcIl9hbGlnbm1lbnRTY3JvbGxMZWZ0XCJcbiAgICAgIEBibG9ja0V2ZW50cyA9IHRydWVcbiAgICAgIEBlbC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdFxuXG4gIF9zZXRTcGFjZXI6IC0+XG4gICAgIyBzcGFjZXIgLyBwYWRkaW5nIGVsZW1lbnRcbiAgICBAZWwuc3R5bGUubWFyZ2luTGVmdCA9IEBfZ2V0TGFiZWxXaWR0aCgpICsgXCJweFwiXG5cbiAgX2dldExhYmVsV2lkdGg6IC0+XG4gICAgcGFkZGluZ0xlZnQgPSAwXG4gICAgdW5sZXNzIEBnLnZpcy5nZXQgXCJsZWZ0SGVhZGVyXCJcbiAgICAgIHBhZGRpbmdMZWZ0ICs9IEBnLnpvb21lci5nZXRMZWZ0QmxvY2tXaWR0aCgpXG4gICAgcmV0dXJuIHBhZGRpbmdMZWZ0XG5cbiAgX3NldFdpZHRoOiAtPlxuICAgIEBlbC5zdHlsZS53aWR0aCA9IEBnLnpvb21lci5nZXRBbGlnbm1lbnRXaWR0aCgpICsgXCJweFwiXG4iLCJTZXFMb2dvVmlldyA9IHJlcXVpcmUgXCJiaW9qcy12aXMtc2VxbG9nby9saWdodFwiXG52aWV3ID0gcmVxdWlyZShcImJhY2tib25lLXZpZXdqXCIpXG5cbiMgdGhpcyBpcyBhIGJyaWRnZSBiZXR3ZWVuIHRoZSBNU0EgYW5kIHRoZSBzZXFsb2dvIHZpZXdlclxubW9kdWxlLmV4cG9ydHMgPSB2aWV3LmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGxpc3RlblRvIEBnLnpvb21lcixcImNoYW5nZTphbGlnbm1lbnRXaWR0aFwiLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEBnLmNvbG9yc2NoZW1lLCBcImNoYW5nZVwiLCAtPlxuICAgICAgY29sb3JzID0gQGcuY29sb3JzY2hlbWUuZ2V0U2VsZWN0ZWRTY2hlbWUoKVxuICAgICAgQHNlcWxvZ28uY2hhbmdlQ29sb3JzIGNvbG9yc1xuICAgICAgQHJlbmRlcigpXG5cbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLFwiY2hhbmdlOmNvbHVtbldpZHRoXCIsIC0+XG4gICAgICAgIEBzZXFsb2dvLmNvbHVtbl93aWR0aCA9IEBnLnpvb21lci5nZXQoJ2NvbHVtbldpZHRoJylcbiAgICAgIEByZW5kZXJcblxuICAgICNAbGlzdGVuVG8gQGcuem9vbWVyLFwiY2hhbmdlOmNvbHVtbldpZHRoIGNoYW5nZTpyb3dIZWlnaHRcIiwgLT5cblxuICAgIEBkcmF3KClcblxuXG4gIGRyYXc6IC0+XG4gICAgY29uc29sZS5sb2cgXCJyZWRyYXdcIlxuICAgIGFyciA9IEBnLnN0YXRzLmNvbnNlcnZSZXNpZHVlIHtzY2FsZWQ6IHRydWV9XG4gICAgYXJyID0gXy5tYXAgYXJyLCAoZWwpIC0+XG4gICAgICBfLnBpY2sgZWwsIChlLGspIC0+XG4gICAgICAgIGsgaXNudCBcIi1cIlxuICAgIGRhdGEgPVxuICAgICAgYWxwaGFiZXQ6IFwiYWFcIlxuICAgICAgaGVpZ2h0QXJyOiBhcnJcblxuICAgIGNvbG9ycyA9IEBnLmNvbG9yc2NoZW1lLmdldFNlbGVjdGVkU2NoZW1lKClcbiAgICAjIFRPRE86IHNlcWxvZ28gbWlnaHQgaGF2ZSBwcm9ibGVtcyB3aXRoIHRydWUgZHluYW1pYyBzY2hlbWVzXG4gICAgQHNlcWxvZ28gPSBuZXcgU2VxTG9nb1ZpZXcge21vZGVsOiBAbW9kZWwsIGc6IEBnLCBkYXRhOiBkYXRhLCB5YXhpczpmYWxzZVxuICAgICAgICAsc2Nyb2xsZXI6IGZhbHNlLHhheGlzOiBmYWxzZSwgaGVpZ2h0OiAxMDAsIGNvbHVtbl93aWR0aDogQGcuem9vbWVyLmdldCgnY29sdW1uV2lkdGgnKVxuICAgICAgICAscG9zaXRpb25NYXJrZXI6IGZhbHNlLCB6b29tOiAxLCBlbDogQGVsLGNvbG9yczogY29sb3JzfVxuXG4gIHJlbmRlcjogLT5cbiAgICBAc2VxbG9nby5yZW5kZXIoKVxuIiwiTGFiZWxSb3dWaWV3ID0gcmVxdWlyZSBcIi4vTGFiZWxSb3dWaWV3XCJcbmJvbmVWaWV3ID0gcmVxdWlyZShcImJhY2tib25lLWNoaWxkc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJvbmVWaWV3LmV4dGVuZFxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGRyYXcoKVxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsIFwiY2hhbmdlOl9hbGlnbm1lbnRTY3JvbGxUb3BcIiwgQF9hZGp1c3RTY3JvbGxpbmdUb3BcbiAgICBAZy52aXMub25jZSAnY2hhbmdlOmxvYWRlZCcsIEBfYWRqdXN0U2Nyb2xsaW5nVG9wICwgQFxuXG4gICAgQGxpc3RlblRvIEBnLnpvb21lcixcImNoYW5nZTphbGlnbm1lbnRIZWlnaHRcIiwgQF9zZXRIZWlnaHRcbiAgICBAbGlzdGVuVG8gQG1vZGVsLFwiY2hhbmdlOnJlZmVyZW5jZVwiLCBAZHJhd1xuXG4gIGRyYXc6IC0+XG4gICAgQHJlbW92ZVZpZXdzKClcbiAgICBmb3IgaSBpbiBbMC4uIEBtb2RlbC5sZW5ndGggLSAxXSBieSAxXG4gICAgICBjb250aW51ZSBpZiBAbW9kZWwuYXQoaSkuZ2V0KCdoaWRkZW4nKVxuICAgICAgdmlldyA9IG5ldyBMYWJlbFJvd1ZpZXcge21vZGVsOiBAbW9kZWwuYXQoaSksIGc6IEBnfVxuICAgICAgdmlldy5vcmRlcmluZyA9IGlcbiAgICAgIEBhZGRWaWV3IFwicm93XyN7aX1cIiwgdmlld1xuXG4gIGV2ZW50czpcbiAgICBcInNjcm9sbFwiOiBcIl9zZW5kU2Nyb2xsRXZlbnRcIlxuXG4gICMgYnJvYWRjYXN0IHRoZSBzY3JvbGxpbmcgZXZlbnQgKGJ5IHRoZSBzY3JvbGxiYXIpXG4gIF9zZW5kU2Nyb2xsRXZlbnQ6IC0+XG4gICAgQGcuem9vbWVyLnNldCBcIl9hbGlnbm1lbnRTY3JvbGxUb3BcIiwgQGVsLnNjcm9sbFRvcCwge29yaWdpbjogXCJsYWJlbFwifVxuXG4gICMgc2V0cyB0aGUgc2Nyb2xsaW5nIHByb3BlcnR5IChmcm9tIGFub3RoZXIgZXZlbnQgZS5nLiBkcmFnZ2luZylcbiAgX2FkanVzdFNjcm9sbGluZ1RvcDogLT5cbiAgICBAZWwuc2Nyb2xsVG9wID0gIEBnLnpvb21lci5nZXQgXCJfYWxpZ25tZW50U2Nyb2xsVG9wXCJcblxuICByZW5kZXI6IC0+XG4gICAgQHJlbmRlclN1YnZpZXdzKClcbiAgICBAZWwuY2xhc3NOYW1lID0gXCJiaW9qc19tc2FfbGFiZWxibG9ja1wiXG4gICAgQGVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgQGVsLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiXG4gICAgQGVsLnN0eWxlLm92ZXJmbG93WSA9IFwiYXV0b1wiXG4gICAgQGVsLnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCJcbiAgICBAZWwuc3R5bGUuZm9udFNpemUgPSBcIiN7QGcuem9vbWVyLmdldCgnbGFiZWxGb250c2l6ZScpfXB4XCJcbiAgICBAZWwuc3R5bGUubGluZUhlaWdodCA9IFwiI3tAZy56b29tZXIuZ2V0IFwibGFiZWxMaW5lSGVpZ2h0XCJ9XCJcbiAgICBAX3NldEhlaWdodCgpXG4gICAgQFxuXG5cbiAgX3NldEhlaWdodDogLT5cbiAgICBAZWwuc3R5bGUuaGVpZ2h0ID0gQGcuem9vbWVyLmdldChcImFsaWdubWVudEhlaWdodFwiKSArIFwicHhcIlxuIiwiYm9uZVZpZXcgPSByZXF1aXJlKFwiYmFja2JvbmUtY2hpbGRzXCIpXG5MYWJlbFZpZXcgPSByZXF1aXJlKFwiLi9MYWJlbFZpZXdcIilcbk1ldGFWaWV3ID0gcmVxdWlyZShcIi4vTWV0YVZpZXdcIilcblxubW9kdWxlLmV4cG9ydHMgPSBib25lVmlldy5leHRlbmRcblxuICBpbml0aWFsaXplOiAoZGF0YSkgLT5cbiAgICBAZyA9IGRhdGEuZ1xuICAgIEBkcmF3KClcblxuICAgIEBsaXN0ZW5UbyBAZy52aXMsXCJjaGFuZ2U6bGFiZWxzXCIsIEBkcmF3UlxuICAgIEBsaXN0ZW5UbyBAZy52aXMsXCJjaGFuZ2U6bWV0YWNlbGxcIiwgQGRyYXdSXG4gICAgQGxpc3RlblRvIEBnLnpvb21lciwgXCJjaGFuZ2U6cm93SGVpZ2h0XCIsIC0+XG4gICAgICBAZWwuc3R5bGUuaGVpZ2h0ID0gQGcuem9vbWVyLmdldChcInJvd0hlaWdodFwiKSArIFwicHhcIlxuXG4gICAgQGxpc3RlblRvIEBnLnNlbGNvbCxcImNoYW5nZSByZXNldCBhZGRcIiwgQHNldFNlbGVjdGlvblxuXG4gIGRyYXc6IC0+XG4gICAgQHJlbW92ZVZpZXdzKClcbiAgICBpZiBAZy52aXMuZ2V0IFwibGFiZWxzXCJcbiAgICAgIEBhZGRWaWV3IFwibGFiZWxzXCIsIG5ldyBMYWJlbFZpZXcge21vZGVsOiBAbW9kZWwsIGc6QGd9XG4gICAgaWYgQGcudmlzLmdldCBcIm1ldGFjZWxsXCJcbiAgICAgIG1ldGEgPSBuZXcgTWV0YVZpZXcge21vZGVsOiBAbW9kZWwsIGc6QGd9XG4gICAgICBAYWRkVmlldyBcIm1ldGFjZWxsXCIsIG1ldGFcblxuICBkcmF3UjogLT5cbiAgICBAZHJhdygpXG4gICAgQHJlbmRlcigpXG5cbiAgcmVuZGVyOiAtPlxuICAgIEByZW5kZXJTdWJ2aWV3cygpXG5cbiAgICBAZWwuc2V0QXR0cmlidXRlIFwiY2xhc3NcIiwgXCJiaW9qc19tc2FfbGFiZWxyb3dcIlxuICAgIEBlbC5zdHlsZS5oZWlnaHQgPSBAZy56b29tZXIuZ2V0KFwicm93SGVpZ2h0XCIpICogKEBtb2RlbC5hdHRyaWJ1dGVzLmhlaWdodCB8fCAxKSArIFwicHhcIlxuXG4gICAgQHNldFNlbGVjdGlvbigpXG4gICAgQFxuXG4gIHNldFNlbGVjdGlvbjogLT5cbiAgICBzZWwgPSBAZy5zZWxjb2wuZ2V0U2VsRm9yUm93IEBtb2RlbC5pZFxuICAgIGlmIHNlbC5sZW5ndGggPiAwXG4gICAgICBAZWwuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiXG4gICAgZWxzZVxuICAgICAgQGVsLnN0eWxlLmZvbnRXZWlnaHQgPSBcIm5vcm1hbFwiXG4iLCJ2aWV3ID0gcmVxdWlyZShcImJhY2tib25lLXZpZXdqXCIpXG5kb20gPSByZXF1aXJlIFwiZG9tLWhlbHBlclwiXG5cbkxhYmVsVmlldyA9IHZpZXcuZXh0ZW5kXG5cbiAgaW5pdGlhbGl6ZTogKGRhdGEpIC0+XG4gICAgQHNlcSA9IGRhdGEuc2VxXG4gICAgQGcgPSBkYXRhLmdcblxuICAgIEBtYW5hZ2VFdmVudHMoKVxuXG4gIG1hbmFnZUV2ZW50czogLT5cbiAgICBldmVudHMgPSB7fVxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlQ2xpY2tzXCJcbiAgICAgIGV2ZW50cy5jbGljayA9IFwiX29uY2xpY2tcIlxuICAgIGlmIEBnLmNvbmZpZy5nZXQgXCJyZWdpc3Rlck1vdXNlSG92ZXJcIlxuICAgICAgZXZlbnRzLm1vdXNlaW4gPSBcIl9vbm1vdXNlaW5cIlxuICAgICAgZXZlbnRzLm1vdXNlb3V0ID0gXCJfb25tb3VzZW91dFwiXG4gICAgQGRlbGVnYXRlRXZlbnRzIGV2ZW50c1xuICAgIEBsaXN0ZW5UbyBAZy5jb25maWcsIFwiY2hhbmdlOnJlZ2lzdGVyTW91c2VIb3ZlclwiLCBAbWFuYWdlRXZlbnRzXG4gICAgQGxpc3RlblRvIEBnLmNvbmZpZywgXCJjaGFuZ2U6cmVnaXN0ZXJNb3VzZUNsaWNrXCIsIEBtYW5hZ2VFdmVudHNcbiAgICBAbGlzdGVuVG8gQGcudmlzLCBcImNoYW5nZTpsYWJlbE5hbWUgY2hhbmdlOmxhYmVsSWQgY2hhbmdlOmxhYmVsUGFydGl0aW9uIGNoYW5nZTpsYWJlbENoZWNrYm94XCIsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpsYWJlbElkTGVuZ3RoIGNoYW5nZTpsYWJlbE5hbWVMZW5ndGhcbiAgICBjaGFuZ2U6bGFiZWxQYXJ0TGVuZ3RoIGNoYW5nZTpsYWJlbENoZWNrTGVuZ3RoXCIsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8gQGcuem9vbWVyLCBcImNoYW5nZTpsYWJlbEZvbnRTaXplIGNoYW5nZTpsYWJlbExpbmVIZWlnaHRcbiAgICBjaGFuZ2U6bGFiZWxXaWR0aCBjaGFuZ2U6cm93SGVpZ2h0XCIsIEByZW5kZXJcblxuICByZW5kZXI6IC0+XG4gICAgZG9tLnJlbW92ZUFsbENoaWxkcyBAZWxcblxuICAgIEBlbC5zdHlsZS53aWR0aCA9IFwiI3tAZy56b29tZXIuZ2V0TGFiZWxXaWR0aCgpfXB4XCJcbiAgICAjQGVsLnN0eWxlLmhlaWdodCA9IFwiI3tAZy56b29tZXIuZ2V0IFwicm93SGVpZ2h0XCJ9cHhcIlxuICAgIEBlbC5zZXRBdHRyaWJ1dGUgXCJjbGFzc1wiLCBcImJpb2pzX21zYV9sYWJlbHNcIlxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJsYWJlbENoZWNrYm94XCJcbiAgICAgIGNoZWNrQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcImlucHV0XCJcbiAgICAgIGNoZWNrQm94LnNldEF0dHJpYnV0ZSBcInR5cGVcIiwgXCJjaGVja2JveFwiXG4gICAgICBjaGVja0JveC52YWx1ZSA9IEBtb2RlbC5nZXQoJ2lkJylcbiAgICAgIGNoZWNrQm94Lm5hbWUgPSBcInNlcVwiXG4gICAgICBjaGVja0JveC5zdHlsZS53aWR0aD0gQGcuem9vbWVyLmdldChcImxhYmVsQ2hlY2tMZW5ndGhcIikgKyBcInB4XCJcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBjaGVja0JveFxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJsYWJlbElkXCJcbiAgICAgIGlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcInNwYW5cIlxuICAgICAgdmFsICA9IEBtb2RlbC5nZXQgXCJpZFwiXG4gICAgICB1bmxlc3MgaXNOYU4gdmFsXG4gICAgICAgIHZhbCsrXG4gICAgICBpZC50ZXh0Q29udGVudCA9IHZhbFxuICAgICAgaWQuc3R5bGUud2lkdGggPSBAZy56b29tZXIuZ2V0KFwibGFiZWxJZExlbmd0aFwiKSArIFwicHhcIlxuICAgICAgaWQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBpZFxuXG4gICAgaWYgQC5nLnZpcy5nZXQgXCJsYWJlbFBhcnRpdGlvblwiXG4gICAgICBwYXJ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcInNwYW5cIlxuICAgICAgcGFydC5zdHlsZS53aWR0aD0gQGcuem9vbWVyLmdldChcImxhYmVsUGFydExlbmd0aFwiKSArIFwicHhcIlxuICAgICAgcGFydC50ZXh0Q29udGVudCA9IEBtb2RlbC5nZXQoXCJwYXJ0aXRpb25cIilcbiAgICAgIHBhcnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBpZFxuICAgICAgQGVsLmFwcGVuZENoaWxkIHBhcnRcblxuICAgIGlmIEAuZy52aXMuZ2V0IFwibGFiZWxOYW1lXCJcbiAgICAgIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50IFwic3BhblwiXG4gICAgICBuYW1lLnRleHRDb250ZW50ID0gQG1vZGVsLmdldChcIm5hbWVcIilcbiAgICAgIGlmIEBtb2RlbC5nZXQoXCJyZWZcIikgYW5kIEBnLmNvbmZpZy5nZXQgXCJoYXNSZWZcIlxuICAgICAgICBuYW1lLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIlxuICAgICAgbmFtZS5zdHlsZS53aWR0aD0gQGcuem9vbWVyLmdldChcImxhYmVsTmFtZUxlbmd0aFwiKSArIFwicHhcIlxuICAgICAgQGVsLmFwcGVuZENoaWxkIG5hbWVcblxuICAgIEBlbC5zdHlsZS5vdmVyZmxvdyA9IHNjcm9sbFxuICAgIEBlbC5zdHlsZS5mb250U2l6ZSA9IFwiI3tAZy56b29tZXIuZ2V0KCdsYWJlbEZvbnRzaXplJyl9cHhcIlxuICAgIEBcblxuICBfb25jbGljazogKGV2dCkgLT5cbiAgICBzZXFJZCA9IEBtb2RlbC5nZXQgXCJpZFwiXG4gICAgQGcudHJpZ2dlciBcInJvdzpjbGlja1wiLCB7c2VxSWQ6c2VxSWQsIGV2dDpldnR9XG5cbiAgX29ubW91c2VpbjogKGV2dCkgLT5cbiAgICBzZXFJZCA9IEBtb2RlbC5nZXQgXCJpZFwiXG4gICAgQGcudHJpZ2dlciBcInJvdzptb3VzZW91dFwiLCB7c2VxSWQ6c2VxSWQsIGV2dDpldnR9XG5cbiAgX29ubW91c2VvdXQ6IChldnQpIC0+XG4gICAgc2VxSWQgPSBAbW9kZWwuZ2V0IFwiaWRcIlxuICAgIEBnLnRyaWdnZXIgXCJyb3c6bW91c2VvdXRcIiwge3NlcUlkOnNlcUlkLCBldnQ6ZXZ0fVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhYmVsVmlld1xuIiwidmlldyA9IHJlcXVpcmUoXCJiYWNrYm9uZS12aWV3alwiKVxuTWVudUJ1aWxkZXIgPSByZXF1aXJlIFwiLi4vLi4vbWVudS9tZW51YnVpbGRlclwiXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbmRvbSA9IHJlcXVpcmUgXCJkb20taGVscGVyXCJcbnN0ID0gcmVxdWlyZSBcIm1zYS1zZXF0b29sc1wiXG5cbm1vZHVsZS5leHBvcnRzID0gTWV0YVZpZXcgPSB2aWV3LmV4dGVuZFxuXG4gIGNsYXNzTmFtZTogXCJiaW9qc19tc2FfbWV0YXZpZXdcIlxuXG4gIGluaXRpYWxpemU6IChkYXRhKSAtPlxuICAgIEBnID0gZGF0YS5nXG4gICAgQGxpc3RlblRvIEBnLnZpcywgXCJjaGFuZ2U6bWV0YWNlbGxcIiwgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAZy56b29tZXIsIFwiY2hhbmdlOm1ldGFXaWR0aFwiLCBAcmVuZGVyXG5cbiAgZXZlbnRzOlxuICAgIGNsaWNrOiBcIl9vbmNsaWNrXCJcbiAgICBtb3VzZWluOiBcIl9vbm1vdXNlaW5cIlxuICAgIG1vdXNlb3V0OiBcIl9vbm1vdXNlb3V0XCJcblxuICByZW5kZXI6IC0+XG4gICAgZG9tLnJlbW92ZUFsbENoaWxkcyBAZWxcblxuICAgIEBlbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuXG4gICAgd2lkdGggPSBAZy56b29tZXIuZ2V0TWV0YVdpZHRoKClcbiAgICBAZWwuc3R5bGUud2lkdGggPSB3aWR0aCAtIDEwXG4gICAgQGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9IDVcbiAgICBAZWwuc3R5bGUucGFkZGluZ0xlZnQgPSA1XG4gICAgIyBUT0RPOiB3aHkgZG8gd2UgbmVlZCB0byBkZWNyZWFzZSB0aGUgZm9udCBzaXplP1xuICAgICMgb3RoZXJ3aXNlIHdlIHNlZSBhIHNjcm9sbGJhclxuICAgIEBlbC5zdHlsZS5mb250U2l6ZSA9IFwiI3tAZy56b29tZXIuZ2V0KCdsYWJlbEZvbnRzaXplJykgLSAyfXB4XCJcblxuICAgIGlmIEAuZy52aXMuZ2V0IFwibWV0YUdhcHNcIlxuICAgICAgIyBhZGRzIGdhcHNcbiAgICAgIHNlcSA9IEBtb2RlbC5nZXQoJ3NlcScpXG4gICAgICBnYXBzID0gXy5yZWR1Y2Ugc2VxLCAoKG1lbW8sIGMpIC0+IG1lbW8rKyBpZiBjIGlzICctJzttZW1vKSwwXG4gICAgICBnYXBzID0gKGdhcHMgLyBzZXEubGVuZ3RoKS50b0ZpeGVkKDEpXG5cbiAgICAgICMgYXBwZW5kIGdhcCBjb3VudFxuICAgICAgZ2FwU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ3NwYW4nXG4gICAgICBnYXBTcGFuLnRleHRDb250ZW50ID0gZ2Fwc1xuICAgICAgZ2FwU3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgZ2FwU3Bhbi5zdHlsZS53aWR0aCA9IDM1XG4gICAgICBAZWwuYXBwZW5kQ2hpbGQgZ2FwU3BhblxuXG5cbiAgICBpZiBALmcudmlzLmdldCBcIm1ldGFJZGVudGl0eVwiXG4gICAgICAjIGlkZW50aXR5XG4gICAgICAjIFRPRE86IHRoZXJlIG11c3QgYmUgYSBiZXR0ZXIgd2F5IHRvIHBhc3MgdGhlIGlkXG4gICAgICBpZGVudCA9IEBnLnN0YXRzLmlkZW50aXR5KClbQG1vZGVsLmlkXVxuICAgICAgaWRlbnRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnc3BhbidcblxuICAgICAgaWYgQG1vZGVsLmdldChcInJlZlwiKSBhbmQgQGcuY29uZmlnLmdldCBcImhhc1JlZlwiXG4gICAgICAgIGlkZW50U3Bhbi50ZXh0Q29udGVudCA9IFwicmVmLlwiXG4gICAgICBlbHNlIGlmIGlkZW50P1xuICAgICAgICBpZGVudFNwYW4udGV4dENvbnRlbnQgPSBpZGVudC50b0ZpeGVkKDIpXG5cbiAgICAgIGlkZW50U3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgaWRlbnRTcGFuLnN0eWxlLndpZHRoID0gNDBcbiAgICAgIEBlbC5hcHBlbmRDaGlsZCBpZGVudFNwYW5cblxuICAgIGlmIEAuZy52aXMuZ2V0IFwibWV0YUxpbmtzXCJcbiAgICAgICMgVE9ETzogdGhpcyBtZW51IGJ1aWxkZXIgaXMganVzdCBhbiBleGFtcGxlIGhvdyBvbmUgY291bGQgY3VzdG9taXplIHRoaXNcbiAgICAgICMgdmlld1xuICAgICAgaWYgQG1vZGVsLmF0dHJpYnV0ZXMuaWRzXG4gICAgICAgIGxpbmtzID0gc3QuYnVpbGRMaW5rcyBAbW9kZWwuYXR0cmlidXRlcy5pZHNcbiAgICAgICAgaWYgXy5rZXlzKGxpbmtzKS5sZW5ndGggPiAwXG4gICAgICAgICAgbWVudSA9IG5ldyBNZW51QnVpbGRlcih7bmFtZTogXCLihpdcIn0pXG4gICAgICAgICAgY29uc29sZS5sb2cgXy5rZXlzKGxpbmtzKVxuICAgICAgICAgIF8uZWFjaCBsaW5rcywgKHZhbCwga2V5KSAtPlxuICAgICAgICAgICAgbWVudS5hZGROb2RlIGtleSwoZSkgLT5cbiAgICAgICAgICAgICAgd2luZG93Lm9wZW4gdmFsXG5cbiAgICAgICAgICBsaW5rRWwgPSBtZW51LmJ1aWxkRE9NKClcbiAgICAgICAgICBsaW5rRWwuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCJcbiAgICAgICAgICBAZWwuYXBwZW5kQ2hpbGQgbGlua0VsXG5cblxuICAgICNAZWwuc3R5bGUuaGVpZ2h0ID0gXCIje0BnLnpvb21lci5nZXQgXCJyb3dIZWlnaHRcIn1weFwiXG5cbiAgX29uY2xpY2s6IChldnQpIC0+XG4gICAgQGcudHJpZ2dlciBcIm1ldGE6Y2xpY2tcIiwge3NlcUlkOiBAbW9kZWwuZ2V0IFwiaWRcIiwgZXZ0OmV2dH1cblxuICBfb25tb3VzZWluOiAoZXZ0KSAtPlxuICAgIEBnLnRyaWdnZXIgXCJtZXRhOm1vdXNlaW5cIiwge3NlcUlkOiBAbW9kZWwuZ2V0IFwiaWRcIiwgZXZ0OmV2dH1cblxuICBfb25tb3VzZW91dDogKGV2dCkgLT5cbiAgICBAZy50cmlnZ2VyIFwibWV0YTptb3VzZW91dFwiLCB7c2VxSWQ6IEBtb2RlbC5nZXQgXCJpZFwiLCBldnQ6ZXZ0fVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxudmFyIENsdXN0YWwsIEdlbmVyaWNSZWFkZXIsIHN0O1xuXG5HZW5lcmljUmVhZGVyID0gcmVxdWlyZShcImJpb2pzLWlvLXBhcnNlclwiKTtcblxuc3QgPSByZXF1aXJlKFwibXNhLXNlcXRvb2xzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsdXN0YWwgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIGJsb2Nrc3RhdGUsIGNTZXEsIGssIGtleXMsIGxhYmVsLCBsaW5lLCBsaW5lcywgbWF0Y2gsIG9iaiwgcmVnZXgsIHNlcUNvdW50ZXIsIHNlcXMsIHNlcXVlbmNlO1xuICAgIHNlcXMgPSBbXTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBsaW5lcyA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICB9XG4gICAgaWYgKGxpbmVzWzBdLnNsaWNlKDAsIDYpID09PSAhXCJDTFVTVEFMXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQ0xVU1RBTCBIZWFkZXJcIik7XG4gICAgfVxuICAgIGsgPSAwO1xuICAgIGJsb2Nrc3RhdGUgPSAxO1xuICAgIHNlcUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlIChrIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICBrKys7XG4gICAgICBsaW5lID0gbGluZXNba107XG4gICAgICBpZiAoKGxpbmUgPT0gbnVsbCkgfHwgbGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYmxvY2tzdGF0ZSA9IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBibG9ja3N0YXRlID0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3QuY29udGFpbnMobGluZSwgXCIqXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2Nrc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICBzZXFDb3VudGVyID0gMDtcbiAgICAgICAgICBibG9ja3N0YXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZWdleCA9IC9eKD86XFxzKikoXFxTKykoPzpcXHMrKShcXFMrKSg/OlxccyopKFxcZCopKD86XFxzKnwkKS9nO1xuICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSk7XG4gICAgICAgIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgbGFiZWwgPSBtYXRjaFsxXTtcbiAgICAgICAgICBzZXF1ZW5jZSA9IG1hdGNoWzJdO1xuICAgICAgICAgIGlmIChzZXFDb3VudGVyID49IHNlcXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmogPSBzdC5nZXRNZXRhKGxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gb2JqLm5hbWU7XG4gICAgICAgICAgICBjU2VxID0gbmV3IHN0Lm1vZGVsKHNlcXVlbmNlLCBsYWJlbCwgc2VxQ291bnRlcik7XG4gICAgICAgICAgICBjU2VxLmlkcyA9IG9iai5pZHMgfHwge307XG4gICAgICAgICAgICBjU2VxLmRldGFpbHMgPSBvYmouZGV0YWlscyB8fCB7fTtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhjU2VxLmlkcyk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNTZXEuaWQgPSBjU2VxLmlkc1trZXlzWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcXMucHVzaChjU2VxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Vxc1tzZXFDb3VudGVyXS5zZXEgKz0gc2VxdWVuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcUNvdW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInBhcnNlIGVycm9yXCIsIGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXFzO1xuICB9XG59O1xuXG5HZW5lcmljUmVhZGVyLm1peGluKENsdXN0YWwpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMFxudmFyIEZhc3RhLCBHZW5lcmljUmVhZGVyLCBzdDtcblxuR2VuZXJpY1JlYWRlciA9IHJlcXVpcmUoXCJiaW9qcy1pby1wYXJzZXJcIik7XG5cbnN0ID0gcmVxdWlyZShcIm1zYS1zZXF0b29sc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYXN0YSA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgY3VycmVudFNlcSwga2V5cywgbGFiZWwsIGxpbmUsIG9iaiwgc2VxcywgX2ksIF9sZW47XG4gICAgc2VxcyA9IFtdO1xuICAgIGlmICghdGV4dCB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHQpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICB9XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0ZXh0Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBsaW5lID0gdGV4dFtfaV07XG4gICAgICBpZiAobGluZVswXSA9PT0gXCI+XCIgfHwgbGluZVswXSA9PT0gXCI7XCIpIHtcbiAgICAgICAgbGFiZWwgPSBsaW5lLnNsaWNlKDEpO1xuICAgICAgICBvYmogPSBzdC5nZXRNZXRhKGxhYmVsKTtcbiAgICAgICAgbGFiZWwgPSBvYmoubmFtZTtcbiAgICAgICAgY3VycmVudFNlcSA9IG5ldyBzdC5tb2RlbChcIlwiLCBsYWJlbCwgc2Vxcy5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50U2VxLmlkcyA9IG9iai5pZHMgfHwge307XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50U2VxLmlkcyk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50U2VxLmlkID0gY3VycmVudFNlcS5pZHNba2V5c1swXV07XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFNlcS5kZXRhaWxzID0gb2JqLmRldGFpbHMgfHwge307XG4gICAgICAgIHNlcXMucHVzaChjdXJyZW50U2VxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRTZXEuc2VxICs9IGxpbmU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXFzO1xuICB9LFxuICB3cml0ZTogZnVuY3Rpb24oc2VxcywgYWNjZXNzKSB7XG4gICAgdmFyIHNlcSwgdGV4dCwgX2ksIF9sZW47XG4gICAgdGV4dCA9IFwiXCI7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzZXFzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBzZXEgPSBzZXFzW19pXTtcbiAgICAgIGlmIChhY2Nlc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXEgPSBhY2Nlc3Moc2VxKTtcbiAgICAgIH1cbiAgICAgIHRleHQgKz0gXCI+XCIgKyBzZXEubmFtZSArIFwiXFxuXCI7XG4gICAgICB0ZXh0ICs9IChzdC5zcGxpdE5DaGFycyhzZXEuc2VxLCA4MCkpLmpvaW4oXCJcXG5cIik7XG4gICAgICB0ZXh0ICs9IFwiXFxuXCI7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG59O1xuXG5HZW5lcmljUmVhZGVyLm1peGluKEZhc3RhKTtcbiIsIi8qXG4gKiBiaW9qcy1pby1nZmZcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbmlmeS9iaW9qcy1pby1nZmZcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgZ3JlZW5pZnlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMiBsaWNlbnNlLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKFwiYmlvanMtaW8tcGFyc2VyXCIpO1xuXG52YXIgZ2ZmID0gZnVuY3Rpb24oKSB7fTtcbnBhcnNlci5taXhpbihnZmYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdmZjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgamFsdmlldyA9IHJlcXVpcmUoXCIuL2phbHZpZXdcIik7XG5cbi8qKlxuICogTWV0aG9kIHJlc3BvbnNpYmxlIHRvIHBhcnNlIEdGRlxuICogQHNlZSBodHRwczovL3d3dy5zYW5nZXIuYWMudWsvcmVzb3VyY2VzL3NvZnR3YXJlL2dmZi9zcGVjLmh0bWwjdF8yXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgYmlvanNpb2dmZi5wYXJzZSgnU0VRMSAgRU1CTCAgYXRnICAxMDMgIDEwNSAgLiAgKyAgMCcpO1xuICpcbiAqIEBtZXRob2QgcGFyc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlIEdGRiBmaWxlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvblxuICovXG5cbmdmZi5wYXJzZUxpbmVzID0gZnVuY3Rpb24oZmlsZSkge1xuICB2YXIgbGluZXMgPSBmaWxlLnNwbGl0KFwiXFxuXCIpO1xuICB2YXIgY29uZmlnID0ge307XG4gIHZhciBhcnIgPSBbXTtcbiAgY29uZmlnLnR5cGUgPSBnZmYuX2d1ZXNzVHlwZShsaW5lcyk7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBpZiAoY29uZmlnLnR5cGUgPT09IFwiamFsdmlld1wiKSB7XG4gICAgdmFyIHJldCA9IGphbHZpZXcucmVhZEhlYWRlcihsaW5lcyk7XG4gICAgLy9jb25zb2xlLmxvZyhyZXQpO1xuICAgIG9mZnNldCA9IHJldC5vZmZzZXQ7XG4gICAgY29uZmlnLmNvbG9ycyA9IHJldC5jb2xvcnM7XG4gICAgYXJyID0gcmV0LmZlYXR1cmVzO1xuICB9XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGlnbm9yZSBjb21tZW50cyBmb3Igbm93XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDAgfHwgbGluZVswXSA9PT0gXCIjXCIpXG4gICAgICBjb250aW51ZTtcblxuICAgIGxpbmUgPSBnZmYucGFyc2VMaW5lKGxpbmUpO1xuICAgIGlmIChsaW5lICE9PSB1bmRlZmluZWQpXG4gICAgICBhcnIucHVzaChsaW5lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZlYXR1cmVzOiBhcnIsXG4gICAgY29uZmlnOiBjb25maWdcbiAgfTtcbn07XG5cbmdmZi5fZ3Vlc3NUeXBlID0gZnVuY3Rpb24obGluZSkge1xuICBpZiAobGluZVswXS5zdWJzdHJpbmcoMCwgMTUpID09PSBcIiMjZ2ZmLXZlcnNpb24gM1wiKSB7XG4gICAgcmV0dXJuIFwiZ2ZmM1wiO1xuICB9IGVsc2UgaWYgKGxpbmVbMF0uaW5kZXhPZihcIiNcIikgPCAwICYmIGxpbmVbMF0uc3BsaXQoXCJcXHRcIikubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gbm8gY29tbWVudHMgYW5kIHR3byBjb2x1bW5zLiBsZXQncyBob3BlIHRoaXMgaXMgZnJvbSBqYWx2aWV3XG4gICAgcmV0dXJuIFwiamFsdmlld1wiO1xuICB9XG4gIC8vIHVuYWJsZSB0byByZWFkIGZpbGUgaGVhZGVyLiBsZXRzIGhvcGUgdGhpcyBpcyBnZmYzXG4gIHJldHVybiBcImdmZjNcIjtcbn07XG5cbi8qKlxuICogcGFyc2VzIEdGRiBhbmQgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgYWxsIHNlcXMgd2l0aCB0aGVpciBmZWF0dXJlc1xuICogQG1ldGhvZCBwYXJzZVNlcXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlIEdGRiBmaWxlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgZGljdGlvbmFyeSBvZiBzZXF1ZW5jZXMgd2l0aCBhbiBhcnJheSBvZiB0aGVpciBmZWF0dXJlc1xuICovXG5nZmYucGFyc2VTZXFzID0gZ2ZmLnBhcnNlID0gZnVuY3Rpb24oZmlsZSkge1xuICB2YXIgb2JqID0gZ2ZmLnBhcnNlTGluZXMgKGZpbGUpO1xuICB2YXIgc2VxcyA9IHt9O1xuICBvYmouZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgIHZhciBrZXkgPSBlbnRyeS5zZXFuYW1lO1xuICAgIGlmIChzZXFzW2tleV0gPT09IHVuZGVmaW5lZCkgc2Vxc1trZXldID0gW107XG4gICAgZGVsZXRlIGVudHJ5LnNlcW5hbWU7XG4gICAgc2Vxc1trZXldLnB1c2goZW50cnkpO1xuICB9KTtcbiAgZGVsZXRlIG9iai5mZWF0dXJlcztcbiAgb2JqLnNlcXMgPSBzZXFzO1xuICByZXR1cm4gb2JqO1xufTtcblxuLypcbiAqIHBhcnNlcyBvbmUgR0ZGIGxpbmUgYW5kIHJldHVybnMgaXRcbiAqL1xuZ2ZmLnBhcnNlTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHRMaW5lID0ge307XG5cbiAgdmFyIGNvbHVtbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gIC8vIGlnbm9yZSBlbXB0eSBsaW5lc1xuICBpZiAoY29sdW1ucy5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIHRMaW5lLnNlcW5hbWUgPSBjb2x1bW5zWzBdO1xuICB0TGluZS5zb3VyY2UgPSBjb2x1bW5zWzFdO1xuICB0TGluZS5mZWF0dXJlID0gY29sdW1uc1syXTtcbiAgdExpbmUuc3RhcnQgPSBwYXJzZUludChjb2x1bW5zWzNdKTtcbiAgdExpbmUuZW5kID0gcGFyc2VJbnQoY29sdW1uc1s0XSk7XG4gIHRMaW5lLnNjb3JlID0gY29sdW1uc1s1XTsgLy8gb25seSBETkEsUk5BXG4gIHRMaW5lLnN0cmFuZCA9IGNvbHVtbnNbNl07IC8vIG9ubHkgRE5BLFJOQVxuICB0TGluZS5mcmFtZSA9IGNvbHVtbnNbN107IC8vIG9ubHkgRE5BLFJOQVxuICB2YXIgYXR0ciA9IGNvbHVtbnMuc2xpY2UoOCkuam9pbihcIiBcIik7IC8vIHBsYWluIHRleHQgY29tbWVudHNcblxuICAvLyByZW1vdmUgdW5kZWZpbmVkIChkb3QpXG4gIE9iamVjdC5rZXlzKHRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICh0TGluZVtrZXldID09PSBcIi5cIikge1xuICAgICAgdExpbmVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHBhcnNlIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgaWYgKHRMaW5lLnNjb3JlKSB7XG4gICAgdExpbmUuc2NvcmUgPSBwYXJzZUZsb2F0KHRMaW5lLnNjb3JlKTtcbiAgfVxuICBpZiAodExpbmUuZnJhbWUpIHtcbiAgICB0TGluZS5mcmFtZSA9IHBhcnNlSW50KHRMaW5lLmZyYW1lKTtcbiAgfVxuXG4gIHRMaW5lLmF0dHJpYnV0ZXMgPSB1dGlscy5leHRyYWN0S2V5cyhhdHRyKTtcbiAgcmV0dXJuIHRMaW5lO1xufTtcblxuZ2ZmLmV4cG9ydExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBhdHRycyA9IE9iamVjdC5rZXlzKGxpbmUuYXR0cmlidXRlcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBrZXkgKyBcIj1cIiArIGxpbmUuYXR0cmlidXRlc1trZXldO1xuICB9KS5qb2luKFwiO1wiKTtcbiAgdmFyIGNlbGxzID0gW2xpbmUuc2VxbmFtZSwgbGluZS5zb3VyY2UsIGxpbmUuZmVhdHVyZSwgbGluZS5zdGFydCwgbGluZS5lbmQsIGxpbmUuc2NvcmUsXG4gICAgbGluZS5zdHJhbmQsIGxpbmUuZnJhbWUsIGF0dHJzXG4gIF07XG4gIGNlbGxzID0gY2VsbHMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbiAgcmV0dXJuIGNlbGxzLmpvaW4oXCJcXHRcIik7XG59O1xuXG5nZmYuZXhwb3J0TGluZXMgPSBmdW5jdGlvbihsaW5lcykge1xuICByZXR1cm4gXCIjI2dmZi12ZXJzaW9uIDNcXG5cIiArIGxpbmVzLm1hcChnZmYuZXhwb3J0TGluZSkuam9pbihcIlxcblwiKTtcbn07XG5cbmdmZi5leHBvcnRTZXFzID0gZ2ZmLmV4cG9ydCA9IGZ1bmN0aW9uKHNlcXMpIHtcbiAgdmFyIGxpbmVzID0gW107XG4gIHZhciBwTGluZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnNlcW5hbWUgPSBrZXk7XG4gICAgbGluZXMucHVzaChlKTtcbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gc2Vxcykge1xuICAgIHNlcXNba2V5XS5mb3JFYWNoKHBMaW5lKTtcbiAgfVxuICByZXR1cm4gZ2ZmLmV4cG9ydExpbmVzKGxpbmVzKTtcbn07XG4iLCIvLyBicm93c2VyIGdsb2JhbHNcbmlmICh0eXBlb2YgYmlvanMgPT09ICd1bmRlZmluZWQnKSB7XG4gIGJpb2pzID0ge307XG59XG5pZiAodHlwZW9mIGJpb2pzLnZpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmlvanMudmlzID0ge307XG59XG4vLyB1c2UgdHdvIG5hbWVzcGFjZXNcbndpbmRvdy5tc2EgPSBiaW9qcy52aXMubXNhID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9pbmRleCcpO1xuXG4vLyBUT0RPOiBob3cgc2hvdWxkIHRoaXMgYmUgYnVuZGxlZFxuXG5pZiAodHlwZW9mIGJpb2pzLmlvID09PSAndW5kZWZpbmVkJykge1xuICBiaW9qcy5pbyA9IHt9O1xufVxuXG4vLyBqdXN0IGJ1bmRsZSB0aGUgdHdvIHBhcnNlcnNcbndpbmRvdy5iaW9qcy5pby5mYXN0YSA9IHJlcXVpcmUoXCJiaW9qcy1pby1mYXN0YVwiKTtcbndpbmRvdy5iaW9qcy5pby5jbHVzdGFsID0gcmVxdWlyZShcImJpb2pzLWlvLWNsdXN0YWxcIik7XG53aW5kb3cuYmlvanMueGhyID0gcmVxdWlyZShcInhoclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXhcIik7XG5cbnJlcXVpcmUoJy4vY3NzL21zYS5jc3MnKTtcbiIsInZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJ3BhcnNlLWhlYWRlcnMnKVxuXG52YXIgbWVzc2FnZXMgPSB7XG4gICAgXCIwXCI6IFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIixcbiAgICBcIjRcIjogXCI0eHggQ2xpZW50IEVycm9yXCIsXG4gICAgXCI1XCI6IFwiNXh4IFNlcnZlciBFcnJvclwiXG59XG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IFhEUigpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IFhIUigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIga2V5XG4gICAgdmFyIGxvYWQgPSBvcHRpb25zLnJlc3BvbnNlID8gbG9hZFJlc3BvbnNlIDogbG9hZFhoclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvclxuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIC8vIGhhdGUgSUVcbiAgICB4aHIub250aW1lb3V0ID0gbm9vcFxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCAob3B0aW9ucy5jb3JzICYmIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzICE9PSBmYWxzZSkpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBcInRpbWVvdXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50aW1lb3V0IDogNTAwMFxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cbiAgICBcbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiBcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gbnVsbFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgZ2V0dGluZyBhIG5vbmUtb2sgc3RhdHVzQ29kZSwgYnVpbGQgJiByZXR1cm4gYW4gZXJyb3JcbiAgICBmdW5jdGlvbiBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cywgYm9keSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDAgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBib2R5IDogZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbU3RyaW5nKHN0YXR1cykuY2hhckF0KDApXVxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvclxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkUmVzcG9uc2UoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMsIGJvZHkpXG4gICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJhdzogeGhyXG4gICAgICAgIH1cbiAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgYW5kIGFkZCBzb21lIHJlc3BvbnNlIHByb3BlcnRpZXMgdG8gdGhlIHNvdXJjZSB4aHJcbiAgICAvLyBhbmQgdGhlbiByZXNwb25kIHdpdGggdGhhdFxuICAgIGZ1bmN0aW9uIGxvYWRYaHIoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpXG5cbiAgICAgICAgeGhyLnN0YXR1cyA9IHhoci5zdGF0dXNDb2RlID0gc3RhdHVzXG4gICAgICAgIHhoci5ib2R5ID0gZ2V0Qm9keSgpXG4gICAgICAgIHhoci5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcblxuICAgICAgICBjYWxsYmFjayhlcnJvciwgeGhyLCB4aHIuYm9keSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihldnQpIHtcbiAgICAgICAgY2FsbGJhY2soZXZ0LCB4aHIpXG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIl19